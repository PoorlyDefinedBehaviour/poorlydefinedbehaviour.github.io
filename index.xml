<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title></title>
    <link>https://poorlydefinedbehaviour.github.io/</link>
    <description>Recent content on </description>
    <image>
      <title></title>
      <url>https://poorlydefinedbehaviour.github.io/papermod-cover.png</url>
      <link>https://poorlydefinedbehaviour.github.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 28 Mar 2023 20:30:00 -0300</lastBuildDate><atom:link href="https://poorlydefinedbehaviour.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Thinking about failure, fair-loss links and two generals</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/fair_loss_links_and_two_generals/</link>
      <pubDate>Tue, 28 Mar 2023 20:30:00 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/fair_loss_links_and_two_generals/</guid>
      <description>It feels like most people are not used to thinking about how things can fail, programming as if things always work as expected is the default modus operandi of most engineers i have talked to. Some examples that come to mind: http requests without handling responses that don&amp;rsquo;t have status 200, no timeouts, no retries, publishing a message to kafka and them updating a database, having a web client orchestrate a transaction across several systems without thinking: what if the user closes the browser tab?</description>
    </item>
    
    <item>
      <title>The simple way to avoid deadlocks</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/the_simple_way_to_avoid_deadlocks/</link>
      <pubDate>Sat, 25 Mar 2023 20:35:00 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/the_simple_way_to_avoid_deadlocks/</guid>
      <description>A deadlock happens when there&amp;rsquo;s at least one resource that can be only acquired by one process at a time and there&amp;rsquo;s a process P1 that is waiting to acquire a resource currently held by a process P2 and P2 is waiting to acquire a resource currently held by P1.
The word process does not mean we are talking about just OS processes.
There are two processes: Process A wants to acquire a lock on resource 1 and then a lock on resource 2.</description>
    </item>
    
    <item>
      <title>Database anomalies and isolation levels</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/isolation_levels/</link>
      <pubDate>Fri, 24 Mar 2023 15:43:00 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/isolation_levels/</guid>
      <description>Anomalies An anomaly or read phenomena can happen when a transaction reads data that may have been modified by another concurrent transaction.
Dirty read A dirty read happens when a transaction T1 reads data that has been modified by a concurrent transaction T2 that has not has been committed or rolled back yet. T1 ends up working with stale data if T2 does not commit.
T2 starts executing and sets x to a new value, T1 starts executing and reads x, the value of x is the value just set by T2, T2 rolls back, the value of x is not persisted to the database but T1 will move forward with the stale value of x that was written before T2 rolled back.</description>
    </item>
    
    <item>
      <title>Avoid overloading your systems: Request coalescing</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/request_coalescing/</link>
      <pubDate>Sun, 19 Mar 2023 20:54:00 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/request_coalescing/</guid>
      <description>The problem You are developing an application backed by a database, something happens and then several of your users try to access the same content. Several requests are sent to your backend at almost the same time and your backend hits the database once for each request to fetch the same data.
Fetching the data only once If N requests asking for the same data arrive at the backend at around the same time, the backend could hit the database to fetch the data when the first request arrives and force the other requests to await until the data is fetched.</description>
    </item>
    
    <item>
      <title>Do Go programs with common data races compile in Rust?</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/rust_compile_time_safety_1/</link>
      <pubDate>Mon, 23 May 2022 20:39:07 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/rust_compile_time_safety_1/</guid>
      <description>Uber has adopted Go as its primary programming language for developing microservices and has a post on its blog called Data Race Patterns in Go where they talk about data races found in their Go codebase.
I was reading it and thought to myself that many of the problems presented in the post would not even compile in Rust. Can Rust help us avoid writing code with common data races?</description>
    </item>
    
    <item>
      <title>Logs</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/logs/</link>
      <pubDate>Sat, 30 Apr 2022 16:46:09 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/logs/</guid>
      <description>What is a log A log is just a immutable sequence of records wih strong ordering semantics that can be used to provide durability, replication and to model consensus. It is usually a 0 indexed file that new entries are appended to because expensive disk seeks can usually be avoided when appending to a file1.
Not to be confused with the type of logs most people are used to: application logs that are meant to be read by humans although application logs are a degenerative case of the log we are talking about2.</description>
    </item>
    
    <item>
      <title>Contributing to Rust and tokio</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/contributing_to_tokio/</link>
      <pubDate>Sun, 17 Apr 2022 14:29:20 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/contributing_to_tokio/</guid>
      <description>Contributing for the first time I have been trying to force myself to do harder things lately in order to practice and learn new things. Since i&amp;rsquo;m doing Rust full time now, i thought it would be a good a idea to contribute to the ecosystem, so i went and enabled notifications for a bunch of Rust related projects and for the Rust project itself.
I thought i would be able to keep up with the notifications.</description>
    </item>
    
    <item>
      <title>Why Rc&lt;T&gt; is not Send</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/why_rc_is_not_send/</link>
      <pubDate>Sun, 27 Mar 2022 17:20:07 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/why_rc_is_not_send/</guid>
      <description>Why Rc cannot be sent between threads We get a compile error if we try to send Rc&amp;lt;T&amp;gt; to another thread:
use std::rc::Rc; fn main() { let rc = Rc::new(1); std::thread::spawn(|| { println!(&amp;#34;{}&amp;#34;, *rc); }) .join(); } error[E0277]: `Rc&amp;lt;i32&amp;gt;` cannot be shared between threads safely --&amp;gt; src/main.rs:5:3 | 5 | std::thread::spawn(|| { | ^^^^^^^^^^^^^^^^^^ `Rc&amp;lt;i32&amp;gt;` cannot be shared between threads safely | = help: the trait `Sync` is not implemented for `Rc&amp;lt;i32&amp;gt;` = note: required because of the requirements on the impl of `Send` for `&amp;amp;Rc&amp;lt;i32&amp;gt;` = note: required because it appears within the type `[closure@src/main.</description>
    </item>
    
    <item>
      <title>Token bucket</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/token_bucket/</link>
      <pubDate>Sun, 20 Mar 2022 22:21:07 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/token_bucket/</guid>
      <description>Intro Token bucket is an algorithm that can be used to rate limit requests made or received by a service.
How it works The algorithm is called token bucket because of the way it works: imagine we have a bucket with x tokens where each accepted request consumes one token from the bucket and a token is added back to the bucket at an interval.
A bucket with 1 token that is refilled each second means the service accepts one request per second.</description>
    </item>
    
    <item>
      <title>Notes taken from the Raft paper</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/raft_notes/</link>
      <pubDate>Fri, 04 Mar 2022 17:48:19 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/raft_notes/</guid>
      <description>Replicated And Fault Tolerant Raft is a consensus algorithm for managing a replicated log.
The authors claim Raft to be more understandable than Paxos because Raft separates the key elements of consensus
Leader election Log replication Safety and enforces a stronger degree of coherency to reduce the number of states that must be considered.
Raft also includes a new mechanism for changing cluster membership.
What is a consensus algorithm Consensus algorithms allow a collection of machines to work as a coherent group that can survive the failures of some of its members.</description>
    </item>
    
    <item>
      <title>Bloom filter</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/bloom_filter/</link>
      <pubDate>Thu, 03 Mar 2022 20:56:31 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/bloom_filter/</guid>
      <description>What&amp;rsquo;s a Bloom filter A bloom filter is a data-structure that can be used to check if a set contains an element. It uses way less memory than a conventional set data-structure by sacrificing accuracy.
Example Say we are building a log-structured merge-tree, we can use a bloom filter to find out if the LSM-tree contains a particular key in O(1) time in most cases, the downside is that sometimes the bloom filter would say that the LSM-tree contains a key, but it actually does not and we would go searching for the value that&amp;rsquo;s mapped to the key and never actually find it.</description>
    </item>
    
    
    
  </channel>
</rss>
