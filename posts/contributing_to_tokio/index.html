<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Contributing to Rust and tokio |</title><meta name=keywords content><meta name=description content="Contributing for the first time I have been trying to force myself to do harder things lately in order to practice and learn new things. Since i&rsquo;m doing Rust full time now, i thought it would be a good a idea to contribute to the ecosystem, so i went and enabled notifications for a bunch of Rust related projects and for the Rust project itself.
I thought i would be able to keep up with the notifications."><meta name=author content="poorlydefinedbehaviour"><link rel=canonical href=https://poorlydefinedbehaviour.github.io/posts/contributing_to_tokio/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://poorlydefinedbehaviour.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://poorlydefinedbehaviour.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://poorlydefinedbehaviour.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://poorlydefinedbehaviour.github.io/apple-touch-icon.png><link rel=mask-icon href=https://poorlydefinedbehaviour.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Contributing to Rust and tokio"><meta property="og:description" content="Contributing for the first time I have been trying to force myself to do harder things lately in order to practice and learn new things. Since i&rsquo;m doing Rust full time now, i thought it would be a good a idea to contribute to the ecosystem, so i went and enabled notifications for a bunch of Rust related projects and for the Rust project itself.
I thought i would be able to keep up with the notifications."><meta property="og:type" content="article"><meta property="og:url" content="https://poorlydefinedbehaviour.github.io/posts/contributing_to_tokio/"><meta property="og:image" content="https://poorlydefinedbehaviour.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-17T14:29:20-03:00"><meta property="article:modified_time" content="2022-04-17T14:29:20-03:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://poorlydefinedbehaviour.github.io/papermod-cover.png"><meta name=twitter:title content="Contributing to Rust and tokio"><meta name=twitter:description content="Contributing for the first time I have been trying to force myself to do harder things lately in order to practice and learn new things. Since i&rsquo;m doing Rust full time now, i thought it would be a good a idea to contribute to the ecosystem, so i went and enabled notifications for a bunch of Rust related projects and for the Rust project itself.
I thought i would be able to keep up with the notifications."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://poorlydefinedbehaviour.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Contributing to Rust and tokio","item":"https://poorlydefinedbehaviour.github.io/posts/contributing_to_tokio/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Contributing to Rust and tokio","name":"Contributing to Rust and tokio","description":"Contributing for the first time I have been trying to force myself to do harder things lately in order to practice and learn new things. Since i\u0026rsquo;m doing Rust full time now, i thought it would be a good a idea to contribute to the ecosystem, so i went and enabled notifications for a bunch of Rust related projects and for the Rust project itself.\nI thought i would be able to keep up with the notifications.","keywords":[],"articleBody":"Contributing for the first time I have been trying to force myself to do harder things lately in order to practice and learn new things. Since i’m doing Rust full time now, i thought it would be a good a idea to contribute to the ecosystem, so i went and enabled notifications for a bunch of Rust related projects and for the Rust project itself.\nI thought i would be able to keep up with the notifications. I was wrong. (obviously) I actually go through a few notifications each day in hope to find something to work on.\nFirst tokio contribution Rust supports async await but it does not come with a runtime by default. It is left for the user to define which runtime their program will use and tokio is the most popular one.\nI was going through my notifications as usual and one issue caught my attention: someone wanted to add a method to get the address the UdpSocket is connected to.\nIt seemed easy enough so i went and claimed it:\nThe implementation was actually pretty simple since mio already had a method that does exact what i needed.\nFrom mio Github repository: Mio is a fast, low-level I/O library for Rust focusing on non-blocking APIs and event notification for building high performance I/O apps with as little overhead as possible over the OS abstractions.\nEverything went as expected and my change got released on tokio 1.18.0.\nFirst Rust contribution A few days went by and a Rust issue caught my attention: a compiler message was incorrect, it turns out, fixing compiler messages is one of the main ways people start contributing to the Rust compiler.\nAnyway, Rust is known for its nice error messages, it does have good error messages indeed but they come at a development cost. The Rust compiler has several functions and methods just to decide which error message to show the user.\nThe offender It is actually valid to add : after a type variable\nfn foo\u003cT:\u003e(t: T) { t.clone(); } note the : after T\nThe compiler would then complain that Clone is not impleted for T and suggest it to be implemented\nerror[E0599]: no method named `clone` found for type parameter `T` in the current scope --\u003e src/lib.rs:2:7 | 2 | t.clone(); | ^^^^^ method not found in `T` | = help: items from traits can only be used if the type parameter is bounded by the trait help: the following trait defines an item `clone`, perhaps you need to restrict type parameter `T` with it: | 1 | fn foo(t: T) { | ~~~~~~~~ note there is an extra : after Clone in the suggestion\nI thought it was easy enough and decided to fix it.\nTesting that the compiler error messages are correct is pretty easy, Rust calls this type of test an ui test.\nAll i needed to do was to add a file containing the code that’s supposed to error to the ui folder.\n~src/test/ui/traits/issue-95898.rs // Test for #95898: The trait suggestion had an extra `:` after the trait. // edition:2021 fn foo\u003cT:\u003e(t: T) { t.clone(); //~^ ERROR no method named `clone` found for type parameter `T` in the current scope } fn main() {} ~^ ERROR tells the test runner that the error is expected and the test fails if the error does not occur\nand a .stderr file containing the expected error message\n~src/test/ui/traits/issue-95898.stderr error[E0599]: no method named `clone` found for type parameter `T` in the current scope --\u003e $DIR/issue-95898.rs:5:7 | LL | t.clone(); | ^^^^^ method not found in `T` | = help: items from traits can only be used if the type parameter is bounded by the trait help: the following trait defines an item `clone`, perhaps you need to restrict type parameter `T` with it: | LL | fn foo(t: T) { | ~~~~~~~~ error: aborting due to previous error For more information about this error, try `rustc --explain E0599`. Note that we expect the suggestion to be correct in the .stderr file\nIt took me some time to get used to the compiler but the fix was really easy thanks to WaffleLapkin who was working on a similar issue.\nSecond tokio contribution tokio has the join! macro that can be used when we want to wait for several futures to complete before doing something.\nThink Promise.all if javascript is your thing.\nasync fn process_something_1() { ... } async fn process_something_2() { ... } #[tokio::main] async fn main() { let (result_1, result_2) = tokio::join!(result_1, result_2); ... } Future based concurrency is a cooperative model, it is pretty easy for one task to monopolize processing time if we are not careful. One way to work around this problem is to not allow a task to run forever without being interrupted by giving each task a budget and force the task to yield control back to the runtime whenever its budget is exceeded.\nTask and Future will be used interchangeably\ntokio does the budget think per task and each time a task interacts with a resource, its budget is decreased until it reaches 0 and control is yielded back to the scheduler.\nEach task starts with a budget of 128 and the budget is consumed when interacting with a resource (a Semaphore, for example)\nuse std::sync::Arc; use std::time::Duration; use tokio::sync::Semaphore; async fn foo() { // Consuming a resource decreases the budget by 1. tokio::time::sleep(Duration).await; } async fn foo() { // Consuming a resource decreases the budget by 1. let _permit = permits.clone().acquire_owned().await.unwrap(); } #[tokio::main] async fn main() { let permits = Arc::new(Semaphore::new(1)); // NOTE: join! creates a new task with a budget of 128 let _ = tokio::join!( foo(), bar(Arc::clone(\u0026permits)), ); } The point of giving a budget to each task to stop bad tasks from starving other tasks but it turns out, it is still possible for one task to starve other tasks because join! polls every future inside the same task which means every future passed to join! shares the same task budget of 128.\nNote that join! creates a new task\nA task can starve other tasks by just consuming the whole budget of the task that invoked join! so by the time the other tasks passed to join! are polled, the budget is already 0 which causes them to yield control back to the runtime.\nuse std::sync::Arc; use tokio::sync::Semaphore; #[tokio::main] async fn main() { let permits = Arc::new(Semaphore::new(1)); // join! polls futures in the order they are passed to it. tokio::join!( // This future will be polled first. non_cooperative_task(Arc::clone(\u0026permits)), // This future will be polled second. poor_little_task(permits) ); } async fn non_cooperative_task(permits: Arc\u003cSemaphore\u003e) { // This future will yield back to the runtime after the loop runs 128 times. loop { let _permit = permits.clone().acquire_owned().await.unwrap(); } } // `non_cooperative_task` has been polled and now it is this futures turn. // The bad thing is that `non_cooperative_task` consumed the whole budget // and there's nothing left for this future to spend. async fn poor_little_task(permits: Arc\u003cSemaphore\u003e) { loop { // Even though this future should be able to acquire the Semaphore, // acquire_owned().await will return Poll::Pending because the budget of // the current task is 0. let _permit = permits.clone().acquire_owned().await.unwrap(); // This println! never gets to run. println!(\"Hello!\") } } Poll is the type returned when the runtime checks if a Future is completed. Poll::pending means the Future is not ready. In this case, the Future is actually ready but since it has no budget to spend, it pretends it isn’t ready.\nFirst try At first i thought we would just be able to give each future passed to join! its own budget instead of letting them share the current task budget.\nBy current task budget, i mean the budget of the task that invoked join!\njoin! is implemented as declarative macro\nmacro_rules! join { (@ { // One `_` for each branch in the `join!` macro. This is not used once // normalization is complete. ( $($count:tt)* ) // Normalized join! branches $( ( $($skip:tt)* ) $e:expr, )* }) =\u003e {{ use $crate::macros::support::{maybe_done, poll_fn, Future, Pin}; use $crate::macros::support::Poll::{Ready, Pending}; // Safety: nothing must be moved out of `futures`. This is to satisfy // the requirement of `Pin::new_unchecked` called below. let mut futures = ( $( maybe_done($e), )* ); poll_fn(move |cx| { let mut is_pending = false; $( // Extract the future for this branch from the tuple. let ( $($skip,)* fut, .. ) = \u0026mut futures; // Safety: future is stored on the stack above // and never moved. let mut fut = unsafe { Pin::new_unchecked(fut) }; // Try polling if fut.poll(cx).is_pending() { is_pending = true; } )* if is_pending { Pending } else { Ready(($({ // Extract the future for this branch from the tuple. let ( $($skip,)* fut, .. ) = \u0026mut futures; // Safety: future is stored on the stack above // and never moved. let mut fut = unsafe { Pin::new_unchecked(fut) }; fut.take_output().expect(\"expected completed future\") },)*)) } }).await }}; // ===== Normalize ===== (@ { ( $($s:tt)* ) $($t:tt)* } $e:expr, $($r:tt)* ) =\u003e { $crate::join!(@{ ($($s)* _) $($t)* ($($s)*) $e, } $($r)*) }; // ===== Entry point ===== ( $($e:expr),* $(,)?) =\u003e { $crate::join!(@{ () } $($e,)*) }; } So i went on and just gave each future its own budget before polling them.\nmacro_rules! join { ... $( // Extract the future for this branch from the tuple. let ( $($skip,)* fut, .. ) = \u0026mut futures; // Safety: future is stored on the stack above // and never moved. let mut fut = unsafe { Pin::new_unchecked(fut) }; // Try polling if crate::coop::budget(|| fut.poll(cx)).is_pending() { is_pending = true; } )* ... } Note that i added crate::coop::budget\nTurns out this doesn’t work. It is still pretty easy to create a future that never yields even though it consumes its whole budget:\n... loop { tokio::join!(sem.acquire()); } The future would spend its budget but not the budget of the surrounding task, causing it to never yield.\nSecond try Each time the task created by join! is polled, poll a different future first so as time goes by, every future gets a chance to make progress.\nI took a look at select! and it is able to do just that (up to 64 branches) so i took note and modified join!.\nmacro_rules! join { ... let mut start = 0; ... // BRANCHES is the number of futures passed to join!. for i in 0..BRANCHES { let branch; #[allow(clippy::modulo_one)] { branch = (start + i) % BRANCHES; } match { $( // $crate::count! will return the number of tokens passed to it // up to 64 tokens. $crate::count!( $($skip)* ) =\u003e { // Extract the future for this branch from the tuple. let ( $($skip,)* fut, .. ) = \u0026mut futures; // Safety: future is stored on the stack above // and never moved. let mut fut = unsafe { Pin::new_unchecked(fut) }; // Try polling if fut.poll(cx).is_pending() { is_pending = true; } } )* } #[allow(clippy::modulo_one)] { start = (start + 1) % BRANCHES; } ... } This actually works but $crate::count! can only count up to 64:\n#[macro_export] #[doc(hidden)] macro_rules! count { () =\u003e { 0 }; (_) =\u003e { 1 }; (_ _) =\u003e { 2 }; (_ _ _) =\u003e { 3 }; ... // up to 64 } aaaand… join! accepts up to 125 futures without changing the recursion limit so this solution wasn’t accepted because it would be a breaking change.\nThird try Start the polling round in a different future each time still seems like a good idea. To bypass $crate::count!’s limitation, i decided to use a procedural macro.\nNot actually showing code for this one because it is too long\nTurns out people don’t like procedural macros very much and it was not accepted.\nFourth try Still the same solution but implemented in a different way. What if instead of using $crate::count! inside the macro to get the index of a future, we counted up front?\njoin! already does some normalization before actually processing the input, so i modified the normalization branches to pair the future index with the future itself.\nmacro_rules! join { (@ { // One `_` for each branch in the `join!` macro. This is not used once // normalization is complete. ( $($count:tt)* ) // The expression `0+1+1+ ... +1` equal to the number of branches. ( $($total:tt)* ) // Normalized join! branches $( ( $($skip:tt)* ) ( $($branch_index:tt)* ) $e:expr, )* }) =\u003e {{ ... let mut start = 0; ... // BRANCHES is the number of futures passed to join!. for i in 0..BRANCHES { let branch; #[allow(clippy::modulo_one)] { branch = (start + i) % BRANCHES; } $( { const INDEX: u32 = $($branch_index)*; if branch == INDEX { // Extract the future for this branch from the tuple. let ( $($skip,)* fut, .. ) = \u0026mut futures; // Safety: future is stored on the stack above // and never moved. let mut fut = unsafe { Pin::new_unchecked(fut) }; // Try polling if fut.poll(cx).is_pending() { is_pending = true; } } } )* } #[allow(clippy::modulo_one)] { start = (start + 1) % BRANCHES; } ... }}; // ===== Normalize ===== (@ { ( $($s:tt)* ) ( $($n:tt)* ) $($t:tt)* } $e:expr, $($r:tt)* ) =\u003e { // i'm new ▼ $crate::join!(@{ ($($s)* _) ($($n)* + 1) $($t)* ($($s)*) ($($n)*) $e, } $($r)*) }; // ===== Entry point ===== ( $($e:expr),* $(,)?) =\u003e { // i'm new ▼ $crate::join!(@{ () (0) } $($e,)*) }; } It works but could be faster. Say we pass 5 futures to join!, how many times would the if statements that check if it is the future’s turn to be polled conditions be checked?\nFifth try (the last one) PR\nThe same idea still, poll a different future first every time, except we avoid checking if statement conditions without necessity.\nmacro_rules! join { (@ { // One `_` for each branch in the `join!` macro. This is not used once // normalization is complete. ( $($count:tt)* ) // The expression `0+1+1+ ... +1` equal to the number of branches. ( $($total:tt)* ) // Normalized join! branches $( ( $($skip:tt)* ) $e:expr, )* }) =\u003e {{ use $crate::macros::support::{maybe_done, poll_fn, Future, Pin}; use $crate::macros::support::Poll::{Ready, Pending}; // Safety: nothing must be moved out of `futures`. This is to satisfy // the requirement of `Pin::new_unchecked` called below. let mut futures = ( $( maybe_done($e), )* ); // Each time the future created by poll_fn is polled, a different future will be polled first // to ensure every future passed to join! gets a chance to make progress even if // one of the futures consumes the whole budget. // // This is number of futures that will be skipped in the first loop // iteration the next time. let mut skip_next_time: u32 = 0; poll_fn(move |cx| { const COUNT: u32 = $($total)*; let mut is_pending = false; let mut to_run = COUNT; // The number of futures that will be skipped in the first loop iteration. let mut skip = skip_next_time; skip_next_time = if skip + 1 == COUNT { 0 } else { skip + 1 }; // This loop runs twice and the first `skip` futures // are not polled in the first iteration. loop { $( if skip == 0 { if to_run == 0 { // Every future has been polled break; } to_run -= 1; // Extract the future for this branch from the tuple. let ( $($skip,)* fut, .. ) = \u0026mut futures; // Safety: future is stored on the stack above // and never moved. let mut fut = unsafe { Pin::new_unchecked(fut) }; // Try polling if fut.poll(cx).is_pending() { is_pending = true; } } else { // Future skipped, one less future to skip in the next iteration skip -= 1; } )* } if is_pending { Pending } else { Ready(($({ // Extract the future for this branch from the tuple. let ( $($skip,)* fut, .. ) = \u0026mut futures; // Safety: future is stored on the stack above // and never moved. let mut fut = unsafe { Pin::new_unchecked(fut) }; fut.take_output().expect(\"expected completed future\") },)*)) } }).await }}; } Thanks Honestly, i had a lot of help from Darksonn.\n","wordCount":"2705","inLanguage":"en","datePublished":"2022-04-17T14:29:20-03:00","dateModified":"2022-04-17T14:29:20-03:00","author":{"@type":"Person","name":"poorlydefinedbehaviour"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://poorlydefinedbehaviour.github.io/posts/contributing_to_tokio/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"https://poorlydefinedbehaviour.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://poorlydefinedbehaviour.github.io/ title=Home><span>Home</span></a></li><li><a href=https://poorlydefinedbehaviour.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://poorlydefinedbehaviour.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://poorlydefinedbehaviour.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://poorlydefinedbehaviour.github.io>Home</a>&nbsp;»&nbsp;<a href=https://poorlydefinedbehaviour.github.io/posts/>Posts</a></div><h1 class=post-title>Contributing to Rust and tokio</h1><div class=post-meta><span title='2022-04-17 14:29:20 -0300 -0300'>April 17, 2022</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;poorlydefinedbehaviour&nbsp;|&nbsp;<a href=https://github.com/PoorlyDefinedBehaviour/poorlydefinedbehaviour.github.io/tree/main/content/posts/contributing_to_tokio.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#contributing-for-the-first-time aria-label="Contributing for the first time">Contributing for the first time</a></li><li><a href=#first-tokio-contribution aria-label="First tokio contribution">First tokio contribution</a></li><li><a href=#first-rust-contribution aria-label="First Rust contribution">First Rust contribution</a><ul><li><a href=#the-offender aria-label="The offender">The offender</a></li></ul></li><li><a href=#second-tokio-contribution aria-label="Second tokio contribution">Second tokio contribution</a><ul><li><a href=#first-try aria-label="First try">First try</a></li><li><a href=#second-try aria-label="Second try">Second try</a></li><li><a href=#third-try aria-label="Third try">Third try</a></li><li><a href=#fourth-try aria-label="Fourth try">Fourth try</a></li><li><a href=#fifth-try-the-last-one aria-label="Fifth try (the last one)">Fifth try (the last one)</a></li></ul></li><li><a href=#thanks aria-label=Thanks>Thanks</a></li></ul></div></details></div><div class=post-content><h1 id=contributing-for-the-first-time>Contributing for the first time<a hidden class=anchor aria-hidden=true href=#contributing-for-the-first-time>#</a></h1><p>I have been trying to force myself to do harder things lately in order to practice and learn new things. Since i&rsquo;m doing <a href=https://www.rust-lang.org/>Rust</a> full time now, i thought it would be a good a idea to contribute to the ecosystem, so i went and enabled notifications for a bunch of <a href=https://www.rust-lang.org/>Rust</a> related projects and for the <a href=https://www.rust-lang.org/>Rust</a> project itself.</p><p align=center><img src=https://user-images.githubusercontent.com/17282221/167045101-fc8e894d-d5e6-4b75-9963-c97cc48fd557.png></p><p align=center><i>I thought i would be able to keep up with the notifications. I was wrong. (obviously)</i></p><p>I actually go through a few notifications each day in hope to find something to work on.</p><h1 id=first-tokio-contribution>First tokio contribution<a hidden class=anchor aria-hidden=true href=#first-tokio-contribution>#</a></h1><p><a href=https://www.rust-lang.org/>Rust</a> supports <a href=https://doc.rust-lang.org/std/keyword.async.html>async await</a> but it does not come with a <a href=https://www.ncameron.org/blog/what-is-an-async-runtime/>runtime</a> by default. It is left for the user to define which runtime their program will use and <a href=https://github.com/tokio-rs/tokio>tokio</a> is the most popular one.</p><p>I was going through my notifications as usual and one issue caught my attention: someone wanted to add a method to get the address the <a href=https://docs.rs/tokio/latest/tokio/net/struct.UdpSocket.html>UdpSocket</a> is connected to.</p><p>It seemed easy enough so i went and claimed it:</p><p align=center><img src=https://user-images.githubusercontent.com/17282221/167046100-d789d0d8-aa0d-49aa-8caf-ccbec9a15d52.png></p><p>The <a href=https://github.com/tokio-rs/tokio/pull/4611/files>implementation</a> was actually pretty simple since <a href=https://github.com/tokio-rs/mio>mio</a> already had a method that does exact what i needed.</p><blockquote><p>From <a href=https://github.com/tokio-rs/mio>mio</a> Github repository: Mio is a fast, low-level I/O library for Rust focusing on non-blocking APIs and event notification for building high performance I/O apps with as little overhead as possible over the OS abstractions.</p></blockquote><p>Everything went as expected and my change got released on tokio <a href=https://github.com/tokio-rs/tokio/pull/4641>1.18.0</a>.</p><h1 id=first-rust-contribution>First Rust contribution<a hidden class=anchor aria-hidden=true href=#first-rust-contribution>#</a></h1><p>A few days went by and a <a href=https://www.rust-lang.org/>Rust</a> issue caught my attention: a compiler message was incorrect, it turns out, fixing compiler messages is one of the main ways people start contributing to the <a href=https://www.rust-lang.org/>Rust</a> compiler.</p><p>Anyway, <a href=https://www.rust-lang.org/>Rust</a> is known for its nice error messages, it does have good error messages indeed but they come at a development cost. The <a href=https://www.rust-lang.org/>Rust</a> compiler has several functions and methods just to decide which error message to show the user.</p><h2 id=the-offender>The offender<a hidden class=anchor aria-hidden=true href=#the-offender>#</a></h2><p>It is actually valid to add <code>:</code> after a type variable</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>foo</span><span style=color:#f92672>&lt;</span>T:<span style=color:#f92672>&gt;</span>(t: <span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>  t.clone();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>note the <code>:</code> after <code>T</code></p></blockquote><p>The compiler would then complain that <a href=https://doc.rust-lang.org/std/clone/trait.Clone.html>Clone</a> is not impleted for <code>T</code> and suggest it to be implemented</p><pre tabindex=0><code class=language-terminal data-lang=terminal>error[E0599]: no method named `clone` found for type parameter `T` in the current scope
 --&gt; src/lib.rs:2:7
  |
2 |     t.clone();
  |       ^^^^^ method not found in `T`
  |
  = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `clone`, perhaps you need to restrict type parameter `T` with it:
  |
1 | fn foo&lt;T: Clone:&gt;(t: T) {
  |        ~~~~~~~~
</code></pre><blockquote><p>note there is an extra <code>:</code> after <code>Clone</code> in the suggestion</p></blockquote><p>I thought it was easy enough and decided to fix it.</p><p align=center><img src=https://user-images.githubusercontent.com/17282221/167047347-0354ba5b-44d7-42d4-b179-412f760758d8.png></p><p>Testing that the compiler error messages are correct is pretty easy, <a href=https://www.rust-lang.org/>Rust</a> calls this type of test an <code>ui</code> test.</p><p>All i needed to do was to add a file containing the code that&rsquo;s supposed to error to the <code>ui</code> folder.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#f92672>~</span>src<span style=color:#f92672>/</span>test<span style=color:#f92672>/</span>ui<span style=color:#f92672>/</span>traits<span style=color:#f92672>/</span>issue<span style=color:#f92672>-</span><span style=color:#ae81ff>95898.</span>rs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Test for #95898: The trait suggestion had an extra `:` after the trait.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// edition:2021
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>foo</span><span style=color:#f92672>&lt;</span>T:<span style=color:#f92672>&gt;</span>(t: <span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>    t.clone();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//~^ ERROR no method named `clone` found for type parameter `T` in the current scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {}
</span></span></code></pre></div><blockquote><p><code>~^ ERROR</code> tells the test runner that the error is expected and the test fails if the error does not occur</p></blockquote><p>and a <code>.stderr</code> file containing the expected error message</p><pre tabindex=0><code class=language-terminal data-lang=terminal>~src/test/ui/traits/issue-95898.stderr

error[E0599]: no method named `clone` found for type parameter `T` in the current scope
  --&gt; $DIR/issue-95898.rs:5:7
   |
LL |     t.clone();
   |       ^^^^^ method not found in `T`
   |
   = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `clone`, perhaps you need to restrict type parameter `T` with it:
   |
LL | fn foo&lt;T: Clone&gt;(t: T) {
   |        ~~~~~~~~

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
</code></pre><blockquote><p>Note that we expect the suggestion to be correct in the <code>.stderr</code> file</p></blockquote><p>It took me some time to get used to the compiler but the <a href=https://github.com/rust-lang/rust/pull/95991/files>fix</a> was really easy thanks to <a href=https://github.com/WaffleLapkin>WaffleLapkin</a> who was working on a similar issue.</p><h1 id=second-tokio-contribution>Second tokio contribution<a hidden class=anchor aria-hidden=true href=#second-tokio-contribution>#</a></h1><p><a href=https://github.com/tokio-rs/tokio>tokio</a> has the <a href=https://docs.rs/tokio/latest/tokio/macro.join.html>join!</a> macro that can be used when we want to wait for several futures to complete before doing something.</p><blockquote><p>Think <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all>Promise.all</a> if javascript is your thing.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>process_something_1</span>() { <span style=color:#f92672>..</span>. }
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>process_something_2</span>() { <span style=color:#f92672>..</span>. }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> (result_1, result_2) <span style=color:#f92672>=</span> tokio::join<span style=color:#f92672>!</span>(result_1, result_2);
</span></span><span style=display:flex><span>  <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://doc.rust-lang.org/std/future/trait.Future.html>Future</a> based concurrency is a <a href=https://en.wikipedia.org/wiki/Cooperative_multitasking>cooperative</a> model, it is pretty easy for one task to monopolize processing time if we are not careful. One way to work around this problem is to not allow a task to run forever without being interrupted by <a href=https://tokio.rs/blog/2020-04-preemption>giving each task a budget</a> and force the task to yield control back to the runtime whenever its budget is exceeded.</p><blockquote><p>Task and Future will be used interchangeably</p></blockquote><p><a href=https://github.com/tokio-rs/tokio>tokio</a> does the budget think per task and each time a task interacts with a resource, its budget is <a href=https://github.com/tokio-rs/tokio/blob/c5ff797dcfb44f003cc9cb2080a5f2544c3cca7f/tokio/src/coop.rs#L169>decreased</a> until it reaches 0 and control is yielded back to the scheduler.</p><p>Each task <a href=https://github.com/tokio-rs/tokio/blob/c5ff797dcfb44f003cc9cb2080a5f2544c3cca7f/tokio/src/coop.rs#L55>starts</a> with a budget of 128 and the budget is consumed when interacting with a resource (a <a href=https://docs.rs/tokio/0.2.6/tokio/sync/struct.Semaphore.html>Semaphore</a>, for example)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::sync::Arc;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::time::Duration;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> tokio::sync::Semaphore;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>foo</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Consuming a resource decreases the budget by 1.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  tokio::time::sleep(Duration).<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>foo</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Consuming a resource decreases the budget by 1.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> _permit <span style=color:#f92672>=</span> permits.clone().acquire_owned().<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> permits <span style=color:#f92672>=</span> Arc::new(Semaphore::new(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>  <span style=color:#75715e>// NOTE: join! creates a new task with a budget of 128
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> tokio::join<span style=color:#f92672>!</span>(
</span></span><span style=display:flex><span>    foo(),
</span></span><span style=display:flex><span>    bar(Arc::clone(<span style=color:#f92672>&amp;</span>permits)),
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The point of giving a budget to each task to stop bad tasks from starving other tasks but it turns out, it is still possible for one task to starve other tasks because <a href=https://docs.rs/tokio/latest/tokio/macro.join.html>join!</a> polls every future inside <a href=https://docs.rs/tokio/latest/tokio/macro.join.html#runtime-characteristics>the same task</a> which means every future passed to <a href=https://docs.rs/tokio/latest/tokio/macro.join.html>join!</a> shares the same task budget of <code>128</code>.</p><blockquote><p>Note that <code>join!</code> creates a new task</p></blockquote><p>A task can starve other tasks by just consuming the whole budget of the task that invoked <a href=https://docs.rs/tokio/latest/tokio/macro.join.html>join!</a> so by the time the other tasks passed to <a href=https://docs.rs/tokio/latest/tokio/macro.join.html>join!</a> are polled, the budget is already 0 which causes them to yield control back to the runtime.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::sync::Arc;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> tokio::sync::Semaphore;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> permits <span style=color:#f92672>=</span> Arc::new(Semaphore::new(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// join! polls futures in the order they are passed to it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  tokio::join<span style=color:#f92672>!</span>(
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This future will be polled first.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    non_cooperative_task(Arc::clone(<span style=color:#f92672>&amp;</span>permits)),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This future will be polled second.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    poor_little_task(permits)
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>non_cooperative_task</span>(permits: <span style=color:#a6e22e>Arc</span><span style=color:#f92672>&lt;</span>Semaphore<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// This future will yield back to the runtime after the loop runs 128 times.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> _permit <span style=color:#f92672>=</span> permits.clone().acquire_owned().<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// `non_cooperative_task` has been polled and now it is this futures turn.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The bad thing is that `non_cooperative_task` consumed the whole budget
</span></span></span><span style=display:flex><span><span style=color:#75715e>// and there&#39;s nothing left for this future to spend.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>poor_little_task</span>(permits: <span style=color:#a6e22e>Arc</span><span style=color:#f92672>&lt;</span>Semaphore<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Even though this future should be able to acquire the Semaphore,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// acquire_owned().await will return Poll::Pending because the budget of
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// the current task is 0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> _permit <span style=color:#f92672>=</span> permits.clone().acquire_owned().<span style=color:#66d9ef>await</span>.unwrap();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This println! never gets to run.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;Hello!&#34;</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p><a href=https://doc.rust-lang.org/stable/std/task/enum.Poll.html>Poll</a> is the type returned when the runtime checks if a <a href=https://doc.rust-lang.org/std/future/trait.Future.html>Future</a> is completed.
<a href=https://doc.rust-lang.org/stable/std/task/enum.Poll.html>Poll::pending</a> means the <a href=https://doc.rust-lang.org/std/future/trait.Future.html>Future</a> is not ready. In this case, the <a href=https://doc.rust-lang.org/std/future/trait.Future.html>Future</a> is actually ready but since it has no budget to spend, it pretends it isn&rsquo;t ready.</p></blockquote><h2 id=first-try>First try<a hidden class=anchor aria-hidden=true href=#first-try>#</a></h2><p>At first i thought we would just be able to give each future passed to <a href=https://docs.rs/tokio/latest/tokio/macro.join.html>join!</a> its own budget instead of letting them share the current task budget.</p><blockquote><p>By current task budget, i mean the budget of the task that invoked <code>join!</code></p></blockquote><p><a href=https://docs.rs/tokio/latest/tokio/macro.join.html>join!</a> is implemented as declarative macro</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>macro_rules! join {
</span></span><span style=display:flex><span>    (<span style=color:#f92672>@</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// One `_` for each branch in the `join!` macro. This is not used once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// normalization is complete.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ( <span style=color:#75715e>$($count</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Normalized join! branches
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>$(</span> ( <span style=color:#75715e>$($skip</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> ) <span style=color:#75715e>$e</span>:<span style=color:#a6e22e>expr</span>, )<span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }) <span style=color:#f92672>=&gt;</span> {{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> <span style=color:#75715e>$crate</span>::macros::support::{maybe_done, poll_fn, Future, Pin};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> <span style=color:#75715e>$crate</span>::macros::support::Poll::{Ready, Pending};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Safety: nothing must be moved out of `futures`. This is to satisfy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// the requirement of `Pin::new_unchecked` called below.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> futures <span style=color:#f92672>=</span> ( <span style=color:#75715e>$(</span> maybe_done(<span style=color:#75715e>$e</span>), )<span style=color:#f92672>*</span> );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        poll_fn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>|</span>cx<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> is_pending <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>$(</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Extract the future for this branch from the tuple.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> ( <span style=color:#75715e>$($skip</span>,)<span style=color:#f92672>*</span> fut, <span style=color:#f92672>..</span> ) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> futures;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Safety: future is stored on the stack above
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// and never moved.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> fut <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { Pin::new_unchecked(fut) };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Try polling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> fut.poll(cx).is_pending() {
</span></span><span style=display:flex><span>                    is_pending <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            )<span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> is_pending {
</span></span><span style=display:flex><span>                Pending
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                Ready((<span style=color:#75715e>$(</span>{
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Extract the future for this branch from the tuple.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> ( <span style=color:#75715e>$($skip</span>,)<span style=color:#f92672>*</span> fut, <span style=color:#f92672>..</span> ) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> futures;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Safety: future is stored on the stack above
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// and never moved.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> fut <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { Pin::new_unchecked(fut) };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    fut.take_output().expect(<span style=color:#e6db74>&#34;expected completed future&#34;</span>)
</span></span><span style=display:flex><span>                },)<span style=color:#f92672>*</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }).<span style=color:#66d9ef>await</span>
</span></span><span style=display:flex><span>    }};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ===== Normalize =====
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    (<span style=color:#f92672>@</span> { ( <span style=color:#75715e>$($s</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> ) <span style=color:#75715e>$($t</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> } <span style=color:#75715e>$e</span>:<span style=color:#a6e22e>expr</span>, <span style=color:#75715e>$($r</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> ) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>$crate</span>::join<span style=color:#f92672>!</span>(<span style=color:#f92672>@</span>{ (<span style=color:#75715e>$($s</span>)<span style=color:#f92672>*</span> _) <span style=color:#75715e>$($t</span>)<span style=color:#f92672>*</span> (<span style=color:#75715e>$($s</span>)<span style=color:#f92672>*</span>) <span style=color:#75715e>$e</span>, } <span style=color:#75715e>$($r</span>)<span style=color:#f92672>*</span>)
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ===== Entry point =====
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    ( <span style=color:#75715e>$($e</span>:<span style=color:#a6e22e>expr</span>),<span style=color:#f92672>*</span> <span style=color:#75715e>$(,</span>)<span style=color:#f92672>?</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>$crate</span>::join<span style=color:#f92672>!</span>(<span style=color:#f92672>@</span>{ () } <span style=color:#75715e>$($e</span>,)<span style=color:#f92672>*</span>)
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So i went on and just gave each future its own budget before polling them.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>macro_rules! join {
</span></span><span style=display:flex><span>  <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>            <span style=color:#75715e>$(</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Extract the future for this branch from the tuple.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> ( <span style=color:#75715e>$($skip</span>,)<span style=color:#f92672>*</span> fut, <span style=color:#f92672>..</span> ) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> futures;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Safety: future is stored on the stack above
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// and never moved.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> fut <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { Pin::new_unchecked(fut) };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Try polling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>crate</span>::coop::budget(<span style=color:#f92672>||</span> fut.poll(cx)).is_pending() {
</span></span><span style=display:flex><span>                    is_pending <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            )<span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>Note that i added <code>crate::coop::budget</code></p></blockquote><p>Turns out this doesn&rsquo;t work. It is still pretty easy to create a future that never yields even though it consumes its whole budget:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span><span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>    tokio::join<span style=color:#f92672>!</span>(sem.acquire());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The future would spend its budget but not the budget of the surrounding task, causing it to never yield.</p><h2 id=second-try>Second try<a hidden class=anchor aria-hidden=true href=#second-try>#</a></h2><p>Each time the task created by <a href=https://docs.rs/tokio/latest/tokio/macro.join.html>join!</a> is polled, poll a different future first so as time goes by, every future gets a chance to make progress.</p><p>I took a look at <a href=https://docs.rs/tokio/latest/tokio/macro.select.html>select!</a> and it is able to do just that (up to 64 branches) so i took note and modified <a href=https://docs.rs/tokio/latest/tokio/macro.join.html>join!</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>macro_rules! join {
</span></span><span style=display:flex><span>  <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> start <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>  <span style=color:#75715e>// BRANCHES is the number of futures passed to join!.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>BRANCHES {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> branch;
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[allow(clippy::modulo_one)]</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      branch <span style=color:#f92672>=</span> (start <span style=color:#f92672>+</span> i) <span style=color:#f92672>%</span> BRANCHES;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>$(</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// $crate::count! will return the number of tokens passed to it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// up to 64 tokens.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>$crate</span>::count<span style=color:#f92672>!</span>( <span style=color:#75715e>$($skip</span>)<span style=color:#f92672>*</span> ) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Extract the future for this branch from the tuple.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> ( <span style=color:#75715e>$($skip</span>,)<span style=color:#f92672>*</span> fut, <span style=color:#f92672>..</span> ) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> futures;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Safety: future is stored on the stack above
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// and never moved.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> fut <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { Pin::new_unchecked(fut) };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Try polling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> fut.poll(cx).is_pending() {
</span></span><span style=display:flex><span>          is_pending <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    )<span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#[allow(clippy::modulo_one)]</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    start <span style=color:#f92672>=</span> (start <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> BRANCHES;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This actually works but <code>$crate::count!</code> can only count up to 64:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[macro_export]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[doc(hidden)]</span>
</span></span><span style=display:flex><span>macro_rules! count {
</span></span><span style=display:flex><span>    () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    (_) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    (_ _) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    (_ _ _) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    <span style=color:#75715e>// up to 64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>aaaand&mldr; <a href=https://docs.rs/tokio/latest/tokio/macro.join.html>join!</a> accepts up to 125 futures without changing the <a href=https://doc.rust-lang.org/reference/attributes/limits.html>recursion limit</a> so this solution wasn&rsquo;t accepted because it would be a breaking change.</p><h2 id=third-try>Third try<a hidden class=anchor aria-hidden=true href=#third-try>#</a></h2><p>Start the polling round in a different future each time still seems like a good idea. To bypass <code>$crate::count!</code>&rsquo;s limitation, i decided to use a <a href=https://doc.rust-lang.org/reference/procedural-macros.html>procedural macro</a>.</p><blockquote><p>Not actually showing code for this one because it is too long</p></blockquote><p>Turns out people don&rsquo;t like <a href=https://doc.rust-lang.org/reference/procedural-macros.html>procedural macro</a>s very much and it was not accepted.</p><h2 id=fourth-try>Fourth try<a hidden class=anchor aria-hidden=true href=#fourth-try>#</a></h2><p>Still the same solution but implemented in a different way. What if instead of using <code>$crate::count!</code> inside the macro to get the index of a future, we counted up front?</p><p><a href=https://docs.rs/tokio/latest/tokio/macro.join.html>join!</a> already does some normalization before actually processing the input, so i modified the normalization branches to pair the future index with the future itself.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>macro_rules! join {
</span></span><span style=display:flex><span>     (<span style=color:#f92672>@</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// One `_` for each branch in the `join!` macro. This is not used once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// normalization is complete.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ( <span style=color:#75715e>$($count</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The expression `0+1+1+ ... +1` equal to the number of branches.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ( <span style=color:#75715e>$($total</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Normalized join! branches
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>$(</span> ( <span style=color:#75715e>$($skip</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> ) ( <span style=color:#75715e>$($branch_index</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> ) <span style=color:#75715e>$e</span>:<span style=color:#a6e22e>expr</span>, )<span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }) <span style=color:#f92672>=&gt;</span> {{
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> start <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        <span style=color:#75715e>// BRANCHES is the number of futures passed to join!.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>BRANCHES {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> branch;
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[allow(clippy::modulo_one)]</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                branch <span style=color:#f92672>=</span> (start <span style=color:#f92672>+</span> i) <span style=color:#f92672>%</span> BRANCHES;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>$(</span>
</span></span><span style=display:flex><span>              {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>const</span> INDEX: <span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> <span style=color:#75715e>$($branch_index</span>)<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> branch <span style=color:#f92672>==</span> INDEX {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Extract the future for this branch from the tuple.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> ( <span style=color:#75715e>$($skip</span>,)<span style=color:#f92672>*</span> fut, <span style=color:#f92672>..</span> ) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> futures;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Safety: future is stored on the stack above
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// and never moved.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> fut <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { Pin::new_unchecked(fut) };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Try polling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> fut.poll(cx).is_pending() {
</span></span><span style=display:flex><span>                      is_pending <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>              }
</span></span><span style=display:flex><span>          )<span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#[allow(clippy::modulo_one)]</span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        start <span style=color:#f92672>=</span> (start <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> BRANCHES;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    }};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// ===== Normalize =====
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    (<span style=color:#f92672>@</span> { ( <span style=color:#75715e>$($s</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> ) ( <span style=color:#75715e>$($n</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> ) <span style=color:#75715e>$($t</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> } <span style=color:#75715e>$e</span>:<span style=color:#a6e22e>expr</span>, <span style=color:#75715e>$($r</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> ) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                                          <span style=color:#75715e>// i&#39;m new ▼
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>$crate</span>::join<span style=color:#f92672>!</span>(<span style=color:#f92672>@</span>{ (<span style=color:#75715e>$($s</span>)<span style=color:#f92672>*</span> _) (<span style=color:#75715e>$($n</span>)<span style=color:#f92672>*</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#75715e>$($t</span>)<span style=color:#f92672>*</span> (<span style=color:#75715e>$($s</span>)<span style=color:#f92672>*</span>) (<span style=color:#75715e>$($n</span>)<span style=color:#f92672>*</span>) <span style=color:#75715e>$e</span>, } <span style=color:#75715e>$($r</span>)<span style=color:#f92672>*</span>)
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ===== Entry point =====
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    ( <span style=color:#75715e>$($e</span>:<span style=color:#a6e22e>expr</span>),<span style=color:#f92672>*</span> <span style=color:#75715e>$(,</span>)<span style=color:#f92672>?</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                  <span style=color:#75715e>// i&#39;m new ▼
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>$crate</span>::join<span style=color:#f92672>!</span>(<span style=color:#f92672>@</span>{ () (<span style=color:#ae81ff>0</span>) } <span style=color:#75715e>$($e</span>,)<span style=color:#f92672>*</span>)
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It works but could be faster. Say we pass 5 futures to <code>join!</code>, how many times would the if statements that check if it is the future&rsquo;s turn to be polled conditions be checked?</p><h2 id=fifth-try-the-last-one>Fifth try (the last one)<a hidden class=anchor aria-hidden=true href=#fifth-try-the-last-one>#</a></h2><p><a href=https://github.com/tokio-rs/tokio/pull/4624>PR</a></p><p>The same idea still, poll a different future first every time, except we avoid checking if statement conditions without necessity.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>macro_rules! join {
</span></span><span style=display:flex><span>    (<span style=color:#f92672>@</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// One `_` for each branch in the `join!` macro. This is not used once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// normalization is complete.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ( <span style=color:#75715e>$($count</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The expression `0+1+1+ ... +1` equal to the number of branches.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ( <span style=color:#75715e>$($total</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Normalized join! branches
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>$(</span> ( <span style=color:#75715e>$($skip</span>:<span style=color:#a6e22e>tt</span>)<span style=color:#f92672>*</span> ) <span style=color:#75715e>$e</span>:<span style=color:#a6e22e>expr</span>, )<span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }) <span style=color:#f92672>=&gt;</span> {{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> <span style=color:#75715e>$crate</span>::macros::support::{maybe_done, poll_fn, Future, Pin};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> <span style=color:#75715e>$crate</span>::macros::support::Poll::{Ready, Pending};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Safety: nothing must be moved out of `futures`. This is to satisfy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// the requirement of `Pin::new_unchecked` called below.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> futures <span style=color:#f92672>=</span> ( <span style=color:#75715e>$(</span> maybe_done(<span style=color:#75715e>$e</span>), )<span style=color:#f92672>*</span> );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Each time the future created by poll_fn is polled, a different future will be polled first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// to ensure every future passed to join! gets a chance to make progress even if
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// one of the futures consumes the whole budget.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// This is number of futures that will be skipped in the first loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// iteration the next time.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> skip_next_time: <span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        poll_fn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>|</span>cx<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> COUNT: <span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> <span style=color:#75715e>$($total</span>)<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> is_pending <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> to_run <span style=color:#f92672>=</span> COUNT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// The number of futures that will be skipped in the first loop iteration.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> skip <span style=color:#f92672>=</span> skip_next_time;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            skip_next_time <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> skip <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> COUNT { <span style=color:#ae81ff>0</span> } <span style=color:#66d9ef>else</span> { skip <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// This loop runs twice and the first `skip` futures
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// are not polled in the first iteration.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>$(</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> skip <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> to_run <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// Every future has been polled
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    to_run <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Extract the future for this branch from the tuple.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> ( <span style=color:#75715e>$($skip</span>,)<span style=color:#f92672>*</span> fut, <span style=color:#f92672>..</span> ) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> futures;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Safety: future is stored on the stack above
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// and never moved.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> fut <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { Pin::new_unchecked(fut) };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Try polling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> fut.poll(cx).is_pending() {
</span></span><span style=display:flex><span>                        is_pending <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Future skipped, one less future to skip in the next iteration
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    skip <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            )<span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> is_pending {
</span></span><span style=display:flex><span>                Pending
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                Ready((<span style=color:#75715e>$(</span>{
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Extract the future for this branch from the tuple.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> ( <span style=color:#75715e>$($skip</span>,)<span style=color:#f92672>*</span> fut, <span style=color:#f92672>..</span> ) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> futures;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Safety: future is stored on the stack above
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// and never moved.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> fut <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { Pin::new_unchecked(fut) };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    fut.take_output().expect(<span style=color:#e6db74>&#34;expected completed future&#34;</span>)
</span></span><span style=display:flex><span>                },)<span style=color:#f92672>*</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }).<span style=color:#66d9ef>await</span>
</span></span><span style=display:flex><span>    }};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=thanks>Thanks<a hidden class=anchor aria-hidden=true href=#thanks>#</a></h1><p>Honestly, i had a lot of help from <a href=https://github.com/Darksonn>Darksonn</a>.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://poorlydefinedbehaviour.github.io/posts/logs/><span class=title>« Prev</span><br><span>Logs</span></a>
<a class=next href=https://poorlydefinedbehaviour.github.io/posts/why_rc_is_not_send/><span class=title>Next »</span><br><span>Why Rc&lt;T> is not Send</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Contributing to Rust and tokio on twitter" href="https://twitter.com/intent/tweet/?text=Contributing%20to%20Rust%20and%20tokio&url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fcontributing_to_tokio%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Contributing to Rust and tokio on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fcontributing_to_tokio%2f&title=Contributing%20to%20Rust%20and%20tokio&summary=Contributing%20to%20Rust%20and%20tokio&source=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fcontributing_to_tokio%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Contributing to Rust and tokio on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fcontributing_to_tokio%2f&title=Contributing%20to%20Rust%20and%20tokio"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Contributing to Rust and tokio on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fcontributing_to_tokio%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Contributing to Rust and tokio on whatsapp" href="https://api.whatsapp.com/send?text=Contributing%20to%20Rust%20and%20tokio%20-%20https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fcontributing_to_tokio%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Contributing to Rust and tokio on telegram" href="https://telegram.me/share/url?text=Contributing%20to%20Rust%20and%20tokio&url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fcontributing_to_tokio%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://poorlydefinedbehaviour.github.io></a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>