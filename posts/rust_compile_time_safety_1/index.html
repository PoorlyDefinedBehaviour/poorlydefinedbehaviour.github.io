<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Do Go programs with common data races compile in Rust? | </title><meta name=keywords content><meta name=description content="Uber has adopted Go as its primary programming language for developing microservices and has a post on its blog called Data Race Patterns in Go where they talk about data races found in their Go codebase.
I was reading it and thought to myself that many of the problems presented in the post would not even compile in Rust. Can Rust help us avoid writing code with common data races?"><meta name=author content="poorlydefinedbehaviour"><link rel=canonical href=https://poorlydefinedbehaviour.github.io/posts/rust_compile_time_safety_1/><link crossorigin=anonymous href=/assets/css/stylesheet.e087fd1dc76e73a35ae6d7028ddc1ba41e0131e7f9b3a6e2d019a208e6d6c4b5.css integrity="sha256-4If9Hcduc6Na5tcCjdwbpB4BMef5s6bi0BmiCObWxLU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://poorlydefinedbehaviour.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://poorlydefinedbehaviour.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://poorlydefinedbehaviour.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://poorlydefinedbehaviour.github.io/apple-touch-icon.png><link rel=mask-icon href=https://poorlydefinedbehaviour.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Do Go programs with common data races compile in Rust?"><meta property="og:description" content="Uber has adopted Go as its primary programming language for developing microservices and has a post on its blog called Data Race Patterns in Go where they talk about data races found in their Go codebase.
I was reading it and thought to myself that many of the problems presented in the post would not even compile in Rust. Can Rust help us avoid writing code with common data races?"><meta property="og:type" content="article"><meta property="og:url" content="https://poorlydefinedbehaviour.github.io/posts/rust_compile_time_safety_1/"><meta property="og:image" content="https://poorlydefinedbehaviour.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-23T20:39:07-03:00"><meta property="article:modified_time" content="2022-05-23T20:39:07-03:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://poorlydefinedbehaviour.github.io/papermod-cover.png"><meta name=twitter:title content="Do Go programs with common data races compile in Rust?"><meta name=twitter:description content="Uber has adopted Go as its primary programming language for developing microservices and has a post on its blog called Data Race Patterns in Go where they talk about data races found in their Go codebase.
I was reading it and thought to myself that many of the problems presented in the post would not even compile in Rust. Can Rust help us avoid writing code with common data races?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://poorlydefinedbehaviour.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Do Go programs with common data races compile in Rust?","item":"https://poorlydefinedbehaviour.github.io/posts/rust_compile_time_safety_1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Do Go programs with common data races compile in Rust?","name":"Do Go programs with common data races compile in Rust?","description":"Uber has adopted Go as its primary programming language for developing microservices and has a post on its blog called Data Race Patterns in Go where they talk about data races found in their Go codebase.\nI was reading it and thought to myself that many of the problems presented in the post would not even compile in Rust. Can Rust help us avoid writing code with common data races?","keywords":[],"articleBody":"Uber has adopted Go as its primary programming language for developing microservices and has a post on its blog called Data Race Patterns in Go where they talk about data races found in their Go codebase.\nI was reading it and thought to myself that many of the problems presented in the post would not even compile in Rust. Can Rust help us avoid writing code with common data races?\nExamples written in Rust are not meant do be idiomatic Rust and do not wait for outputs generated by tasks for simplicity because the examples written in Go do not wait as well.\nWhat is a data race A data race happens when a task tries to access memory while another task tries to write to it at the same time. The task that’s accessing memory may read a value that was just modified, is being modified or will be modified and end up processing an unexpected value.\nLoop index variable capture Go has the range loop to iterate over a collection.\nfor index, value := range list { ... } index is the index of the element in the list and value is the value at that index. The problem with it is that value is not a new variable at each iteration, it is just modified to have the value of the current iteration. This behaviour in combination with the fact that closures capture variables by reference instead of by copy can easily lead to concurrency bugs.\nWhile ProcessJob is running, the range loop will be updating the job variable which was captured by reference by ProcessJob, it is possible that by that ProcessJob gets to run, job will be a reference to the last job in jobs because the variable has been updated.\nfor _, job := range jobs { go func(){ ProcessJob(job) }() } There’s a proposal to change for range semantics in Go.\nRust provides concurrency through stackless coroutines, also known as async and await, the only thing we need to do is to choose a async runtime. I chose to use tokio which is the most popular runtime in the Rust ecosystem at the moment.\nWe can iterate through any collection that implements the Iterator trait by using the for in construct.\nfor job in jobs { tokio::spawn(process_job(job)); } for job in jobs is syntax sugar for for job in jobs.into_iter() – it also is syntax sugar for advancing an iterator, but we don’t care about that – which lets us iterate over the values in a collection by consuming the collection.\nWe could iterate over references to the values inside of the collection by using for job in jobs.iter() which creates an iterator that yields a reference to each value of the collection, if needed but the code would not compile in this case because a task(think goroutine) may run for longer than the amount of time the value being referenced by it lives for.\nerror[E0597]: `jobs` does not live long enough --\u003e src/for_range_and_closures.rs:6:16 | 6 | for job in jobs.iter() { | ^^^^^^^^^^^ borrowed value does not live long enough 7 | tokio::spawn(process_job(job)); | ---------------- argument requires that `jobs` is borrowed for `'static` 8 | } 9 | } | - `jobs` dropped here while still borrowed There’s no need to use a closure but for completeness sake here it is and it would not compile as well.\nerror[E0597]: `jobs` does not live long enough --\u003e src/for_range_and_closures.rs:14:16 | 14 | for job in jobs.iter() { | ^^^^^^^^^^^ borrowed value does not live long enough 15 | tokio::spawn((|| async { process_job(job) })()); | -------------------------- returning this value requires that `jobs` is borrowed for `'static` 16 | } 17 | } | - `jobs` dropped here while still borrowed Data race due to idiomatic err variable capture Errors are values in Go and failable functions usually return a tuple with two values, one value being the result if the function succeeded and the other being an error if the function failed.\nIn this example, processing is happening concurrently between the current function and a goroutine. We want to return an error if the goroutine or the current function fails, so they both try to assign to the err variable so the error can be returned to the caller of the current function.\nx, err := Foo() if err != nil { ... } go func() { var y int // Oops, err was captured by reference. y, err = Bar() if err != nil { ... } }() var z int // err is being written to by the goroutine as well. z, err = Baz() if err != nil { ... } This is an example of a data race because the err variable is being modified by the current function and by the goroutine without synchronization.\nAs expected, the same example does not compile in Rust for several reasons.\nerror[E0373]: async block may outlive the current function, but it borrows `result`, which is owned by the current function --\u003e src/goroutine_var_reference_data_race.rs:41:24 | 41 | tokio::spawn(async { | ________________________^ 42 | | // Trying to assign to the `result` captured . 43 | | result = bar(); | | ------ `result` is borrowed here 44 | | if result.is_err() { 45 | | // ... 46 | | } 47 | | }); | |_____^ may outlive borrowed value `result` | = note: async blocks are not executed immediately and must either take a reference or ownership of outside variables they use help: to force the async block to take ownership of `result` (and any other referenced variables), use the `move` keyword | 41 | tokio::spawn(async move { | ++++ error[E0506]: cannot assign to `result` because it is borrowed --\u003e src/goroutine_var_reference_data_race.rs:51:5 | 41 | tokio::spawn(async { | _____-__________________- | |_____| | || 42 | || // Trying to assign to the `result` captured . 43 | || result = bar(); | || ------ borrow occurs due to use in generator 44 | || if result.is_err() { 45 | || // ... 46 | || } 47 | || }); | ||_____-- argument requires that `result` is borrowed for `'static` | |_____| | borrow of `result` occurs here ... 51 | result = baz(); | ^^^^^^ assignment to borrowed `result` occurs here error[E0502]: cannot borrow `result` as immutable because it is also borrowed as mutable --\u003e src/goroutine_var_reference_data_race.rs:52:8 | 41 | tokio::spawn(async { | _____-__________________- | |_____| | || 42 | || // Trying to assign to the `result` captured . 43 | || result = bar(); | || ------ first borrow occurs due to use of `result` in generator 44 | || if result.is_err() { 45 | || // ... 46 | || } 47 | || }); | ||_____-- argument requires that `result` is borrowed for `'static` | |_____| | mutable borrow occurs here ... 52 | if result.is_err() { | ^^^^^^^^^^^^^^^ immutable borrow occurs here We could try to translate the Go version to Rust and make it work by using atomic reference counting with Arc and a Mutex.\nlet result = foo(); if result.is_err() { // ... } let result = Arc::new(Mutex::new(result)); let result_clone = Arc::clone(\u0026result); let task = tokio::spawn(async move { let mut result = result_clone.lock().await; *result = bar(); if result.is_err() { // ... } }); { let mut result = result.lock().await; *result = baz(); if result.is_err() { // ... } } task.await; Arc::try_unwrap(result).unwrap().into_inner() Bugs due to copies of a slice’s internal state Go slices are growable lists made of a pointer to a buffer, a capacity and a length. We can add elements to a slice by calling append, if the slice is full, it will grow to accommodate the new element.\nThe problem here is that by passing myResults as argument to the closure, we are copying the length, the capacity and the pointer to the buffer of the slice because function arguments are passed by copy in Go.\nWhen we try to append to myResults, the copy the goroutine holds may have the wrong length and capacity because myResults may have need to grow when another goroutine appended to it.\nfunc ProcessAll(uuids []string) { var myResults []string var mutex sync.Mutex safeAppend := func(res string) { mutex.Lock() myResults = append(myResults, res) mutex.Unlock() } for _, uuid := range uuids { go func(id string, results []string) { res := Foo(id) safeAppend(res) }(uuid, myResults) } } Like Go, Rust function arguments are passed by copy as well but unlike Go, Rust’s Vec, the growable array, is not passed by reference by default.\nIf we try to translate the Go code to Rust, it does not even compile. We create a closure safe_append to ensure the mutex is always locked before modyfing the list of results, it does not compile because we try to use the closure inside several tasks but the closure gets moved after the first loop iteration.\nfn process_all(uuids: Vec\u003cString\u003e) { let mut my_results = Vec::new(); let mutex = Mutex::new(()); let mut safe_append = |res: String| async move { mutex.lock().await; my_results.push(res); }; for uuid in uuids { tokio::spawn(async { let res = foo(uuid); safe_append(res); }); } } error[E0382]: use of moved value: `safe_append` --\u003e src/mutex_slice_append.rs:34:28 | 34 | tokio::spawn(async { | ____________________________^ 35 | | let res = foo(uuid); 36 | | safe_append(res); | | ----------- use occurs due to use in generator 37 | | }); | |_________^ value moved here, in previous iteration of loop The solution is simple as well. Rust’s Mutex is meant to hold the data being protected instead of just acting like a type of flag. Use reference counting so each task can access the same mutex and modify the data held by it.\nfn process_all_2(uuids: Vec\u003cString\u003e) { let my_results = Arc::new(Mutex::new(Vec::new())); for uuid in uuids { let my_results_clone = Arc::clone(\u0026my_results); tokio::spawn(async move { let res = foo(uuid); let mut my_results = my_results_clone.lock().await; my_results.push(res); }); } } The mutex is unlocked automatically on Drop thanks to RAII.\nData races because maps are not thread-safe In this example, orders are being processed concurrently and eventual errors are added to a map where the key is the order id and the error is the value so we can know which orders were not processed.\nThe problem is that the map is not thread-safe which means that since there are several goroutines modifying the map without synchronization it may end up in an unexpected state.\nfunc processOrders(uuids []string) error { var errMap = make(map[string]error) for _, uuid := range uuids { go func(uuid string) { orderHandle, err := GetOrder(uuid) if err != nil { // Data race errMap[uuid] = err return } ... }(uuid) } return combineErrors(errMap) } As expected, the same code does not compile in Rust because multiple tasks(think goroutine) may not have mutable access to a value at the same time without synchronization.\nfn process_orders(uuids: Vec\u003cString\u003e) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let mut err_map = HashMap::new(); for uuid in uuids { tokio::spawn(async { match get_order(\u0026uuid).await { Err(err) =\u003e { err_map.insert(uuid, err); } Ok(value) =\u003e { // ... } } }); } combine_errors(err_map) } error[E0499]: cannot borrow `err_map` as mutable more than once at a time --\u003e src/thread_unsafe_hashmap.rs:23:28 | 23 | tokio::spawn(async { | _________-__________________^ | |_________| | || 24 | || match get_order(\u0026uuid).await { 25 | || Err(err) =\u003e { 26 | || err_map.insert(uuid, err); | || ------- borrows occur due to use of `err_map` in generator ... || 31 | || } 32 | || }); | ||_________^- argument requires that `err_map` is borrowed for `'static` | |_________| | `err_map` was mutably borrowed here in the previous iteration of the loop The correct version is also pretty simple in this case. Use a mutex to protect the data so it can be mutate by several tasks concurrently and reference counting to ensure the every task operates on the data guarded by the same mutex.\nfn process_orders_2(uuids: Vec\u003cString\u003e) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let mut err_map = Arc::new(Mutex::new(HashMap::new())); for uuid in uuids { let err_map_clone = Arc::clone(\u0026err_map); tokio::spawn(async move { match get_order(\u0026uuid).await { Err(err) =\u003e { let mut err_map = err_map_clone.lock().await; err_map.insert(uuid, err); } Ok(value) =\u003e { // ... } } }); } combine_errors(\u0026err_map) } Breaking a mutex by copying it around Function arguments are copied in Go. Its not uncommon to commit the mistake of passing a mutex by copy to multiple goroutines in order to synchronize access to a piece of data, the problem is that a mutex will be copied – including its internal state – when passed to a goroutine, which means each goroutine will have each its own mutex and all of them will be able to acquire it at the same time.\nvar a int func CriticalSection(m synx.Mutex) { m.Lock() a += 1 m.Unlock() } func main() { mutex := sync.Mutex{} go CriticalSection(mutex) // mutex is copied go CriticalSection(mutex) // mutex is copied } Rust mutexes are supposed to hold the data they protect instead of acting as a flag and when a variable is passed as argument to a function, we say that the value has been moved and it cannot be accessed using the old variable anymore, for this reason, the code does not compile.\nuse tokio::sync::Mutex; fn main() { let mutex = Mutex::new(0); tokio::spawn(critical_section(mutex)); tokio::spawn(critical_section(mutex)); } async fn critical_section(mutex: Mutex\u003ci32\u003e) { let mut value = mutex.lock().await; *value += 1; } --\u003e src/mutex.rs:21:35 | 19 | let mutex = Mutex::new(0); | ----- move occurs because `mutex` has type `tokio::sync::Mutex\u003ci32\u003e`, which does not implement the `Copy` trait 20 | tokio::spawn(critical_section(mutex)); | ----- value moved here 21 | tokio::spawn(critical_section(mutex)); | ^^^^^ value used here after move The incorrect version does not compile and the correct version is pretty easy to write using reference couting to ensure every task uses the same mutex.\nfn main() { let mutex = Arc::new(Mutex::new(0)); tokio::spawn(critical_section(Arc::clone(\u0026mutex))); tokio::spawn(critical_section(Arc::clone(\u0026mutex))); } async fn critical_section(mutex: Arc\u003cMutex\u003ci32\u003e\u003e) { let mut value = mutex.lock().await; *value += 1; } Conclusion Rust can not stop us from making every kind of mistake but it does seem like it can help us avoid at least some concurrency bugs.\n","wordCount":"2336","inLanguage":"en","datePublished":"2022-05-23T20:39:07-03:00","dateModified":"2022-05-23T20:39:07-03:00","author":{"@type":"Person","name":"poorlydefinedbehaviour"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://poorlydefinedbehaviour.github.io/posts/rust_compile_time_safety_1/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"https://poorlydefinedbehaviour.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://poorlydefinedbehaviour.github.io/ title=Home><span>Home</span></a></li><li><a href=https://poorlydefinedbehaviour.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://poorlydefinedbehaviour.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://poorlydefinedbehaviour.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://poorlydefinedbehaviour.github.io>Home</a>&nbsp;»&nbsp;<a href=https://poorlydefinedbehaviour.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Do Go programs with common data races compile in Rust?</h1><div class=post-meta><span title='2022-05-23 20:39:07 -0300 -0300'>May 23, 2022</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;poorlydefinedbehaviour&nbsp;|&nbsp;<a href=https://github.com/PoorlyDefinedBehaviour/poorlydefinedbehaviour.github.io/tree/main/content/posts/rust_compile_time_safety_1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-is-a-data-race aria-label="What is a data race">What is a data race</a></li><li><a href=#loop-index-variable-capture aria-label="Loop index variable capture">Loop index variable capture</a></li><li><a href=#data-race-due-to-idiomatic-err-variable-capture aria-label="Data race due to idiomatic err variable capture">Data race due to idiomatic err variable capture</a></li><li><a href=#bugs-due-to-copies-of-a-slices-internal-state aria-label="Bugs due to copies of a slice&rsquo;s internal state">Bugs due to copies of a slice&rsquo;s internal state</a></li><li><a href=#data-races-because-maps-are-not-thread-safe aria-label="Data races because maps are not thread-safe">Data races because maps are not thread-safe</a></li><li><a href=#breaking-a-mutex-by-copying-it-around aria-label="Breaking a mutex by copying it around">Breaking a mutex by copying it around</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>Uber has adopted <a href=https://github.com/golang/go>Go</a> as its primary programming language for developing microservices and has a post on its blog called <a href=https://www.uber.com/en-BR/blog/data-race-patterns-in-go/>Data Race Patterns in Go</a> where they talk about data races found in their Go codebase.</p><p>I was reading it and thought to myself that many of the problems presented in the post would not even compile in Rust. Can Rust help us avoid writing code with common data races?</p><p>Examples written in Rust are not meant do be idiomatic Rust and do not wait for outputs generated by tasks for simplicity because the examples written in Go do not wait as well.</p><h2 id=what-is-a-data-race>What is a data race<a hidden class=anchor aria-hidden=true href=#what-is-a-data-race>#</a></h2><p>A <a href=https://en.wikipedia.org/wiki/Race_condition#Data_race>data race</a> happens when a task tries to access memory while another task tries to write to it at the same time. The task that&rsquo;s accessing memory may read a value that was just modified, is being modified or will be modified and end up processing an unexpected value.</p><h2 id=loop-index-variable-capture>Loop index variable capture<a hidden class=anchor aria-hidden=true href=#loop-index-variable-capture>#</a></h2><p>Go has the <a href=https://go.dev/tour/moretypes/16>range</a> loop to iterate over a collection.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>index</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>list</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>index</code> is the index of the element in the list and <code>value</code> is the value at that index. The problem with it is that <code>value</code> is not a new variable at each iteration, it is just modified to have the value of the current iteration. This behaviour in combination with the fact that <a href=https://go.dev/tour/moretypes/25>closures</a> capture variables by reference instead of by copy can easily lead to concurrency bugs.</p><p>While <code>ProcessJob</code> is running, the <code>range</code> loop will be updating the <code>job</code> variable which was captured by reference by <code>ProcessJob</code>, it is possible that by that <code>ProcessJob</code> gets to run, <code>job</code> will be a reference to the last <code>job</code> in <code>jobs</code> because the variable has been updated.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>job</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>jobs</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ProcessJob</span>(<span style=color:#a6e22e>job</span>)
</span></span><span style=display:flex><span>  }()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There&rsquo;s a <a href=https://github.com/golang/go/discussions/56010>proposal</a> to change <code>for range</code> semantics in Go.</p><p>Rust provides concurrency through stackless <a href=https://en.wikipedia.org/wiki/Coroutine>coroutines</a>, also known as <code>async</code> and <code>await</code>, the only thing we need to do is to choose a async runtime. I chose to use <a href=https://github.com/tokio-rs/tokio>tokio</a> which is the most popular runtime in the Rust ecosystem at the moment.</p><p>We can iterate through any collection that implements the <a href=https://doc.rust-lang.org/std/iter/trait.Iterator.html>Iterator</a> trait by using the <code>for in</code> construct.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>for</span> job <span style=color:#66d9ef>in</span> jobs {
</span></span><span style=display:flex><span>  tokio::spawn(process_job(job));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>for job in jobs</code> is syntax sugar for <code>for job in jobs.into_iter()</code> &ndash; it also is syntax sugar for advancing an iterator, but we don&rsquo;t care about that &ndash; which lets us iterate over the values in a collection by consuming the collection.</p><p>We could iterate over references to the values inside of the collection by using <code>for job in jobs.iter()</code> which creates an iterator that yields a reference to each value of the collection, if needed but the code would not compile in this case because a task(think goroutine) may run for longer than the amount of time the value being referenced by it lives for.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>error[E0597]: <span style=color:#960050;background-color:#1e0010>`</span>jobs<span style=color:#960050;background-color:#1e0010>`</span> does not live long enough
</span></span><span style=display:flex><span> <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>src</span><span style=color:#f92672>/</span>for_range_and_closures.rs:<span style=color:#ae81ff>6</span>:<span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span> <span style=color:#f92672>|</span>     <span style=color:#66d9ef>for</span> job <span style=color:#66d9ef>in</span> jobs.iter() {
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span>                <span style=color:#f92672>^^^^^^^^^^^</span> borrowed value does not live long enough
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> <span style=color:#f92672>|</span>         tokio::spawn(process_job(job));
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span>                      <span style=color:#f92672>----------------</span> argument requires that <span style=color:#960050;background-color:#1e0010>`</span>jobs<span style=color:#960050;background-color:#1e0010>`</span> is borrowed <span style=color:#66d9ef>for</span> <span style=color:#960050;background-color:#1e0010>`</span>&#39;static<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>8</span> <span style=color:#f92672>|</span>     }
</span></span><span style=display:flex><span><span style=color:#ae81ff>9</span> <span style=color:#f92672>|</span> }
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#f92672>-</span> <span style=color:#960050;background-color:#1e0010>`</span>jobs<span style=color:#960050;background-color:#1e0010>`</span> dropped here <span style=color:#66d9ef>while</span> still borrowed
</span></span></code></pre></div><p>There&rsquo;s no need to use a closure but for completeness sake here it is and it would not compile as well.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>error[E0597]: <span style=color:#960050;background-color:#1e0010>`</span>jobs<span style=color:#960050;background-color:#1e0010>`</span> does not live long enough
</span></span><span style=display:flex><span>  <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>src</span><span style=color:#f92672>/</span>for_range_and_closures.rs:<span style=color:#ae81ff>14</span>:<span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>14</span> <span style=color:#f92672>|</span>     <span style=color:#66d9ef>for</span> job <span style=color:#66d9ef>in</span> jobs.iter() {
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>                <span style=color:#f92672>^^^^^^^^^^^</span> borrowed value does not live long enough
</span></span><span style=display:flex><span><span style=color:#ae81ff>15</span> <span style=color:#f92672>|</span>         tokio::spawn((<span style=color:#f92672>||</span> <span style=color:#66d9ef>async</span> { process_job(job) })());
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>                          <span style=color:#f92672>--------------------------</span> returning this value requires that <span style=color:#960050;background-color:#1e0010>`</span>jobs<span style=color:#960050;background-color:#1e0010>`</span> is borrowed <span style=color:#66d9ef>for</span> <span style=color:#960050;background-color:#1e0010>`</span>&#39;static<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>16</span> <span style=color:#f92672>|</span>     }
</span></span><span style=display:flex><span><span style=color:#ae81ff>17</span> <span style=color:#f92672>|</span> }
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#f92672>-</span> <span style=color:#960050;background-color:#1e0010>`</span>jobs<span style=color:#960050;background-color:#1e0010>`</span> dropped here <span style=color:#66d9ef>while</span> still borrowed
</span></span></code></pre></div><h2 id=data-race-due-to-idiomatic-err-variable-capture>Data race due to idiomatic err variable capture<a hidden class=anchor aria-hidden=true href=#data-race-due-to-idiomatic-err-variable-capture>#</a></h2><p>Errors are values in Go and failable functions usually return a tuple with two values, one value being the result if the function succeeded and the other being an error if the function failed.</p><p>In this example, processing is happening concurrently between the current function and a goroutine. We want to return an error if the goroutine or the current function fails, so they both try to assign to the <code>err</code> variable so the error can be returned to the caller of the current function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Foo</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Oops, err was captured by reference.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>Bar</span>()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>z</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// err is being written to by the goroutine as well.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>z</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>Baz</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is an example of a data race because the <code>err</code> variable is being modified by the current function and by the goroutine without synchronization.</p><p>As expected, the same example does not compile in Rust for several reasons.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>error[E0373]: <span style=color:#a6e22e>async</span> block may outlive the current function, but it borrows <span style=color:#960050;background-color:#1e0010>`</span>result<span style=color:#960050;background-color:#1e0010>`</span>, which is owned by the current function
</span></span><span style=display:flex><span>  <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>src</span><span style=color:#f92672>/</span>goroutine_var_reference_data_race.rs:<span style=color:#ae81ff>41</span>:<span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>41</span> <span style=color:#f92672>|</span>       tokio::spawn(<span style=color:#66d9ef>async</span> {
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>  ________________________<span style=color:#f92672>^</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>42</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>         <span style=color:#75715e>// Trying to assign to the `result` captured .
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>43</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>         result <span style=color:#f92672>=</span> bar();
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>         <span style=color:#f92672>------</span> <span style=color:#960050;background-color:#1e0010>`</span>result<span style=color:#960050;background-color:#1e0010>`</span> is borrowed here
</span></span><span style=display:flex><span><span style=color:#ae81ff>44</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>         <span style=color:#66d9ef>if</span> result.is_err() {
</span></span><span style=display:flex><span><span style=color:#ae81ff>45</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>             <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>46</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>         }
</span></span><span style=display:flex><span><span style=color:#ae81ff>47</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>     });
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>_____<span style=color:#f92672>^</span> may outlive borrowed value <span style=color:#960050;background-color:#1e0010>`</span>result<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>=</span> note: <span style=color:#a6e22e>async</span> blocks are not executed immediately and must either take a reference or ownership of outside variables they <span style=color:#66d9ef>use</span>
</span></span><span style=display:flex><span>help: <span style=color:#a6e22e>to</span> force the <span style=color:#66d9ef>async</span> block to take ownership of <span style=color:#960050;background-color:#1e0010>`</span>result<span style=color:#960050;background-color:#1e0010>`</span> (and any other referenced variables), <span style=color:#66d9ef>use</span> the <span style=color:#960050;background-color:#1e0010>`</span><span style=color:#66d9ef>move</span><span style=color:#960050;background-color:#1e0010>`</span> keyword
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>41</span> <span style=color:#f92672>|</span>     tokio::spawn(<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>move</span> {
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>                        <span style=color:#f92672>++++</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error[E0506]: <span style=color:#a6e22e>cannot</span> assign to <span style=color:#960050;background-color:#1e0010>`</span>result<span style=color:#960050;background-color:#1e0010>`</span> because it is borrowed
</span></span><span style=display:flex><span>  <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>src</span><span style=color:#f92672>/</span>goroutine_var_reference_data_race.rs:<span style=color:#ae81ff>51</span>:<span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>41</span> <span style=color:#f92672>|</span>        tokio::spawn(<span style=color:#66d9ef>async</span> {
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>   _____<span style=color:#f92672>-</span>__________________<span style=color:#f92672>-</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>  <span style=color:#f92672>|</span>_____<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>42</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>         <span style=color:#75715e>// Trying to assign to the `result` captured .
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>43</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>         result <span style=color:#f92672>=</span> bar();
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>         <span style=color:#f92672>------</span> borrow occurs due to <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>in</span> generator
</span></span><span style=display:flex><span><span style=color:#ae81ff>44</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>         <span style=color:#66d9ef>if</span> result.is_err() {
</span></span><span style=display:flex><span><span style=color:#ae81ff>45</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>             <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>46</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>         }
</span></span><span style=display:flex><span><span style=color:#ae81ff>47</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>     });
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>_____<span style=color:#f92672>--</span> argument requires that <span style=color:#960050;background-color:#1e0010>`</span>result<span style=color:#960050;background-color:#1e0010>`</span> is borrowed <span style=color:#66d9ef>for</span> <span style=color:#960050;background-color:#1e0010>`</span>&#39;static<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>  <span style=color:#f92672>|</span>_____<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>        borrow of <span style=color:#960050;background-color:#1e0010>`</span>result<span style=color:#960050;background-color:#1e0010>`</span> occurs here
</span></span><span style=display:flex><span><span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span><span style=color:#ae81ff>51</span> <span style=color:#f92672>|</span>        result <span style=color:#f92672>=</span> baz();
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>        <span style=color:#f92672>^^^^^^</span> assignment to borrowed <span style=color:#960050;background-color:#1e0010>`</span>result<span style=color:#960050;background-color:#1e0010>`</span> occurs here
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error[E0502]: <span style=color:#a6e22e>cannot</span> borrow <span style=color:#960050;background-color:#1e0010>`</span>result<span style=color:#960050;background-color:#1e0010>`</span> <span style=color:#66d9ef>as</span> immutable because it is also borrowed <span style=color:#66d9ef>as</span> mutable
</span></span><span style=display:flex><span>  <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>src</span><span style=color:#f92672>/</span>goroutine_var_reference_data_race.rs:<span style=color:#ae81ff>52</span>:<span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>41</span> <span style=color:#f92672>|</span>        tokio::spawn(<span style=color:#66d9ef>async</span> {
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>   _____<span style=color:#f92672>-</span>__________________<span style=color:#f92672>-</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>  <span style=color:#f92672>|</span>_____<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>42</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>         <span style=color:#75715e>// Trying to assign to the `result` captured .
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>43</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>         result <span style=color:#f92672>=</span> bar();
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>         <span style=color:#f92672>------</span> first borrow occurs due to <span style=color:#66d9ef>use</span> of <span style=color:#960050;background-color:#1e0010>`</span>result<span style=color:#960050;background-color:#1e0010>`</span> <span style=color:#66d9ef>in</span> generator
</span></span><span style=display:flex><span><span style=color:#ae81ff>44</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>         <span style=color:#66d9ef>if</span> result.is_err() {
</span></span><span style=display:flex><span><span style=color:#ae81ff>45</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>             <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>46</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>         }
</span></span><span style=display:flex><span><span style=color:#ae81ff>47</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>     });
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>_____<span style=color:#f92672>--</span> argument requires that <span style=color:#960050;background-color:#1e0010>`</span>result<span style=color:#960050;background-color:#1e0010>`</span> is borrowed <span style=color:#66d9ef>for</span> <span style=color:#960050;background-color:#1e0010>`</span>&#39;static<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>  <span style=color:#f92672>|</span>_____<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>        mutable borrow occurs here
</span></span><span style=display:flex><span><span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span><span style=color:#ae81ff>52</span> <span style=color:#f92672>|</span>        <span style=color:#66d9ef>if</span> result.is_err() {
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>           <span style=color:#f92672>^^^^^^^^^^^^^^^</span> immutable borrow occurs here
</span></span></code></pre></div><p>We could try to translate the Go version to Rust and make it work by using atomic reference counting with <a href=https://doc.rust-lang.org/std/sync/struct.Arc.html>Arc</a> and a <a href=https://doc.rust-lang.org/std/sync/struct.Mutex.html>Mutex</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> foo();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> result.is_err() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> Arc::new(Mutex::new(result));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result_clone <span style=color:#f92672>=</span> Arc::clone(<span style=color:#f92672>&amp;</span>result);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> task <span style=color:#f92672>=</span> tokio::spawn(<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>move</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> result <span style=color:#f92672>=</span> result_clone.lock().<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>result <span style=color:#f92672>=</span> bar();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> result.is_err() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> result <span style=color:#f92672>=</span> result.lock().<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>result <span style=color:#f92672>=</span> baz();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> result.is_err() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    task.<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Arc::try_unwrap(result).unwrap().into_inner()
</span></span></code></pre></div><h2 id=bugs-due-to-copies-of-a-slices-internal-state>Bugs due to copies of a slice&rsquo;s internal state<a hidden class=anchor aria-hidden=true href=#bugs-due-to-copies-of-a-slices-internal-state>#</a></h2><p>Go slices are growable lists made of a pointer to a buffer, a capacity and a length. We can add elements to a slice by calling <a href=https://pkg.go.dev/builtin#append>append</a>, if the slice is full, it will grow to accommodate the new element.</p><p>The problem here is that by passing <code>myResults</code> as argument to the closure, we are copying the length, the capacity and the pointer to the buffer of the slice because function arguments are passed by copy in Go.</p><p>When we try to append to <code>myResults</code>, the copy the goroutine holds may have the wrong length and capacity because <code>myResults</code> may have need to grow when another goroutine appended to it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ProcessAll</span>(<span style=color:#a6e22e>uuids</span> []<span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>myResults</span> []<span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>mutex</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>safeAppend</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>res</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>myResults</span> = append(<span style=color:#a6e22e>myResults</span>, <span style=color:#a6e22e>res</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>uuid</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>uuids</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>results</span> []<span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Foo</span>(<span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>safeAppend</span>(<span style=color:#a6e22e>res</span>)
</span></span><span style=display:flex><span>    }(<span style=color:#a6e22e>uuid</span>, <span style=color:#a6e22e>myResults</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Like Go, Rust function arguments are passed by copy as well but unlike Go, Rust&rsquo;s <a href=https://doc.rust-lang.org/std/vec/struct.Vec.html>Vec</a>, the growable array, is not passed by reference by default.</p><p>If we try to translate the Go code to Rust, it does not even compile. We create a closure <code>safe_append</code> to ensure the mutex is always locked before modyfing the list of results, it does not compile because we try to use the closure inside several tasks but the closure gets moved after the first loop iteration.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>process_all</span>(uuids: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> my_results <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mutex <span style=color:#f92672>=</span> Mutex::new(());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> safe_append <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>res: String<span style=color:#f92672>|</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>move</span> {
</span></span><span style=display:flex><span>        mutex.lock().<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>        my_results.push(res);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> uuid <span style=color:#66d9ef>in</span> uuids {
</span></span><span style=display:flex><span>        tokio::spawn(<span style=color:#66d9ef>async</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> res <span style=color:#f92672>=</span> foo(uuid);
</span></span><span style=display:flex><span>            safe_append(res);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error[E0382]: <span style=color:#a6e22e>use</span> of moved value: <span style=color:#960050;background-color:#1e0010>`</span>safe_append<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>src</span><span style=color:#f92672>/</span>mutex_slice_append.rs:<span style=color:#ae81ff>34</span>:<span style=color:#ae81ff>28</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>34</span> <span style=color:#f92672>|</span>           tokio::spawn(<span style=color:#66d9ef>async</span> {
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>  ____________________________<span style=color:#f92672>^</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>35</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>             <span style=color:#66d9ef>let</span> res <span style=color:#f92672>=</span> foo(uuid);
</span></span><span style=display:flex><span><span style=color:#ae81ff>36</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>             safe_append(res);
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>             <span style=color:#f92672>-----------</span> <span style=color:#66d9ef>use</span> occurs due to <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>in</span> generator
</span></span><span style=display:flex><span><span style=color:#ae81ff>37</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>         });
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>_________<span style=color:#f92672>^</span> value moved here, <span style=color:#66d9ef>in</span> previous iteration of <span style=color:#66d9ef>loop</span>
</span></span></code></pre></div><p>The solution is simple as well. Rust&rsquo;s <a href=https://doc.rust-lang.org/std/sync/struct.Mutex.html>Mutex</a> is meant to hold the data being protected instead of just acting like a type of flag. Use reference counting so each task can access the same mutex and modify the data held by it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>process_all_2</span>(uuids: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> my_results <span style=color:#f92672>=</span> Arc::new(Mutex::new(Vec::new()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> uuid <span style=color:#66d9ef>in</span> uuids {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> my_results_clone <span style=color:#f92672>=</span> Arc::clone(<span style=color:#f92672>&amp;</span>my_results);
</span></span><span style=display:flex><span>        tokio::spawn(<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>move</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> res <span style=color:#f92672>=</span> foo(uuid);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> my_results <span style=color:#f92672>=</span> my_results_clone.lock().<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>            my_results.push(res);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The mutex is unlocked automatically on <a href=https://doc.rust-lang.org/std/ops/trait.Drop.html>Drop</a> thanks to <a href=https://www.thecodedmessage.com/posts/raii/>RAII</a>.</p><h2 id=data-races-because-maps-are-not-thread-safe>Data races because maps are not thread-safe<a hidden class=anchor aria-hidden=true href=#data-races-because-maps-are-not-thread-safe>#</a></h2><p>In this example, orders are being processed concurrently and eventual errors are added to a map where the key is the order id and the error is the value so we can know which orders were not processed.</p><p>The problem is that the map is not thread-safe which means that since there are several goroutines modifying the map without synchronization it may end up in an unexpected state.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>processOrders</span>(<span style=color:#a6e22e>uuids</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>errMap</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>uuid</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>uuids</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>uuid</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>orderHandle</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>GetOrder</span>(<span style=color:#a6e22e>uuid</span>)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Data race
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>errMap</span>[<span style=color:#a6e22e>uuid</span>] = <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    }(<span style=color:#a6e22e>uuid</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>combineErrors</span>(<span style=color:#a6e22e>errMap</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As expected, the same code does not compile in Rust because multiple tasks(think goroutine) may not have mutable access to a value at the same time without synchronization.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>process_orders</span>(uuids: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>(), Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> std::error::Error<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> err_map <span style=color:#f92672>=</span> HashMap::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> uuid <span style=color:#66d9ef>in</span> uuids {
</span></span><span style=display:flex><span>        tokio::spawn(<span style=color:#66d9ef>async</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> get_order(<span style=color:#f92672>&amp;</span>uuid).<span style=color:#66d9ef>await</span> {
</span></span><span style=display:flex><span>                Err(err) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    err_map.insert(uuid, err);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Ok(value) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    combine_errors(err_map)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error[E0499]: <span style=color:#a6e22e>cannot</span> borrow <span style=color:#960050;background-color:#1e0010>`</span>err_map<span style=color:#960050;background-color:#1e0010>`</span> <span style=color:#66d9ef>as</span> mutable more than once at a time
</span></span><span style=display:flex><span>  <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>src</span><span style=color:#f92672>/</span>thread_unsafe_hashmap.rs:<span style=color:#ae81ff>23</span>:<span style=color:#ae81ff>28</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>23</span> <span style=color:#f92672>|</span>            tokio::spawn(<span style=color:#66d9ef>async</span> {
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>   _________<span style=color:#f92672>-</span>__________________<span style=color:#f92672>^</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>  <span style=color:#f92672>|</span>_________<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>24</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>             <span style=color:#66d9ef>match</span> get_order(<span style=color:#f92672>&amp;</span>uuid).<span style=color:#66d9ef>await</span> {
</span></span><span style=display:flex><span><span style=color:#ae81ff>25</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>                 Err(err) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span><span style=color:#ae81ff>26</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>                     err_map.insert(uuid, err);
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>                     <span style=color:#f92672>-------</span> borrows occur due to <span style=color:#66d9ef>use</span> of <span style=color:#960050;background-color:#1e0010>`</span>err_map<span style=color:#960050;background-color:#1e0010>`</span> <span style=color:#66d9ef>in</span> generator
</span></span><span style=display:flex><span><span style=color:#f92672>..</span>.  <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>31</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>             }
</span></span><span style=display:flex><span><span style=color:#ae81ff>32</span> <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>         });
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span> <span style=color:#f92672>||</span>_________<span style=color:#f92672>^-</span> argument requires that <span style=color:#960050;background-color:#1e0010>`</span>err_map<span style=color:#960050;background-color:#1e0010>`</span> is borrowed <span style=color:#66d9ef>for</span> <span style=color:#960050;background-color:#1e0010>`</span>&#39;static<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>  <span style=color:#f92672>|</span>_________<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>            <span style=color:#960050;background-color:#1e0010>`</span>err_map<span style=color:#960050;background-color:#1e0010>`</span> was mutably borrowed here <span style=color:#66d9ef>in</span> the previous iteration of the <span style=color:#66d9ef>loop</span>
</span></span></code></pre></div><p>The correct version is also pretty simple in this case. Use a mutex to protect the data so it can be mutate by several tasks concurrently and reference counting to ensure the every task operates on the data guarded by the same mutex.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>process_orders_2</span>(uuids: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>(), Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> std::error::Error<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> err_map <span style=color:#f92672>=</span> Arc::new(Mutex::new(HashMap::new()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> uuid <span style=color:#66d9ef>in</span> uuids {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> err_map_clone <span style=color:#f92672>=</span> Arc::clone(<span style=color:#f92672>&amp;</span>err_map);
</span></span><span style=display:flex><span>        tokio::spawn(<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>move</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> get_order(<span style=color:#f92672>&amp;</span>uuid).<span style=color:#66d9ef>await</span> {
</span></span><span style=display:flex><span>                Err(err) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> err_map <span style=color:#f92672>=</span> err_map_clone.lock().<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>                    err_map.insert(uuid, err);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Ok(value) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    combine_errors(<span style=color:#f92672>&amp;</span>err_map)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=breaking-a-mutex-by-copying-it-around>Breaking a mutex by copying it around<a hidden class=anchor aria-hidden=true href=#breaking-a-mutex-by-copying-it-around>#</a></h2><p>Function arguments are copied in Go. Its not uncommon to commit the mistake of passing a mutex by copy to multiple goroutines in order to synchronize access to a piece of data, the problem is that a mutex will be copied &ndash; including its internal state &ndash; when passed to a goroutine, which means each goroutine will have each its own mutex and all of them will be able to acquire it at the same time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CriticalSection</span>(<span style=color:#a6e22e>m</span> <span style=color:#a6e22e>synx</span>.<span style=color:#a6e22e>Mutex</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>a</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mutex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>{}
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>CriticalSection</span>(<span style=color:#a6e22e>mutex</span>) <span style=color:#75715e>// mutex is copied
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>CriticalSection</span>(<span style=color:#a6e22e>mutex</span>) <span style=color:#75715e>// mutex is copied
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Rust mutexes are supposed to hold the data they protect instead of acting as a flag and when a variable is passed as argument to a function, we say that the value has been moved and it cannot be accessed using the old variable anymore, for this reason, the code does not compile.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> tokio::sync::Mutex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mutex <span style=color:#f92672>=</span> Mutex::new(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    tokio::spawn(critical_section(mutex));
</span></span><span style=display:flex><span>    tokio::spawn(critical_section(mutex));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>critical_section</span>(mutex: <span style=color:#a6e22e>Mutex</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> value <span style=color:#f92672>=</span> mutex.lock().<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>value <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>src</span><span style=color:#f92672>/</span>mutex.rs:<span style=color:#ae81ff>21</span>:<span style=color:#ae81ff>35</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>19</span> <span style=color:#f92672>|</span>     <span style=color:#66d9ef>let</span> mutex <span style=color:#f92672>=</span> Mutex::new(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>         <span style=color:#f92672>-----</span> <span style=color:#66d9ef>move</span> occurs because <span style=color:#960050;background-color:#1e0010>`</span>mutex<span style=color:#960050;background-color:#1e0010>`</span> has <span style=color:#66d9ef>type</span> <span style=color:#960050;background-color:#1e0010>`</span>tokio::sync::Mutex<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span><span style=color:#960050;background-color:#1e0010>`</span>, which does not implement the <span style=color:#960050;background-color:#1e0010>`</span>Copy<span style=color:#960050;background-color:#1e0010>`</span> <span style=color:#66d9ef>trait</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>20</span> <span style=color:#f92672>|</span>     tokio::spawn(critical_section(mutex));
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>                                   <span style=color:#f92672>-----</span> value moved here
</span></span><span style=display:flex><span><span style=color:#ae81ff>21</span> <span style=color:#f92672>|</span>     tokio::spawn(critical_section(mutex));
</span></span><span style=display:flex><span>   <span style=color:#f92672>|</span>                                   <span style=color:#f92672>^^^^^</span> value used here after <span style=color:#66d9ef>move</span>
</span></span></code></pre></div><p>The incorrect version does not compile and the correct version is pretty easy to write using reference couting to ensure every task uses the same mutex.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mutex <span style=color:#f92672>=</span> Arc::new(Mutex::new(<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    tokio::spawn(critical_section(Arc::clone(<span style=color:#f92672>&amp;</span>mutex)));
</span></span><span style=display:flex><span>    tokio::spawn(critical_section(Arc::clone(<span style=color:#f92672>&amp;</span>mutex)));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>critical_section</span>(mutex: <span style=color:#a6e22e>Arc</span><span style=color:#f92672>&lt;</span>Mutex<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;&gt;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> value <span style=color:#f92672>=</span> mutex.lock().<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>value <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Rust can not stop us from making every kind of mistake but it does seem like it can help us avoid at least some concurrency bugs.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://poorlydefinedbehaviour.github.io/posts/request_coalescing/><span class=title>« Prev</span><br><span>Avoid overloading your systems: Request coalescing</span>
</a><a class=next href=https://poorlydefinedbehaviour.github.io/posts/logs/><span class=title>Next »</span><br><span>Logs</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Do Go programs with common data races compile in Rust? on x" href="https://x.com/intent/tweet/?text=Do%20Go%20programs%20with%20common%20data%20races%20compile%20in%20Rust%3f&amp;url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2frust_compile_time_safety_1%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Do Go programs with common data races compile in Rust? on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2frust_compile_time_safety_1%2f&amp;title=Do%20Go%20programs%20with%20common%20data%20races%20compile%20in%20Rust%3f&amp;summary=Do%20Go%20programs%20with%20common%20data%20races%20compile%20in%20Rust%3f&amp;source=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2frust_compile_time_safety_1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Do Go programs with common data races compile in Rust? on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2frust_compile_time_safety_1%2f&title=Do%20Go%20programs%20with%20common%20data%20races%20compile%20in%20Rust%3f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Do Go programs with common data races compile in Rust? on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2frust_compile_time_safety_1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Do Go programs with common data races compile in Rust? on whatsapp" href="https://api.whatsapp.com/send?text=Do%20Go%20programs%20with%20common%20data%20races%20compile%20in%20Rust%3f%20-%20https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2frust_compile_time_safety_1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Do Go programs with common data races compile in Rust? on telegram" href="https://telegram.me/share/url?text=Do%20Go%20programs%20with%20common%20data%20races%20compile%20in%20Rust%3f&amp;url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2frust_compile_time_safety_1%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Do Go programs with common data races compile in Rust? on ycombinator" href="https://news.ycombinator.com/submitlink?t=Do%20Go%20programs%20with%20common%20data%20races%20compile%20in%20Rust%3f&u=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2frust_compile_time_safety_1%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://poorlydefinedbehaviour.github.io></a></span><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>