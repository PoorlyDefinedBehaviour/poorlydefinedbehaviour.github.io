<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤 | </title><meta name=keywords content><meta name=description content='𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤
deterministic:  of or relating to a process or model in which the output is determined solely by the input and initial conditions, thereby always returning the same results ( stochastic ):
The algorithms are simple and deterministic, so the results are predictable and reproducible.
Example based testing
Example based testing works fine for simple cases where there&rsquo;s only a small number of actions that matter.
let%test_unit "append entries: truncates the log on entry conflict" =
  let storage = make { dir = Test_util.temp_dir () } in

  (* Leader adds some entries to the replica&#39;s log. *)
  append_entries storage (last_log_index storage)
    [
      { term = 1L; data = "1" };
      { term = 2L; data = "2" };
      { term = 3L; data = "3" };
    ];

  (* Another leader overrides the replica&#39;s log. *)
  append_entries storage 2L
    [ { term = 4L; data = "3" }; { term = 4L; data = "4" } ];

  assert (entry_at_index storage 1L = Some { term = 1L; data = "1" });
  assert (entry_at_index storage 2L = Some { term = 2L; data = "2" });
  (* Entry at index 3 has been overwritten. *)
  assert (entry_at_index storage 3L = Some { term = 4L; data = "3" });
  (* Entry at index 4 is new. *)
  assert (entry_at_index storage 4L = Some { term = 4L; data = "4" })
It becomes way harder to think of and write the examples when the bugs you&rsquo;re looking for only happen after several events that need to happen in a specific order.'><meta name=author content="poorlydefinedbehaviour"><link rel=canonical href=https://poorlydefinedbehaviour.github.io/posts/deterministic_simulation_testing/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://poorlydefinedbehaviour.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://poorlydefinedbehaviour.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://poorlydefinedbehaviour.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://poorlydefinedbehaviour.github.io/apple-touch-icon.png><link rel=mask-icon href=https://poorlydefinedbehaviour.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://poorlydefinedbehaviour.github.io/posts/deterministic_simulation_testing/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://poorlydefinedbehaviour.github.io/posts/deterministic_simulation_testing/"><meta property="og:title" content="𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤"><meta property="og:description" content='𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤 deterministic: of or relating to a process or model in which the output is determined solely by the input and initial conditions, thereby always returning the same results ( stochastic ): The algorithms are simple and deterministic, so the results are predictable and reproducible.
Example based testing Example based testing works fine for simple cases where there’s only a small number of actions that matter.
let%test_unit "append entries: truncates the log on entry conflict" = let storage = make { dir = Test_util.temp_dir () } in (* Leader adds some entries to the replica&#39;s log. *) append_entries storage (last_log_index storage) [ { term = 1L; data = "1" }; { term = 2L; data = "2" }; { term = 3L; data = "3" }; ]; (* Another leader overrides the replica&#39;s log. *) append_entries storage 2L [ { term = 4L; data = "3" }; { term = 4L; data = "4" } ]; assert (entry_at_index storage 1L = Some { term = 1L; data = "1" }); assert (entry_at_index storage 2L = Some { term = 2L; data = "2" }); (* Entry at index 3 has been overwritten. *) assert (entry_at_index storage 3L = Some { term = 4L; data = "3" }); (* Entry at index 4 is new. *) assert (entry_at_index storage 4L = Some { term = 4L; data = "4" }) It becomes way harder to think of and write the examples when the bugs you’re looking for only happen after several events that need to happen in a specific order.'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-06T22:00:00-03:00"><meta property="article:modified_time" content="2024-11-06T22:00:00-03:00"><meta property="og:image" content="https://poorlydefinedbehaviour.github.io/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://poorlydefinedbehaviour.github.io/papermod-cover.png"><meta name=twitter:title content="𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤"><meta name=twitter:description content='𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤
deterministic:  of or relating to a process or model in which the output is determined solely by the input and initial conditions, thereby always returning the same results ( stochastic ):
The algorithms are simple and deterministic, so the results are predictable and reproducible.
Example based testing
Example based testing works fine for simple cases where there&rsquo;s only a small number of actions that matter.
let%test_unit "append entries: truncates the log on entry conflict" =
  let storage = make { dir = Test_util.temp_dir () } in

  (* Leader adds some entries to the replica&#39;s log. *)
  append_entries storage (last_log_index storage)
    [
      { term = 1L; data = "1" };
      { term = 2L; data = "2" };
      { term = 3L; data = "3" };
    ];

  (* Another leader overrides the replica&#39;s log. *)
  append_entries storage 2L
    [ { term = 4L; data = "3" }; { term = 4L; data = "4" } ];

  assert (entry_at_index storage 1L = Some { term = 1L; data = "1" });
  assert (entry_at_index storage 2L = Some { term = 2L; data = "2" });
  (* Entry at index 3 has been overwritten. *)
  assert (entry_at_index storage 3L = Some { term = 4L; data = "3" });
  (* Entry at index 4 is new. *)
  assert (entry_at_index storage 4L = Some { term = 4L; data = "4" })
It becomes way harder to think of and write the examples when the bugs you&rsquo;re looking for only happen after several events that need to happen in a specific order.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://poorlydefinedbehaviour.github.io/posts/"},{"@type":"ListItem","position":2,"name":"𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤","item":"https://poorlydefinedbehaviour.github.io/posts/deterministic_simulation_testing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤","name":"𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤","description":"𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤 deterministic: of or relating to a process or model in which the output is determined solely by the input and initial conditions, thereby always returning the same results ( stochastic ): The algorithms are simple and deterministic, so the results are predictable and reproducible.\nExample based testing Example based testing works fine for simple cases where there\u0026rsquo;s only a small number of actions that matter.\nlet%test_unit \u0026#34;append entries: truncates the log on entry conflict\u0026#34; = let storage = make { dir = Test_util.temp_dir () } in (* Leader adds some entries to the replica\u0026#39;s log. *) append_entries storage (last_log_index storage) [ { term = 1L; data = \u0026#34;1\u0026#34; }; { term = 2L; data = \u0026#34;2\u0026#34; }; { term = 3L; data = \u0026#34;3\u0026#34; }; ]; (* Another leader overrides the replica\u0026#39;s log. *) append_entries storage 2L [ { term = 4L; data = \u0026#34;3\u0026#34; }; { term = 4L; data = \u0026#34;4\u0026#34; } ]; assert (entry_at_index storage 1L = Some { term = 1L; data = \u0026#34;1\u0026#34; }); assert (entry_at_index storage 2L = Some { term = 2L; data = \u0026#34;2\u0026#34; }); (* Entry at index 3 has been overwritten. *) assert (entry_at_index storage 3L = Some { term = 4L; data = \u0026#34;3\u0026#34; }); (* Entry at index 4 is new. *) assert (entry_at_index storage 4L = Some { term = 4L; data = \u0026#34;4\u0026#34; }) It becomes way harder to think of and write the examples when the bugs you\u0026rsquo;re looking for only happen after several events that need to happen in a specific order.\n","keywords":[],"articleBody":"𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤 deterministic: of or relating to a process or model in which the output is determined solely by the input and initial conditions, thereby always returning the same results ( stochastic ): The algorithms are simple and deterministic, so the results are predictable and reproducible.\nExample based testing Example based testing works fine for simple cases where there’s only a small number of actions that matter.\nlet%test_unit \"append entries: truncates the log on entry conflict\" = let storage = make { dir = Test_util.temp_dir () } in (* Leader adds some entries to the replica's log. *) append_entries storage (last_log_index storage) [ { term = 1L; data = \"1\" }; { term = 2L; data = \"2\" }; { term = 3L; data = \"3\" }; ]; (* Another leader overrides the replica's log. *) append_entries storage 2L [ { term = 4L; data = \"3\" }; { term = 4L; data = \"4\" } ]; assert (entry_at_index storage 1L = Some { term = 1L; data = \"1\" }); assert (entry_at_index storage 2L = Some { term = 2L; data = \"2\" }); (* Entry at index 3 has been overwritten. *) assert (entry_at_index storage 3L = Some { term = 4L; data = \"3\" }); (* Entry at index 4 is new. *) assert (entry_at_index storage 4L = Some { term = 4L; data = \"4\" }) It becomes way harder to think of and write the examples when the bugs you’re looking for only happen after several events that need to happen in a specific order.\nA bug found deep in the input tree. Property based testing Property based testing is a testing technique where a wide range of inputs are generated automatically unlike traditional example based testing where the inputs have to be manually thought of and written. The idea is that by auto generating inputs, the system will end up being tested with inputs that the programmer wouldn’t think of otherwise.\nBasic input\nProblem: Create a function that given a vec of integers nums and an integer k, returns the kth largest element in the vec.\nIn this case, the implementation uses a max heap to find the kth largest element in the vec in O(k log n).\nfn find_kth_largest(nums: Vec\u003ci32\u003e, k: i32) -\u003e i32 { let mut heap: BinaryHeap\u003c_\u003e = nums.into_iter().collect(); for _ in 0..k as usize - 1 { let _ = heap.pop(); } heap.pop().unwrap() } The test generates a random Vec, finds the kth largest element by sorting the vec – using a different and probably easier to understand implementation than the function being tested – and asserts that the function returns the same value.\n#[cfg(test)] mod tests { use super::*; use quickcheck::quickcheck; fn check(nums: Vec\u003ci32\u003e, k: usize, f: fn(Vec\u003ci32\u003e, i32) -\u003e i32) -\u003e bool { if nums.is_empty() { return true; } let k = 1 + k % nums.len(); let result = f(nums.clone(), k as i32); let mut nums = nums; nums.sort_unstable(); nums.reverse(); let expected = nums[k - 1]; expected == result } quickcheck! { #[test] fn test_find_kth_largest(nums: Vec\u003ci32\u003e, k: usize) -\u003e bool { check(nums, k, find_kth_largest) } } } Ideally, one or more properties would be defined and checked against the output but starting simple by just checking that the output makes sense works well in a lot of cases.\nfn sort(nums: \u0026mut Vec\u003ci32\u003e) { ... } #[cfg(test)] mod tests { use quickcheck::quickcheck; use super::*; quickcheck! { #[test] fn test_sort(nums: Vec\u003ci32\u003e) -\u003e bool { let mut nums = nums; sort(\u0026mut nums); if !nums.is_empty() { for i in 0..nums.len()-1 { assert!(nums[i] \u003c= nums[i+1]); } } true } } } Property: After sorting, every nums[i] is less than or equal to nums[i + 1].\nGenerate a large number of inputs randomly instead of writing just a few of them manually. More sophisticated inputs\nIt may be possible to interact with the system under test in several ways. Imagine that a max heap with a different implementation from the std library was being written. Sometimes a bug will be found only when a specific set of events happen in a specific order, popping from an empty heap, pushing two elements and popping 3 times, for example.\nInstead of thinking of all possible operation interleavings, generate a list of operations at random and apply them to the heap. The std heap could be used as a model – by having the same operations applied to it – to check that our heap behaves correctly from the user’s point of view. Run the test several times to increase the chance of a finding a bug.\n#[cfg(test)] mod tests { ... quickcheck! { #[test] fn test_heap(actions: Vec\u003cAction\u003e) -\u003e bool { let mut heap = Heap::new(); let mut model = BinaryHeap::new(); for action in actions { match action { Action::Push(v) =\u003e { model.push(v); heap.push(v); }, Action::Pop =\u003e { assert_eq!(model.pop(), heap.pop()); } } } true } } } The same idea could be used to test other systems, the difference is that instead of using the std heap, a simplified model of the real thing – that hopefully behaves correctly – would be used, for example, an in memory map that models a disk-based key-value store. Here’s an example of a append-only log in Go that uses an in-memory slice as the model.\nfunc TestFileStorage(t *testing.T) { t.Parallel() const ( OpAppendEntries = \"AppendEntries\" OpTruncateLogStartingFrom = \"TruncateLogStartingFrom\" OpGetEntryAtIndex = \"GetEntryAtIndex\" OpGetBatch = \"GetBatch\" OpLastLogIndex = \"LastLogIndex\" ) rapid.Check(t, func(t *rapid.T) { storage, err := NewFileStorage(fmt.Sprintf(\"%s/raft-go/%s\", os.TempDir(), uuid.New().String())) assert.NoError(t, err) model := newModel() ops := rapid.SliceOf(rapid.SampledFrom([]string{ OpAppendEntries, OpTruncateLogStartingFrom, OpGetEntryAtIndex, OpGetBatch, OpLastLogIndex, })). Draw(t, \"ops\") for _, op := range ops { switch op { case OpAppendEntries: entries := rapid.SliceOf(entryGenerator()).Draw(t, \"append: entries\") assert.NoError(t, storage.AppendEntries(entries)) assert.NoError(t, model.AppendEntries(entries)) t.Logf(\"appended %d entries\\n\", len(entries)) case OpTruncateLogStartingFrom: maybeExistingIndex := rapid.Uint64Range(1, uint64(len(model.entries)*2)+1).Draw(t, \"truncate: maybeExistingIndex\") storageErr := storage.TruncateLogStartingFrom(maybeExistingIndex) modelErr := model.TruncateLogStartingFrom(maybeExistingIndex) t.Logf(\"truncated from index %d len(model.entries)=%+v storageErr=%+v modelErr=%+v\\n\", maybeExistingIndex, len(model.entries), storageErr, modelErr) assert.ErrorIs(t, storageErr, modelErr) case OpGetEntryAtIndex: maybeExistingIndex := rapid.Uint64Range(1, uint64(len(model.entries)*2)+1).Draw(t, \"get entry: maybeExistingIndex\") storageEntry, storageErr := storage.GetEntryAtIndex(maybeExistingIndex) modelEntry, modelErr := model.GetEntryAtIndex(maybeExistingIndex) t.Logf(\"getting entry at index %d storageErr=%+v modelErr=%+v\\n\", maybeExistingIndex, storageErr, modelErr) assert.Equal(t, modelEntry, storageEntry) assert.ErrorIs(t, storageErr, modelErr) case OpGetBatch: maybeExistingIndex := rapid.Uint64Range(1, uint64(len(model.entries)*2)+1).Draw(t, \"get batch: maybe existing index\") batchSize := rapid.Uint64Range(1, uint64(len(model.entries)*2)+1).Draw(t, \"get batch: batch size\") storageBatch, storageErr := storage.GetBatch(maybeExistingIndex, batchSize) modelBatch, modelErr := model.GetBatch(maybeExistingIndex, batchSize) t.Logf(\"get batch index=%d batchSize=%d len(storageBatch)=%+v storageErr=%+v len(modelBatch)=%+v modelErr=%+v\\n\", maybeExistingIndex, batchSize, len(storageBatch), storageErr, len(modelBatch), modelErr, ) assert.ErrorIs(t, storageErr, modelErr) assert.Equal(t, modelBatch, storageBatch) case OpLastLogIndex: storageLastLogIndex := storage.LastLogIndex() modelLastLogIndex := model.LastLogIndex() assert.Equal(t, modelLastLogIndex, storageLastLogIndex) default: panic(fmt.Sprintf(\"unexpected op: %s\", op)) } } }) } Deterministic simulation testing For more complicated systems with several components, it may be complicated to write useful tests. What if the input space could be explored automatically by generating inputs in the same way inputs are generated for property based testing and the events that led to the bug replayed without effort? After defining a model of how the system should work – which actions and events the system should be able to handle – component failures can be injected according to the failure model – the failures the system should be able to handle –.\nStart by removing non-determinism introduced by things such as threads or iterating over a data structure that yields a different order in each iteration. This means moving IO to the edges of the system and replacing the real implementation – where it is not deterministic or fast enough – with a fake version that behaves like the real thing.\nNext, generate actions such as simulating an user request using a seeded prng. When a bug is found, the simulation can be re-run with the same seed to hit the same bug over and over again.\nBugs are reproducible by running the simulation with the seed that was used when the bug was found. Example: Applying deterministic simulation testing to single-decree Paxos Given a set of computers that can propose values, how to get the computers to decide on a value?\nThe chosen value must be proposed by one of the computers Only a single value can be chosen Paxos is one of the algorithms that can be used to solve the consensus problem.\nThe model Computers run at different speeds Computers may stop and restart at any time Messages sent from one computer to another can be lost, delayed or duplicated Single-decree Paxos The algorithm can be explained in two phases:\nPhase 1\nA computer that proposes values is called a proposer. A value is proposed by broadcasting a Prepare(n) message to the computers in the cluster where n is a unique monotonically increasing number. When a computer receives a Prepare(n) message, it responds with Ok(accepted_proposal_number, accepted_value) if n is the greatest proposal number it has seen so far where accepted_proposal_number and accepted_value are from latest proposal the computer has accepted, if any. impl Replica { fn next_proposal_number(\u0026mut self) -\u003e Result\u003cu64\u003e { let state = contracts::DurableState { min_proposal_number: self.state.min_proposal_number + 1, ..self.state.clone() }; self.storage.store(\u0026state)?; self.state = state; Ok(self.state.min_proposal_number) } // Phase 1. fn on_start_proposal(\u0026mut self, value: String) { let proposal_number = self.next_proposal_number().unwrap(); self.broadcast_prepare(proposal_number, value); } // Phase 1. fn on_prepare(\u0026mut self, input: PrepareInput) { if input.proposal_number \u003e self.state.min_proposal_number { let mut state = self.state.clone(); state.min_proposal_number = input.proposal_number; self.storage.store(\u0026state).unwrap(); self.state = state; self.bus.send_prepare_response( input.from_replica_id, PrepareOutput { from_replica_id: self.config.id, request_id: input.request_id, accepted_proposal_number: self.state.accepted_proposal_number, accepted_value: self.state.accepted_value.clone(), }, ); } } ... Phase 2\nAfter broadcasting Prepare(n), the proposer waits for responses from a majority of computers in the cluster After receiving responses from the majority, the proposer broadcasts a Accept(n, v) message to the computers in the cluster where n is the same proposal number sent in Prepare(n) message and v is the accepted_value from the message with the highest accepted_proposal_number received in response to the Prepare(n) messages or the value the proposer would like the computers to decide on if no proposals have been accepted yet. When a computer receives a Accept(n, v) message, it responds with Ok() if n is greater than or equal to the greatest proposal number it has seen in Phase 1. The last used proposal number, the highest proposal number seen by a computer, the accepted proposal number and the accepted value are stored in durable storage. ... // Phase 2. fn on_prepare_response(\u0026mut self, input: PrepareOutput) { let majority = self.majority(); let request_id = input.request_id; if let Some(req) = self.inflight_requests.get_mut(\u0026request_id) { req.responses.insert(input); if req.responses.len() \u003c majority { return; } let value = req .responses .iter() .filter(|response| response.accepted_proposal_number.is_some()) .max_by_key(|response| response.accepted_proposal_number) .map(|response| response.accepted_value.clone().unwrap()) .unwrap_or_else(|| req.proposed_value.clone().unwrap()); let proposal_number = req.proposal_number; self.broadcast_accept(proposal_number, value); self.inflight_requests.remove(\u0026request_id); } } // Phase 2. fn on_accept(\u0026mut self, input: AcceptInput) { if input.proposal_number \u003e= self.state.min_proposal_number { let mut state = self.state.clone(); state.accepted_proposal_number = Some(input.proposal_number); state.accepted_value = Some(input.value); self.storage.store(\u0026state).unwrap(); self.state = state; self.bus.send_accept_response( input.from_replica_id, AcceptOutput { from_replica_id: self.config.id, request_id: input.request_id, min_proposal_number: self.state.min_proposal_number, }, ); } } } An example of a Paxos round. The simulation\nThe network calls were replaced by a fake implementation to make it easier to drop, duplicate and delay messages. Insteading of sending messages using TCP or UDP, messages are held in an in-memory queue and are delivered by calling a method since every replica is running in memory.\nstruct SimMessageBus { queue: RefCell\u003cMessageQueue\u003e, } Generate a seed for the prng. The prng will be used to generate actions during the simulation. The seed can be passed as input the program to generate the same sequence of inputs after a test failure.\n#[cfg(test)] mod tests { ... #[test] fn action_simulation() -\u003e Result\u003c()\u003e { let seed: u64 = std::env::var(\"SEED\") .map(|v| v.parse::\u003cu64\u003e().unwrap()) .unwrap_or_else(|_| rand::thread_rng().gen()); eprintln!(\"SEED={seed}\"); let rng = Rc::new(RefCell::new(rand::rngs::StdRng::seed_from_u64(seed))); ... } } The simulator uses the seeded prng to generate actions, which include actions such as delivering a message, crashing a replica, generating a user request and more. The simulator generates max_actions actions where each action is generated based on the current state of the system, this is done to improve the number of interesting input sequences.\nIt is not that useful to crash a replica that’s already in the crashed state or to crash more than F replicas if we are interested in testing that a cluster with 2F + 1 replicas can make progress as long as the majority of replicas are up. In general, actions that trigger failures should be generated according to the failure model.\nstruct ActionSimulator { config: ActionSimulatorConfig, rng: Rc\u003cRefCell\u003cStdRng\u003e\u003e, bus: Rc\u003cSimMessageBus\u003e, replicas: Vec\u003cReplica\u003e, } enum Action { SendUserRequest, CrashReplica, RestartReplica, DeliverMessage, DropMessage, DuplicateMessage, } impl ActionSimulator { fn next_action(\u0026mut self) -\u003e Action { // Use the prng + knowledge about the current system state to generate the next action. // It's not that useful to crash a replica that's already in the crashed state. } fn run(\u0026mut self) { for i in 0..self.config.max_actions { let action = self.next_action(); match action { Action::SendUserRequest =\u003e { // Trigger a proposal from a replica. } Action::CrashReplica =\u003e { // Crash a random replica. } Action::RestartReplica =\u003e { // Restart a random replica. } Action::Delivermessage =\u003e { // Deliver a random message from the messages in flight. } Action::DropMessage =\u003e { // Drop a random message from the messages in flight. } Action::DuplicateMessage =\u003e { // Duplicate a random message from the messages in flight. } } ... } } } When a Action::DeliverMessage is generated, a random message is removed from the queue and delivered to the target replica:\nfn pop(\u0026mut self) -\u003e Option\u003cPendingMessage\u003e { if self.items.is_empty() { return None; } let i = self .rng .as_ref() .borrow_mut() .gen_range(0..self.items.len()); let item = self.items.swap_remove(i); Some(item) } Replicas get instantiated and passed to the simulator along with the configuration. The simulation will run 10000 times where each run will generate 1000 actions (e.g. CrashReplica, DeliverMessage). This simulator is actually running several threads with one simulation each to find bugs faster. The simulation in each thread is deterministic and isolated.\n#[cfg(test)] mod tests { ... #[test] fn action_simulation() -\u003e Result\u003c()\u003e { let count = if std::env::var(\"SEED\").is_ok() { 1 } else { std::env::var(\"MAX_THREADS\") .map(|v| v.parse::\u003cusize\u003e().unwrap()) .unwrap_or_else(|_| std::thread::available_parallelism().unwrap().get()) }; let max_iters = std::env::var(\"MAX_ITERS\") .map(|v| v.parse::\u003cu64\u003e().unwrap()) .unwrap_or_else(|_| 10_000); let max_actions = std::env::var(\"MAX_ACTIONS\") .map(|v| v.parse::\u003cu32\u003e().unwrap()) .unwrap_or_else(|_| 100); eprintln!(\"Spawning {count} threads\"); let handles = (0..count) .map(|thread_id| { std::thread::Builder::new() .name(format!(\"Thread({thread_id})\")) .spawn(move || { let seed: u64 = std::env::var(\"SEED\") .map(|v| v.parse::\u003cu64\u003e().unwrap()) .unwrap_or_else(|_| rand::thread_rng().gen()); eprintln!(\"SEED={seed}\"); let rng = Rc::new(RefCell::new(rand::rngs::StdRng::seed_from_u64(seed))); for i in 0..max_iters { if i % 1_000 == 0 { eprintln!(\"Thread({thread_id}) Running simulation {i}\"); } let simulator_config = { let mut rng = rng.borrow_mut(); ActionSimulatorConfig { max_actions, max_user_requests: rng.gen::\u003cu32\u003e() % 100 + 1, } }; let activity_log = Rc::new(RefCell::new(ActivityLog::new())); let servers = vec![1, 2, 3]; let majority = servers.len() / 2 + 1; let bus: Rc\u003cSimMessageBus\u003e = Rc::new(SimMessageBus::new( Rc::clone(\u0026rng), Oracle::new(majority, Rc::clone(\u0026activity_log)), Rc::clone(\u0026activity_log), )); let nodes: Vec\u003c_\u003e = servers .iter() .map(|id| { let fs = Rc::new(SimFileSystem::new()); Node { replica: Replica::new( Config { id: *id, replicas: servers.clone(), }, Rc::clone(\u0026bus) as Rc\u003cdyn contracts::MessageBus\u003e, Rc::new( FileStorage::new( Rc::clone(\u0026fs) as Rc\u003cdyn contracts::FileSystem\u003e, PathBuf::from(\"dir\"), ) .unwrap(), ), ), fs, } }) .collect(); let mut sim = ActionSimulator::new( simulator_config, Rc::clone(\u0026rng), nodes, Rc::clone(\u0026bus), Rc::clone(\u0026activity_log), ); let result = std::panic::catch_unwind(move || { sim.run(); assert!(sim.bus.is_empty()); }); if result.is_err() { activity_log.borrow_mut().print_events(); eprintln!(\"SEED={seed}\"); std::process::exit(1); } } }) }) .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?; for handle in handles { handle.join().unwrap(); } Ok(()) } } In a sense, the number of times the simulation runs can be understood as the max number of paths we would like to visit from an input tree and max_actions can be thought of as the depth of every path in the tree. The simulation may end up visiting the same path multiple times, solving that is an optimization for the future.\nAn example of a path in the input tree where a message is delivered and then the replica crashes. Verifying the system state is valid\nAt the moment, the simulation doesn’t do anything because there are no assertions. Let’s add an oracle – something that has a bird’s eye view of the system – that will receive a copy of the messages sent from replicas.\nimpl Oracle { pub fn on_accept_sent(\u0026mut self, _to_replica_id: ReplicaId, input: \u0026AcceptInput) { ... } pub fn on_proposal_accepted(\u0026mut self, _to_replica_id: ReplicaId, output: \u0026AcceptOutput) { ... } } The basic oracle keeps track of accepted proposals, after a proposal has been accepted by a majority of replicas, it asserts that no other value is even chosen.\nIn this case, the system state is seen from the perspective of an outside observer that only has access to the messages sent from the replicas but there’s nothing stopping assertions from being added to the internal modules or having the oracle inspect the internal state of the system under test.\nEven basic simulations can catch bugs. Let’s ignore the requirement the proposal numbers must be unique by accepting proposal numbers that are the highest the replica has seen.\nimpl Replica { fn on_prepare(\u0026mut self, input: PrepareInput) { --\u003e Change from `\u003e` to `\u003e=` // if input.proposal_number \u003e self.state.min_proposal_number { if input.proposal_number \u003e= self.state.min_proposal_number { ... } } ... } Run the simulation:\ncargo t action_simulation -- --nocapture ... thread 'Thread(3)' panicked at src/simulation/oracle.rs:75:17: assertion failed: `(left == right)` left: `Some(\"V(1, 44)\")`, right: `Some(\"V(2, 93)\")`: majority of replicas decided on a different value after a value was accepted note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace SEED=6948436056757512111 Replay the bug by running the simulation with the seed to get the same sequence of inputs:\nSEED=6948436056757512111 cargo t action_simulation -- --nocapture ... [BUS] Replica(1) -\u003e Replica(3) RECEIVED Prepare(RID(R1, P9)) [BUS] Replica(3) -\u003e Replica(1) RECEIVED AcceptResponse(RID(R1, P12), 12) [BUS] Replica(1) -\u003e Replica(1) RECEIVED PrepareResponse(RID(R1, P12), None, None) [ORACLE] value accepted by majority of replicas: majority=2 RID(R1, P12) value=V(1, 44) replicas=[2, 3] [BUS] Replica(2) -\u003e Replica(1) RECEIVED AcceptResponse(RID(R1, P12), 12) [BUS] Replica(2) -\u003e Replica(1) RECEIVED Accept(RID(R2, P12), 12, V(2, 93)) [BUS] Replica(1) -\u003e Replica(2) QUEUED AcceptResponse(RID(R2, P12), 12) [BUS] Replica(2) -\u003e Replica(2) RECEIVED AcceptResponse(RID(R2, P12), 12) [ORACLE] value accepted by majority of replicas: majority=2 RID(R2, P12) value=V(2, 93) replicas=[3, 2] SEED=6948436056757512111 The simulator will generate 1000 actions by default but it only needs to generate 2 actions to find this bug. The advantage of generating less actions is that the error trace will contain less events:\nMAX_ACTIONS=2 cargo t action_simulation -- --nocapture ... [BUS] Replica(2) -\u003e Replica(2) QUEUED AcceptResponse(RID(R2, P1), 1) [BUS] Replica(1) -\u003e Replica(2) RECEIVED AcceptResponse(RID(R2, P1), 1) [ORACLE] value accepted by majority of replicas: majority=2 RID(R2, P1) value=V(2, 0) replicas=[2, 1] [BUS] Replica(2) -\u003e Replica(2) RECEIVED AcceptResponse(RID(R2, P1), 1) [BUS] Replica(1) -\u003e Replica(1) RECEIVED Accept(RID(R1, P1), 1, V(1, 1)) [BUS] Replica(1) -\u003e Replica(1) QUEUED AcceptResponse(RID(R1, P1), 1) [BUS] Replica(2) -\u003e Replica(2) RECEIVED PrepareResponse(RID(R2, P1), None, None) [BUS] Replica(2) -\u003e Replica(3) RECEIVED Accept(RID(R2, P1), 1, V(2, 0)) [BUS] Replica(3) -\u003e Replica(2) QUEUED AcceptResponse(RID(R2, P1), 1) [BUS] Replica(1) -\u003e Replica(2) RECEIVED Accept(RID(R1, P1), 1, V(1, 1)) [BUS] Replica(2) -\u003e Replica(1) QUEUED AcceptResponse(RID(R1, P1), 1) [BUS] Replica(1) -\u003e Replica(3) RECEIVED Accept(RID(R1, P1), 1, V(1, 1)) [BUS] Replica(3) -\u003e Replica(1) QUEUED AcceptResponse(RID(R1, P1), 1) [BUS] Replica(3) -\u003e Replica(1) RECEIVED AcceptResponse(RID(R1, P1), 1) [ORACLE] value accepted by majority of replicas: majority=2 RID(R1, P1) value=V(1, 1) replicas=[3, 1] SEED=9075634049329737353 Always remove the current bug before introducing a new one.\nLet’s have the replica reuse a proposal number:\nimpl Replica { fn next_proposal_number(\u0026mut self) -\u003e Result\u003cu64\u003e { ... // Comment this line // self.storage.store(\u0026state)?; ... Ok(self.state.min_proposal_number) } } Run the simulation:\ncargo t action_simulation -- --nocapture ... assertion failed: `(left == right)` left: `Some(\"V(2, 14)\")`, right: `Some(\"V(2, 98)\")`: majority of replicas decided on a different value after a value was accepted note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace SEED=6875993431596082141 The accepted proposal number and value must be persisted to durable storage. Let’s forget to do that and see what happens.\nimpl Replica { fn on_accept(\u0026mut self, input: AcceptInput) { if input.proposal_number \u003e= self.state.min_proposal_number { let mut state = self.state.clone(); state.accepted_proposal_number = Some(input.proposal_number); state.accepted_value = Some(input.value); // self.storage.store(\u0026state).unwrap(); self.state = state; self.bus.send_accept_response( input.from_replica_id, AcceptOutput { from_replica_id: self.config.id, request_id: input.request_id, min_proposal_number: self.state.min_proposal_number, }, ); } } } Run the simulation:\ncargo t action_simulation -- --nocapture ... assertion `left == right` failed: majority of replicas decided on a different value after a value was accepted left: Some(\"V(1, 17)\") right: Some(\"V(2, 38)\") SEED=6875993431596082141 After sending a Prepare(n) message and receiving responses from a quorum, the value sent in Accept(n, v) messages must be the value accepted in the proposal with the highest proposal number. Let’s forget to look for the accepted value and always send the value the proposer wants to.\nimpl Replica { fn on_prepare_response(\u0026mut self, input: PrepareOutput) { let majority = self.majority(); let request_id = input.request_id; if let Some(req) = self.inflight_requests.get_mut(\u0026request_id) { req.responses.insert(input); if req.responses.len() \u003c majority { return; } // let value = req // .responses // .iter() // .filter(|response| response.accepted_proposal_number.is_some()) // .max_by_key(|response| response.accepted_proposal_number) // .map(|response| response.accepted_value.clone().unwrap()) // .unwrap_or_else(|| req.proposed_value.clone().unwrap()); let value = req.proposed_value.clone().unwrap(); let proposal_number = req.proposal_number; self.broadcast_accept(proposal_number, value); self.inflight_requests.remove(\u0026request_id); } } } Run the simulation:\ncargo t action_simulation -- --nocapture ... assertion `left == right` failed: majority of replicas decided on a different value after a value was accepted left: Some(\"V(1, 99)\") right: Some(\"V(1, 40)\") ... [BUS] Replica(1) -\u003e Replica(1) RECEIVED AcceptResponse(RID(R1, P10), 10) [ORACLE] value accepted by majority of replicas: majority=2 RID(R1, P10) value=V(1, 40) replicas=[1, 2] SEED=6369495520157998847 Even better, let’s forget to fsync the file that contains the replica state:\nimpl FileStorage { fn store(\u0026self, state: \u0026contracts::DurableState) -\u003e std::io::Result\u003c()\u003e { ... // Comment this line. // file.sync_all()?; ... Ok(()) } } Run the simulation:\ncargo t action_simulation -- --nocapture ... assertion failed: `(left == right)` left: `Some(\"V(1, 0)\")`, right: `Some(\"V(1, 58)\")`: majority of replicas decided on a different value after a value was accepted ... [BUS] Replica(3) -\u003e Replica(1) QUEUED AcceptResponse(RID(R1, P5), 5) [BUS] Replica(1) -\u003e Replica(1) RECEIVED AcceptResponse(RID(R1, P5), 5) [ORACLE] value accepted by majority of replicas: majority=2 RID(R1, P5) value=V(3, 59) replicas=[1, 2] SEED=7923659261799353388 Atomically writing to a file is complicated, let’s forget to fsync the directory since the atomic rename trick is being used:\nimpl FileStorage { fn store(\u0026self, state: \u0026contracts::DurableState) -\u003e std::io::Result\u003c()\u003e { ... // Comment this line. // self.dir_file.sync_all()?; ... Ok(()) } } Run the simulation:\ncargo t action_simulation -- --nocapture ... assertion failed: `(left == right)` left: `Some(\"V(1, 2)\")`, right: `Some(\"V(3, 27)\")`: majority of replicas decided on a different value after a value was accepted note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace SEED=11856967350924232882 Without introducing any bugs, let’s run the simulator and see what happens:\nRun the simulation:\ncargo t action_simulation -- --nocapture Spawning 4 threads SEED=3616773477915676583 Thread(0) Running simulation 0 SEED=10055364015445278185 Thread(1) Running simulation 0 SEED=17460562123704731307 Thread(2) Running simulation 0 SEED=6671866141078837726 Thread(3) Running simulation 0 Thread(3) Running simulation 1000 Thread(1) Running simulation 1000 Thread(2) Running simulation 1000 Thread(0) Running simulation 1000 Thread(3) Running simulation 2000 Thread(0) Running simulation 2000 Thread(2) Running simulation 2000 Thread(1) Running simulation 2000 Thread(0) Running simulation 3000 Thread(3) Running simulation 3000 Thread(2) Running simulation 3000 Thread(0) Running simulation 4000 Thread(1) Running simulation 3000 Thread(3) Running simulation 4000 Thread(2) Running simulation 4000 Thread(0) Running simulation 5000 Thread(2) Running simulation 5000 Thread(1) Running simulation 4000 Thread(3) Running simulation 5000 Thread(1) Running simulation 5000 Thread(0) Running simulation 6000 Thread(3) Running simulation 6000 Thread(2) Running simulation 6000 Thread(1) Running simulation 6000 Thread(3) Running simulation 7000 Thread(2) Running simulation 7000 Thread(0) Running simulation 7000 Thread(3) Running simulation 8000 Thread(1) Running simulation 7000 Thread(2) Running simulation 8000 Thread(0) Running simulation 8000 Thread(3) Running simulation 9000 Thread(1) Running simulation 8000 Thread(2) Running simulation 9000 Thread(0) Running simulation 9000 Thread(1) Running simulation 9000 test simulation::simulator::tests::action_simulation ... ok The code for the Paxos implementation and the simulator can be found here.\nNote on P P is a state machine programming language for modeling and specifying distributed systems. P is used for modeling while the simulator is used to test the real system, using the real components whenever possible. The overall structure of the system is pretty similar to the structure of a P program.\nThe implementation:\ntype request_id = (node_id: int, request_number: int); type prepareReq = (node: Node, request_id: request_id, proposal_number: int); type prepareResp = (node: Node, request_id: request_id, node_id: int, proposal_number: int, accepted_proposal_number: int, accepted_value: int); type acceptReq = (node: Node, request_id: request_id, node_id: int, proposal_number: int, value: int); type acceptResp = (request_id: request_id, node_id: int, min_proposal_number: int); type valueAcceptedReq = (node_id: int, value: int); type setNodesReq = (m: machine, nodes: seq[Node]); event eSetNodes: setNodesReq; event eSetNodesResponse; event eTriggerPrepare; event ePrepare: prepareReq; event ePrepareResp: prepareResp; event eAccept: acceptReq; event eAcceptResp: acceptResp; event eValueAccepted: valueAcceptedReq; event eRestart; event eCrash; enum MessageType { PREPARE, ACCEPT } machine Node { start state Init { entry (node_id: int) { ... } } state Crashed { on eRestart goto Restarting; ignore eCrash, eTriggerPrepare, ePrepare, ePrepareResp, eAccept, eAcceptResp; } state Restarting { entry { requests = default(map[(MessageType, int), (value: int, responses: set[(node_id: int, accepted_proposal_number: int, accepted_value: int)])]); goto HandleRequests; } } state HandleRequests { ignore eRestart; on eCrash goto Crashed; on eTriggerPrepare do { ... } on ePrepare do (req: prepareReq) { ... } on ePrepareResp do (req: prepareResp) { ... } on eAccept do (req: acceptReq) { ... } on eAcceptResp do (req: acceptResp) { ... } } } fun quorum(num_nodes: int): int { return num_nodes / 2 + 1; } The spec:\nevent spec_EventuallyDecideOnSameValue_num_nodes: int; spec EventuallyDecideOnSameValue observes spec_EventuallyDecideOnSameValue_num_nodes, eValueAccepted { // Node id -\u003e value the node accepted. Node ids for nodes that haven't accepted a value aren't in the map. var accepted_values: map[int, int]; // The value accepted by a majority of nodes. 0 means unset. var accepted_value: int; // The minimum number of nodes that form a majority in the cluster. var majority: int; start state Init { on spec_EventuallyDecideOnSameValue_num_nodes do (num_nodes: int) { majority = num_nodes / 2 + 1; goto WaitingForDecision; } } // Nodes must eventually decide. hot state WaitingForDecision { on eValueAccepted do (req: valueAcceptedReq) { accepted_values[req.node_id] = req.value; accepted_value = getValueAcceptedByMajority(); print format(\"debug: WaitingForDecision accepted_values={0}\", accepted_values); // No value accepted yet. if(accepted_value == 0) { return; } goto EnsuringDecisionDoesntChange; } } // After a majority of the nodes decide on a value, the value cannot change. state EnsuringDecisionDoesntChange { on eValueAccepted do (req: valueAcceptedReq) { var value: int; accepted_values[req.node_id] = req.value; value = getValueAcceptedByMajority(); assert accepted_value == value, format(\"nodes decided on a new value after a value has already been decided. old={0} new={1}\", accepted_value, value); } } } The P implementation includes a failure injector as well. The code can be found here.\nCan’t catch them all It’s obvious that some bugs won’t be found because the inputs are generated randomly and some components will end up being replaced by fake implementations to remove non-determinism or to make the simulation run at an acceptable speed. Combine dst with other testing and modeling techniques for maximum effectiveness.\nReferences Paxos made simple\nP\nTigerbeetle\n“Testing Distributed Systems w/ Deterministic Simulation” by Will Wilson\nFF meetup #4 - Deterministic simulation testing\nWhat’s the big deal about Deterministic Simulation Testing?\n","wordCount":"4430","inLanguage":"en","image":"https://poorlydefinedbehaviour.github.io/papermod-cover.png","datePublished":"2024-11-06T22:00:00-03:00","dateModified":"2024-11-06T22:00:00-03:00","author":{"@type":"Person","name":"poorlydefinedbehaviour"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://poorlydefinedbehaviour.github.io/posts/deterministic_simulation_testing/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"https://poorlydefinedbehaviour.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://poorlydefinedbehaviour.github.io/ title=Home><span>Home</span></a></li><li><a href=https://poorlydefinedbehaviour.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://poorlydefinedbehaviour.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://poorlydefinedbehaviour.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://poorlydefinedbehaviour.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://poorlydefinedbehaviour.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤</h1><div class=post-meta><span title='2024-11-06 22:00:00 -0300 -0300'>November 6, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;poorlydefinedbehaviour&nbsp;|&nbsp;<a href=https://github.com/PoorlyDefinedBehaviour/poorlydefinedbehaviour.github.io/tree/main/content/posts/deterministic_simulation_testing/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#center%f0%9d%94%87%f0%9d%94%a2%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%af%f0%9d%94%aa%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a6%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%a0-%f0%9d%94%b0%f0%9d%94%a6%f0%9d%94%aa%f0%9d%94%b2%f0%9d%94%a9%f0%9d%94%9e%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ac%f0%9d%94%ab-%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a4center aria-label="𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤">𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤</a><ul><ul><li><a href=#example-based-testing aria-label="Example based testing">Example based testing</a></li><li><a href=#property-based-testing aria-label="Property based testing">Property based testing</a></li><li><a href=#deterministic-simulation-testing aria-label="Deterministic simulation testing">Deterministic simulation testing</a></li><li><a href=#example-applying-deterministic-simulation-testing-to-single-decree-paxos aria-label="Example: Applying deterministic simulation testing to single-decree Paxos">Example: Applying deterministic simulation testing to single-decree Paxos</a><ul><li><a href=#the-model aria-label="The model">The model</a></li><li><a href=#single-decree-paxos aria-label="Single-decree Paxos">Single-decree Paxos</a></li></ul></li><li><a href=#note-on-p aria-label="Note on P">Note on P</a></li><li><a href=#cant-catch-them-all aria-label="Can&rsquo;t catch them all">Can&rsquo;t catch them all</a></li><li><a href=#references aria-label=References>References</a></li></ul></ul></li></ul></div></details></div><div class=post-content><h1 id=center𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠-𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫-𝔱𝔢𝔰𝔱𝔦𝔫𝔤center><center>𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤</center><a hidden class=anchor aria-hidden=true href=#center𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠-𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫-𝔱𝔢𝔰𝔱𝔦𝔫𝔤center>#</a></h1><p><em><a href=https://www.dictionary.com/browse/deterministic>deterministic</a></em>: of or relating to a process or model in which the output is determined solely by the input and initial conditions, thereby always returning the same results ( stochastic ):
The algorithms are simple and deterministic, so the results are predictable and reproducible.</p><h3 id=example-based-testing>Example based testing<a hidden class=anchor aria-hidden=true href=#example-based-testing>#</a></h3><p>Example based testing works fine for simple cases where there&rsquo;s only a small number of actions that matter.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span><span style=color:#f92672>%</span>test_unit <span style=color:#e6db74>&#34;append entries: truncates the log on entry conflict&#34;</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> storage <span style=color:#f92672>=</span> make <span style=color:#f92672>{</span> dir <span style=color:#f92672>=</span> Test_util.temp_dir () <span style=color:#f92672>}</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Leader adds some entries to the replica&#39;s log. *)</span>
</span></span><span style=display:flex><span>  append_entries storage <span style=color:#f92672>(</span>last_log_index storage<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>{</span> term <span style=color:#f92672>=</span> 1L<span style=color:#f92672>;</span> data <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#f92672>};</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>{</span> term <span style=color:#f92672>=</span> 2L<span style=color:#f92672>;</span> data <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;2&#34;</span> <span style=color:#f92672>};</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>{</span> term <span style=color:#f92672>=</span> 3L<span style=color:#f92672>;</span> data <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;3&#34;</span> <span style=color:#f92672>};</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Another leader overrides the replica&#39;s log. *)</span>
</span></span><span style=display:flex><span>  append_entries storage 2L
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span> <span style=color:#f92672>{</span> term <span style=color:#f92672>=</span> 4L<span style=color:#f92672>;</span> data <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;3&#34;</span> <span style=color:#f92672>};</span> <span style=color:#f92672>{</span> term <span style=color:#f92672>=</span> 4L<span style=color:#f92672>;</span> data <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;4&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>assert</span> <span style=color:#f92672>(</span>entry_at_index storage 1L <span style=color:#f92672>=</span> <span style=color:#a6e22e>Some</span> <span style=color:#f92672>{</span> term <span style=color:#f92672>=</span> 1L<span style=color:#f92672>;</span> data <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>assert</span> <span style=color:#f92672>(</span>entry_at_index storage 2L <span style=color:#f92672>=</span> <span style=color:#a6e22e>Some</span> <span style=color:#f92672>{</span> term <span style=color:#f92672>=</span> 2L<span style=color:#f92672>;</span> data <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;2&#34;</span> <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Entry at index 3 has been overwritten. *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>assert</span> <span style=color:#f92672>(</span>entry_at_index storage 3L <span style=color:#f92672>=</span> <span style=color:#a6e22e>Some</span> <span style=color:#f92672>{</span> term <span style=color:#f92672>=</span> 4L<span style=color:#f92672>;</span> data <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;3&#34;</span> <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Entry at index 4 is new. *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>assert</span> <span style=color:#f92672>(</span>entry_at_index storage 4L <span style=color:#f92672>=</span> <span style=color:#a6e22e>Some</span> <span style=color:#f92672>{</span> term <span style=color:#f92672>=</span> 4L<span style=color:#f92672>;</span> data <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;4&#34;</span> <span style=color:#f92672>})</span>
</span></span></code></pre></div><p>It becomes way harder to think of and write the examples when the bugs you&rsquo;re looking for only happen after several events that need to happen in a specific order.</p><p><img loading=lazy src=/posts/deterministic_simulation_testing/images/input_tree_0.png></p><center>A bug found deep in the input tree.</center><h3 id=property-based-testing>Property based testing<a hidden class=anchor aria-hidden=true href=#property-based-testing>#</a></h3><p>Property based testing is a testing technique where a wide range of inputs are generated automatically unlike traditional example based testing where the inputs have to be manually thought of and written. The idea is that by auto generating inputs, the system will end up being tested with inputs that the programmer wouldn&rsquo;t think of otherwise.</p><p><strong>Basic input</strong><br>Problem: Create a function that given a vec of integers <code>nums</code> and an integer <code>k</code>, returns the kth largest element in the vec.</p><p>In this case, the implementation uses a max heap to find the kth largest element in the vec in <code>O(k log n)</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>find_kth_largest</span>(nums: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>, k: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> heap: <span style=color:#a6e22e>BinaryHeap</span><span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> nums.into_iter().collect();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>k <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> heap.pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    heap.pop().unwrap()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The test generates a random <code>Vec&lt;i32></code>, finds the kth largest element by sorting the vec &ndash; <em>using a different and probably easier to understand implementation than the function being tested</em> &ndash; and asserts that the function returns the same value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> quickcheck::quickcheck;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>check</span>(nums: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>, k: <span style=color:#66d9ef>usize</span>, f: <span style=color:#a6e22e>fn</span>(Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>, <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> nums.is_empty() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> k <span style=color:#f92672>%</span> nums.len();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> f(nums.clone(), k <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> nums <span style=color:#f92672>=</span> nums;
</span></span><span style=display:flex><span>        nums.sort_unstable();
</span></span><span style=display:flex><span>        nums.reverse();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> expected <span style=color:#f92672>=</span> nums[k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        expected <span style=color:#f92672>==</span> result
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    quickcheck! {
</span></span><span style=display:flex><span>      <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_find_kth_largest</span>(nums: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>, k: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        check(nums, k, find_kth_largest)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Ideally, one or more properties would be defined and checked against the output but starting simple by just checking that the output makes sense works well in a lot of cases.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>sort</span>(nums: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> quickcheck::quickcheck;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>    quickcheck! {
</span></span><span style=display:flex><span>      <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_sort</span>(nums: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> nums <span style=color:#f92672>=</span> nums;
</span></span><span style=display:flex><span>        sort(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> nums);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>nums.is_empty() {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>nums.len()<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>            assert!(nums[i] <span style=color:#f92672>&lt;=</span> nums[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>Property</em>: After sorting, every <code>nums[i]</code> is less than or equal to <code>nums[i + 1]</code>.</p><ul><li>Generate a large number of inputs randomly instead of writing just a few of them manually.</li></ul><p><strong>More sophisticated inputs</strong><br>It may be possible to interact with the system under test in several ways. Imagine that a max heap with a different implementation from the std library was being written. Sometimes a bug will be found only when a specific set of events happen in a specific order, popping from an empty heap, pushing two elements and popping 3 times, for example.</p><p>Instead of thinking of all possible operation interleavings, generate a list of operations at random and apply them to the heap. The std heap could be used as a model &ndash; by having the same operations applied to it &ndash; to check that our heap behaves correctly from the user&rsquo;s point of view. Run the test several times to increase the chance of a finding a bug.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    quickcheck! {
</span></span><span style=display:flex><span>      <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_heap</span>(actions: Vec<span style=color:#f92672>&lt;</span>Action<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> heap <span style=color:#f92672>=</span> Heap::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> model <span style=color:#f92672>=</span> BinaryHeap::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> action <span style=color:#66d9ef>in</span> actions {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>match</span> action {
</span></span><span style=display:flex><span>            Action::Push(v) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>              model.push(v);
</span></span><span style=display:flex><span>              heap.push(v);
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            Action::Pop <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>              assert_eq!(model.pop(), heap.pop());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The same idea could be used to test other systems, the difference is that instead of using the std heap, a simplified model of the real thing &ndash; that hopefully behaves correctly &ndash; would be used, for example, an in memory map that models a disk-based key-value store. Here&rsquo;s an example of a append-only log in Go that uses an in-memory slice as the model.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestFileStorage</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Parallel</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>OpAppendEntries</span>           = <span style=color:#e6db74>&#34;AppendEntries&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>OpTruncateLogStartingFrom</span> = <span style=color:#e6db74>&#34;TruncateLogStartingFrom&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>OpGetEntryAtIndex</span>         = <span style=color:#e6db74>&#34;GetEntryAtIndex&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>OpGetBatch</span>                = <span style=color:#e6db74>&#34;GetBatch&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>OpLastLogIndex</span>            = <span style=color:#e6db74>&#34;LastLogIndex&#34;</span>
</span></span><span style=display:flex><span>	)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rapid</span>.<span style=color:#a6e22e>Check</span>(<span style=color:#a6e22e>t</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>rapid</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>storage</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewFileStorage</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%s/raft-go/%s&#34;</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>TempDir</span>(), <span style=color:#a6e22e>uuid</span>.<span style=color:#a6e22e>New</span>().<span style=color:#a6e22e>String</span>()))
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>NoError</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>model</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newModel</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ops</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rapid</span>.<span style=color:#a6e22e>SliceOf</span>(<span style=color:#a6e22e>rapid</span>.<span style=color:#a6e22e>SampledFrom</span>([]<span style=color:#66d9ef>string</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>OpAppendEntries</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>OpTruncateLogStartingFrom</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>OpGetEntryAtIndex</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>OpGetBatch</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>OpLastLogIndex</span>,
</span></span><span style=display:flex><span>		})).
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Draw</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;ops&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>op</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>ops</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>op</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OpAppendEntries</span>:
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>entries</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rapid</span>.<span style=color:#a6e22e>SliceOf</span>(<span style=color:#a6e22e>entryGenerator</span>()).<span style=color:#a6e22e>Draw</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;append: entries&#34;</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>NoError</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>storage</span>.<span style=color:#a6e22e>AppendEntries</span>(<span style=color:#a6e22e>entries</span>))
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>NoError</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>AppendEntries</span>(<span style=color:#a6e22e>entries</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Logf</span>(<span style=color:#e6db74>&#34;appended %d entries\n&#34;</span>, len(<span style=color:#a6e22e>entries</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OpTruncateLogStartingFrom</span>:
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>maybeExistingIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rapid</span>.<span style=color:#a6e22e>Uint64Range</span>(<span style=color:#ae81ff>1</span>, uint64(len(<span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>entries</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>).<span style=color:#a6e22e>Draw</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;truncate: maybeExistingIndex&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>storageErr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>storage</span>.<span style=color:#a6e22e>TruncateLogStartingFrom</span>(<span style=color:#a6e22e>maybeExistingIndex</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>modelErr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>TruncateLogStartingFrom</span>(<span style=color:#a6e22e>maybeExistingIndex</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Logf</span>(<span style=color:#e6db74>&#34;truncated from index %d len(model.entries)=%+v storageErr=%+v modelErr=%+v\n&#34;</span>, <span style=color:#a6e22e>maybeExistingIndex</span>, len(<span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>entries</span>), <span style=color:#a6e22e>storageErr</span>, <span style=color:#a6e22e>modelErr</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>ErrorIs</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>storageErr</span>, <span style=color:#a6e22e>modelErr</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OpGetEntryAtIndex</span>:
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>maybeExistingIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rapid</span>.<span style=color:#a6e22e>Uint64Range</span>(<span style=color:#ae81ff>1</span>, uint64(len(<span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>entries</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>).<span style=color:#a6e22e>Draw</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;get entry: maybeExistingIndex&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>storageEntry</span>, <span style=color:#a6e22e>storageErr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>storage</span>.<span style=color:#a6e22e>GetEntryAtIndex</span>(<span style=color:#a6e22e>maybeExistingIndex</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>modelEntry</span>, <span style=color:#a6e22e>modelErr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>GetEntryAtIndex</span>(<span style=color:#a6e22e>maybeExistingIndex</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Logf</span>(<span style=color:#e6db74>&#34;getting entry at index %d storageErr=%+v modelErr=%+v\n&#34;</span>, <span style=color:#a6e22e>maybeExistingIndex</span>, <span style=color:#a6e22e>storageErr</span>, <span style=color:#a6e22e>modelErr</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>modelEntry</span>, <span style=color:#a6e22e>storageEntry</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>ErrorIs</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>storageErr</span>, <span style=color:#a6e22e>modelErr</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OpGetBatch</span>:
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>maybeExistingIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rapid</span>.<span style=color:#a6e22e>Uint64Range</span>(<span style=color:#ae81ff>1</span>, uint64(len(<span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>entries</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>).<span style=color:#a6e22e>Draw</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;get batch: maybe existing index&#34;</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>batchSize</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rapid</span>.<span style=color:#a6e22e>Uint64Range</span>(<span style=color:#ae81ff>1</span>, uint64(len(<span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>entries</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>).<span style=color:#a6e22e>Draw</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;get batch: batch size&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>storageBatch</span>, <span style=color:#a6e22e>storageErr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>storage</span>.<span style=color:#a6e22e>GetBatch</span>(<span style=color:#a6e22e>maybeExistingIndex</span>, <span style=color:#a6e22e>batchSize</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>modelBatch</span>, <span style=color:#a6e22e>modelErr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>GetBatch</span>(<span style=color:#a6e22e>maybeExistingIndex</span>, <span style=color:#a6e22e>batchSize</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Logf</span>(<span style=color:#e6db74>&#34;get batch index=%d batchSize=%d len(storageBatch)=%+v storageErr=%+v len(modelBatch)=%+v modelErr=%+v\n&#34;</span>,
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>maybeExistingIndex</span>,
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>batchSize</span>,
</span></span><span style=display:flex><span>					len(<span style=color:#a6e22e>storageBatch</span>),
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>storageErr</span>,
</span></span><span style=display:flex><span>					len(<span style=color:#a6e22e>modelBatch</span>),
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>modelErr</span>,
</span></span><span style=display:flex><span>				)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>ErrorIs</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>storageErr</span>, <span style=color:#a6e22e>modelErr</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>modelBatch</span>, <span style=color:#a6e22e>storageBatch</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OpLastLogIndex</span>:
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>storageLastLogIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>storage</span>.<span style=color:#a6e22e>LastLogIndex</span>()
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>modelLastLogIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>LastLogIndex</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>modelLastLogIndex</span>, <span style=color:#a6e22e>storageLastLogIndex</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>				panic(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;unexpected op: %s&#34;</span>, <span style=color:#a6e22e>op</span>))
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=deterministic-simulation-testing>Deterministic simulation testing<a hidden class=anchor aria-hidden=true href=#deterministic-simulation-testing>#</a></h3><p>For more complicated systems with several components, it may be complicated to write useful tests. What if the input space could be explored automatically by generating inputs in the same way inputs are generated for property based testing and the events that led to the bug replayed without effort? After defining a model of how the system should work &ndash; which actions and events the system should be able to handle &ndash; component failures can be injected according to the failure model &ndash; the failures the system should be able to handle &ndash;.</p><p>Start by removing non-determinism introduced by things such as threads or iterating over a data structure that yields a different order in each iteration. This means moving IO to the edges of the system and replacing the real implementation &ndash; where it is not deterministic or fast enough &ndash; with a fake version that behaves like the real thing.</p><p>Next, generate actions such as simulating an user request using a seeded prng. When a bug is found, the simulation can be re-run with the same seed to hit the same bug over and over again.</p><ul><li><em>Bugs are reproducible</em> by running the simulation with the seed that was used when the bug was found.</li></ul><h3 id=example-applying-deterministic-simulation-testing-to-single-decree-paxos>Example: Applying deterministic simulation testing to single-decree Paxos<a hidden class=anchor aria-hidden=true href=#example-applying-deterministic-simulation-testing-to-single-decree-paxos>#</a></h3><p>Given a set of computers that can propose values, how to get the computers to decide on a value?</p><ul><li>The chosen value must be proposed by one of the computers</li><li>Only a single value can be chosen</li></ul><p><a href=https://lamport.azurewebsites.net/pubs/paxos-simple.pdf>Paxos</a> is one of the algorithms that can be used to solve the consensus problem.</p><h4 id=the-model>The model<a hidden class=anchor aria-hidden=true href=#the-model>#</a></h4><ul><li>Computers run at different speeds</li><li>Computers may stop and restart at any time</li><li>Messages sent from one computer to another can be lost, delayed or duplicated</li></ul><h4 id=single-decree-paxos>Single-decree Paxos<a hidden class=anchor aria-hidden=true href=#single-decree-paxos>#</a></h4><p>The algorithm can be explained in two phases:</p><p><strong>Phase 1</strong></p><ul><li>A computer that proposes values is called a <code>proposer</code>. A value is proposed by broadcasting a <code>Prepare(n)</code> message to the computers in the cluster where <code>n</code> is a unique monotonically increasing number.</li><li>When a computer receives a <code>Prepare(n)</code> message, it responds with <code>Ok(accepted_proposal_number, accepted_value)</code> if <code>n</code> is the greatest proposal number it has seen so far where <code>accepted_proposal_number</code> and <code>accepted_value</code> are from latest proposal the computer has accepted, if any.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Replica {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next_proposal_number</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Result<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> state <span style=color:#f92672>=</span> contracts::DurableState {
</span></span><span style=display:flex><span>            min_proposal_number: <span style=color:#a6e22e>self</span>.state.min_proposal_number <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>..</span>self.state.clone()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        self.storage.store(<span style=color:#f92672>&amp;</span>state)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        self.state <span style=color:#f92672>=</span> state;
</span></span><span style=display:flex><span>        Ok(self.state.min_proposal_number)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Phase 1.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>on_start_proposal</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, value: String) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> proposal_number <span style=color:#f92672>=</span> self.next_proposal_number().unwrap();
</span></span><span style=display:flex><span>        self.broadcast_prepare(proposal_number, value);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Phase 1.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>on_prepare</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, input: <span style=color:#a6e22e>PrepareInput</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> input.proposal_number <span style=color:#f92672>&gt;</span> self.state.min_proposal_number {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> state <span style=color:#f92672>=</span> self.state.clone();
</span></span><span style=display:flex><span>            state.min_proposal_number <span style=color:#f92672>=</span> input.proposal_number;
</span></span><span style=display:flex><span>            self.storage.store(<span style=color:#f92672>&amp;</span>state).unwrap();
</span></span><span style=display:flex><span>            self.state <span style=color:#f92672>=</span> state;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self.bus.send_prepare_response(
</span></span><span style=display:flex><span>                input.from_replica_id,
</span></span><span style=display:flex><span>                PrepareOutput {
</span></span><span style=display:flex><span>                    from_replica_id: <span style=color:#a6e22e>self</span>.config.id,
</span></span><span style=display:flex><span>                    request_id: <span style=color:#a6e22e>input</span>.request_id,
</span></span><span style=display:flex><span>                    accepted_proposal_number: <span style=color:#a6e22e>self</span>.state.accepted_proposal_number,
</span></span><span style=display:flex><span>                    accepted_value: <span style=color:#a6e22e>self</span>.state.accepted_value.clone(),
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#f92672>..</span>.
</span></span></code></pre></div><p><strong>Phase 2</strong></p><ul><li>After broadcasting <code>Prepare(n)</code>, the proposer waits for responses from a majority of computers in the cluster</li><li>After receiving responses from the majority, the proposer broadcasts a <code>Accept(n, v)</code> message to the computers in the cluster where <code>n</code> is the same proposal number sent in <code>Prepare(n)</code> message and <code>v</code> is the <code>accepted_value</code> from the message with the highest <code>accepted_proposal_number</code> received in response to the <code>Prepare(n)</code> messages or the value the proposer would like the computers to decide on if no proposals have been accepted yet.</li><li>When a computer receives a <code>Accept(n, v)</code> message, it responds with <code>Ok()</code> if <code>n</code> is greater than or equal to the greatest proposal number it has seen in <code>Phase 1</code>.</li></ul><blockquote><ul><li>The last used proposal number, the highest proposal number seen by a computer, the accepted proposal number and the accepted value are stored in durable storage.</li></ul></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Phase 2.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>on_prepare_response</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, input: <span style=color:#a6e22e>PrepareOutput</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> majority <span style=color:#f92672>=</span> self.majority();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> request_id <span style=color:#f92672>=</span> input.request_id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(req) <span style=color:#f92672>=</span> self.inflight_requests.get_mut(<span style=color:#f92672>&amp;</span>request_id) {
</span></span><span style=display:flex><span>            req.responses.insert(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> req.responses.len() <span style=color:#f92672>&lt;</span> majority {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> req
</span></span><span style=display:flex><span>                .responses
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .filter(<span style=color:#f92672>|</span>response<span style=color:#f92672>|</span> response.accepted_proposal_number.is_some())
</span></span><span style=display:flex><span>                .max_by_key(<span style=color:#f92672>|</span>response<span style=color:#f92672>|</span> response.accepted_proposal_number)
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>response<span style=color:#f92672>|</span> response.accepted_value.clone().unwrap())
</span></span><span style=display:flex><span>                .unwrap_or_else(<span style=color:#f92672>||</span> req.proposed_value.clone().unwrap());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> proposal_number <span style=color:#f92672>=</span> req.proposal_number;
</span></span><span style=display:flex><span>            self.broadcast_accept(proposal_number, value);
</span></span><span style=display:flex><span>            self.inflight_requests.remove(<span style=color:#f92672>&amp;</span>request_id);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Phase 2.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>on_accept</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, input: <span style=color:#a6e22e>AcceptInput</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> input.proposal_number <span style=color:#f92672>&gt;=</span> self.state.min_proposal_number {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> state <span style=color:#f92672>=</span> self.state.clone();
</span></span><span style=display:flex><span>            state.accepted_proposal_number <span style=color:#f92672>=</span> Some(input.proposal_number);
</span></span><span style=display:flex><span>            state.accepted_value <span style=color:#f92672>=</span> Some(input.value);
</span></span><span style=display:flex><span>            self.storage.store(<span style=color:#f92672>&amp;</span>state).unwrap();
</span></span><span style=display:flex><span>            self.state <span style=color:#f92672>=</span> state;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self.bus.send_accept_response(
</span></span><span style=display:flex><span>                input.from_replica_id,
</span></span><span style=display:flex><span>                AcceptOutput {
</span></span><span style=display:flex><span>                    from_replica_id: <span style=color:#a6e22e>self</span>.config.id,
</span></span><span style=display:flex><span>                    request_id: <span style=color:#a6e22e>input</span>.request_id,
</span></span><span style=display:flex><span>                    min_proposal_number: <span style=color:#a6e22e>self</span>.state.min_proposal_number,
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/posts/deterministic_simulation_testing/images/paxos_flow_1.png></p><center>An example of a Paxos round.</center><p><strong>The simulation</strong></p><p>The network calls were replaced by a fake implementation to make it easier to drop, duplicate and delay messages. Insteading of sending messages using TCP or UDP, messages are held in an in-memory queue and are delivered by calling a method since every replica is running in memory.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SimMessageBus</span> {
</span></span><span style=display:flex><span>    queue: <span style=color:#a6e22e>RefCell</span><span style=color:#f92672>&lt;</span>MessageQueue<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Generate a seed for the prng. The prng will be used to generate actions during the simulation. The seed can be passed as input the program to generate the same sequence of inputs after a test failure.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>action_simulation</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> seed: <span style=color:#66d9ef>u64</span> <span style=color:#f92672>=</span> std::env::var(<span style=color:#e6db74>&#34;SEED&#34;</span>)
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> v.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>().unwrap())
</span></span><span style=display:flex><span>            .unwrap_or_else(<span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> rand::thread_rng().gen());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        eprintln!(<span style=color:#e6db74>&#34;SEED=</span><span style=color:#e6db74>{seed}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> rng <span style=color:#f92672>=</span> Rc::new(RefCell::new(rand::rngs::StdRng::seed_from_u64(seed)));
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The simulator uses the seeded prng to generate actions, which include actions such as delivering a message, crashing a replica, generating a user request and more. The simulator generates <code>max_actions</code> actions where each action is generated based on the current state of the system, this is done to improve the number of interesting input sequences.</p><p>It is not that useful to crash a replica that&rsquo;s already in the crashed state or to crash more than <code>F</code> replicas if we are interested in testing that a cluster with <code>2F + 1</code> replicas can make progress as long as the majority of replicas are up. In general, actions that trigger failures should be generated according to the failure model.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ActionSimulator</span> {
</span></span><span style=display:flex><span>    config: <span style=color:#a6e22e>ActionSimulatorConfig</span>,
</span></span><span style=display:flex><span>    rng: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span>StdRng<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    bus: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>SimMessageBus<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    replicas: Vec<span style=color:#f92672>&lt;</span>Replica<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Action</span> {
</span></span><span style=display:flex><span>    SendUserRequest,
</span></span><span style=display:flex><span>    CrashReplica,
</span></span><span style=display:flex><span>    RestartReplica,
</span></span><span style=display:flex><span>    DeliverMessage,
</span></span><span style=display:flex><span>    DropMessage,
</span></span><span style=display:flex><span>    DuplicateMessage,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> ActionSimulator {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next_action</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; <span style=color:#a6e22e>Action</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Use the prng + knowledge about the current system state to generate the next action.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// It&#39;s not that useful to crash a replica that&#39;s already in the crashed state.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>run</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.config.max_actions {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> action <span style=color:#f92672>=</span> self.next_action();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> action {
</span></span><span style=display:flex><span>              Action::SendUserRequest <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Trigger a proposal from a replica.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              }
</span></span><span style=display:flex><span>              Action::CrashReplica <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Crash a random replica.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              }
</span></span><span style=display:flex><span>              Action::RestartReplica <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Restart a random replica.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              }
</span></span><span style=display:flex><span>              Action::Delivermessage <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Deliver a random message from the messages in flight.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              }
</span></span><span style=display:flex><span>              Action::DropMessage <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Drop a random message from the messages in flight.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              }
</span></span><span style=display:flex><span>              Action::DuplicateMessage <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Duplicate a random message from the messages in flight.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When a <code>Action::DeliverMessage</code> is generated, a random message is removed from the queue and delivered to the target replica:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>pop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>PendingMessage<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.items.is_empty() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> i <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>            .rng
</span></span><span style=display:flex><span>            .as_ref()
</span></span><span style=display:flex><span>            .borrow_mut()
</span></span><span style=display:flex><span>            .gen_range(<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.items.len());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> item <span style=color:#f92672>=</span> self.items.swap_remove(i);
</span></span><span style=display:flex><span>        Some(item)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Replicas get instantiated and passed to the simulator along with the configuration. The simulation will run <code>10000</code> times where each run will generate <code>1000</code> actions (e.g. <code>CrashReplica</code>, <code>DeliverMessage</code>). This simulator is actually running several threads with one simulation each to find bugs faster. The simulation in each thread is deterministic and isolated.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>action_simulation</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> count <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> std::env::var(<span style=color:#e6db74>&#34;SEED&#34;</span>).is_ok() {
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            std::env::var(<span style=color:#e6db74>&#34;MAX_THREADS&#34;</span>)
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> v.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>().unwrap())
</span></span><span style=display:flex><span>                .unwrap_or_else(<span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> std::thread::available_parallelism().unwrap().get())
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> max_iters <span style=color:#f92672>=</span> std::env::var(<span style=color:#e6db74>&#34;MAX_ITERS&#34;</span>)
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> v.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>().unwrap())
</span></span><span style=display:flex><span>            .unwrap_or_else(<span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> <span style=color:#ae81ff>10_000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> max_actions <span style=color:#f92672>=</span> std::env::var(<span style=color:#e6db74>&#34;MAX_ACTIONS&#34;</span>)
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> v.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span>().unwrap())
</span></span><span style=display:flex><span>            .unwrap_or_else(<span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        eprintln!(<span style=color:#e6db74>&#34;Spawning </span><span style=color:#e6db74>{count}</span><span style=color:#e6db74> threads&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> handles <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>count)
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>thread_id<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                std::thread::Builder::new()
</span></span><span style=display:flex><span>                    .name(format!(<span style=color:#e6db74>&#34;Thread(</span><span style=color:#e6db74>{thread_id}</span><span style=color:#e6db74>)&#34;</span>))
</span></span><span style=display:flex><span>                    .spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> seed: <span style=color:#66d9ef>u64</span> <span style=color:#f92672>=</span> std::env::var(<span style=color:#e6db74>&#34;SEED&#34;</span>)
</span></span><span style=display:flex><span>                            .map(<span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> v.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>().unwrap())
</span></span><span style=display:flex><span>                            .unwrap_or_else(<span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> rand::thread_rng().gen());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        eprintln!(<span style=color:#e6db74>&#34;SEED=</span><span style=color:#e6db74>{seed}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> rng <span style=color:#f92672>=</span> Rc::new(RefCell::new(rand::rngs::StdRng::seed_from_u64(seed)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>max_iters {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> i <span style=color:#f92672>%</span> <span style=color:#ae81ff>1_000</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                                eprintln!(<span style=color:#e6db74>&#34;Thread(</span><span style=color:#e6db74>{thread_id}</span><span style=color:#e6db74>) Running simulation </span><span style=color:#e6db74>{i}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> simulator_config <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> rng <span style=color:#f92672>=</span> rng.borrow_mut();
</span></span><span style=display:flex><span>                                ActionSimulatorConfig {
</span></span><span style=display:flex><span>                                    max_actions,
</span></span><span style=display:flex><span>                                    max_user_requests: <span style=color:#a6e22e>rng</span>.gen::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span>() <span style=color:#f92672>%</span> <span style=color:#ae81ff>100</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> activity_log <span style=color:#f92672>=</span> Rc::new(RefCell::new(ActivityLog::new()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> servers <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> majority <span style=color:#f92672>=</span> servers.len() <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> bus: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>SimMessageBus<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Rc::new(SimMessageBus::new(
</span></span><span style=display:flex><span>                                Rc::clone(<span style=color:#f92672>&amp;</span>rng),
</span></span><span style=display:flex><span>                                Oracle::new(majority, Rc::clone(<span style=color:#f92672>&amp;</span>activity_log)),
</span></span><span style=display:flex><span>                                Rc::clone(<span style=color:#f92672>&amp;</span>activity_log),
</span></span><span style=display:flex><span>                            ));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> nodes: Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> servers
</span></span><span style=display:flex><span>                                .iter()
</span></span><span style=display:flex><span>                                .map(<span style=color:#f92672>|</span>id<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>let</span> fs <span style=color:#f92672>=</span> Rc::new(SimFileSystem::new());
</span></span><span style=display:flex><span>                                    Node {
</span></span><span style=display:flex><span>                                        replica: <span style=color:#a6e22e>Replica</span>::new(
</span></span><span style=display:flex><span>                                            Config {
</span></span><span style=display:flex><span>                                                id: <span style=color:#f92672>*</span>id,
</span></span><span style=display:flex><span>                                                replicas: <span style=color:#a6e22e>servers</span>.clone(),
</span></span><span style=display:flex><span>                                            },
</span></span><span style=display:flex><span>                                            Rc::clone(<span style=color:#f92672>&amp;</span>bus) <span style=color:#66d9ef>as</span> Rc<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> contracts::MessageBus<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>                                            Rc::new(
</span></span><span style=display:flex><span>                                                FileStorage::new(
</span></span><span style=display:flex><span>                                                    Rc::clone(<span style=color:#f92672>&amp;</span>fs) <span style=color:#66d9ef>as</span> Rc<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> contracts::FileSystem<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>                                                    PathBuf::from(<span style=color:#e6db74>&#34;dir&#34;</span>),
</span></span><span style=display:flex><span>                                                )
</span></span><span style=display:flex><span>                                                .unwrap(),
</span></span><span style=display:flex><span>                                            ),
</span></span><span style=display:flex><span>                                        ),
</span></span><span style=display:flex><span>                                        fs,
</span></span><span style=display:flex><span>                                    }
</span></span><span style=display:flex><span>                                })
</span></span><span style=display:flex><span>                                .collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sim <span style=color:#f92672>=</span> ActionSimulator::new(
</span></span><span style=display:flex><span>                                simulator_config,
</span></span><span style=display:flex><span>                                Rc::clone(<span style=color:#f92672>&amp;</span>rng),
</span></span><span style=display:flex><span>                                nodes,
</span></span><span style=display:flex><span>                                Rc::clone(<span style=color:#f92672>&amp;</span>bus),
</span></span><span style=display:flex><span>                                Rc::clone(<span style=color:#f92672>&amp;</span>activity_log),
</span></span><span style=display:flex><span>                            );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> std::panic::catch_unwind(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>                                sim.run();
</span></span><span style=display:flex><span>                                assert!(sim.bus.is_empty());
</span></span><span style=display:flex><span>                            });
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> result.is_err() {
</span></span><span style=display:flex><span>                                activity_log.borrow_mut().print_events();
</span></span><span style=display:flex><span>                                eprintln!(<span style=color:#e6db74>&#34;SEED=</span><span style=color:#e6db74>{seed}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>                                std::process::exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Result<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span>, _<span style=color:#f92672>&gt;&gt;</span>()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> handle <span style=color:#66d9ef>in</span> handles {
</span></span><span style=display:flex><span>            handle.join().unwrap();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In a sense, the number of times the simulation runs can be understood as the max number of paths we would like to visit from an input tree and <code>max_actions</code> can be thought of as the depth of every path in the tree. The simulation may end up visiting the same path multiple times, solving that is an optimization for the future.</p><p><img loading=lazy src=/posts/deterministic_simulation_testing/images/input_tree_1.png></p><center>An example of a path in the input tree where a message is delivered and then the replica crashes.</center><p><strong>Verifying the system state is valid</strong></p><p>At the moment, the simulation doesn&rsquo;t do anything because there are no assertions. Let&rsquo;s add an oracle &ndash; something that has a bird&rsquo;s eye view of the system &ndash; that will receive a copy of the messages sent from replicas.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Oracle {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>on_accept_sent</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, _to_replica_id: <span style=color:#a6e22e>ReplicaId</span>, input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>AcceptInput</span>) {
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>on_proposal_accepted</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, _to_replica_id: <span style=color:#a6e22e>ReplicaId</span>, output: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>AcceptOutput</span>) {
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The basic oracle keeps track of accepted proposals, after a proposal has been accepted by a majority of replicas, it asserts that no other value is even chosen.</p><p>In this case, the system state is seen from the perspective of an outside observer that only has access to the messages sent from the replicas but there&rsquo;s nothing stopping assertions from being added to the internal modules or having the oracle inspect the internal state of the system under test.</p><p>Even basic simulations can catch bugs. Let&rsquo;s ignore the requirement the proposal numbers must be unique by accepting proposal numbers that are the highest the replica has seen.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Replica {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>on_prepare</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, input: <span style=color:#a6e22e>PrepareInput</span>) {
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>Change</span> from <span style=color:#960050;background-color:#1e0010>`</span><span style=color:#f92672>&gt;</span><span style=color:#960050;background-color:#1e0010>`</span> to <span style=color:#960050;background-color:#1e0010>`</span><span style=color:#f92672>&gt;=</span><span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if input.proposal_number &gt; self.state.min_proposal_number {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> input.proposal_number <span style=color:#f92672>&gt;=</span> self.state.min_proposal_number {
</span></span><span style=display:flex><span>            <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Run the simulation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo t action_simulation -- --nocapture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>thread <span style=color:#e6db74>&#39;Thread(3)&#39;</span> panicked at src/simulation/oracle.rs:75:17:
</span></span><span style=display:flex><span>assertion failed: <span style=color:#e6db74>`</span><span style=color:#f92672>(</span>left <span style=color:#f92672>==</span> right<span style=color:#f92672>)</span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>  left: <span style=color:#e6db74>`</span>Some<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;V(1, 44)&#34;</span><span style=color:#f92672>)</span><span style=color:#e6db74>`</span>,
</span></span><span style=display:flex><span> right: <span style=color:#e6db74>`</span>Some<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;V(2, 93)&#34;</span><span style=color:#f92672>)</span><span style=color:#e6db74>`</span>: majority of replicas decided on a different value after a value was accepted
</span></span><span style=display:flex><span>note: run with <span style=color:#e6db74>`</span>RUST_BACKTRACE<span style=color:#f92672>=</span>1<span style=color:#e6db74>`</span> environment variable to display a backtrace
</span></span><span style=display:flex><span>SEED<span style=color:#f92672>=</span><span style=color:#ae81ff>6948436056757512111</span>
</span></span></code></pre></div><p>Replay the bug by running the simulation with the seed to get the same sequence of inputs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>SEED<span style=color:#f92672>=</span><span style=color:#ae81ff>6948436056757512111</span> cargo t action_simulation -- --nocapture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> RECEIVED Prepare<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R1, P9<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> RECEIVED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R1, P12<span style=color:#f92672>)</span>, 12<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> RECEIVED PrepareResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R1, P12<span style=color:#f92672>)</span>, None, None<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>ORACLE<span style=color:#f92672>]</span> value accepted by majority of replicas: majority<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> RID<span style=color:#f92672>(</span>R1, P12<span style=color:#f92672>)</span> value<span style=color:#f92672>=</span>V<span style=color:#f92672>(</span>1, 44<span style=color:#f92672>)</span> replicas<span style=color:#f92672>=[</span>2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> RECEIVED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R1, P12<span style=color:#f92672>)</span>, 12<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> RECEIVED Accept<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R2, P12<span style=color:#f92672>)</span>, 12, V<span style=color:#f92672>(</span>2, 93<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> QUEUED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R2, P12<span style=color:#f92672>)</span>, 12<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> RECEIVED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R2, P12<span style=color:#f92672>)</span>, 12<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>ORACLE<span style=color:#f92672>]</span> value accepted by majority of replicas: majority<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> RID<span style=color:#f92672>(</span>R2, P12<span style=color:#f92672>)</span> value<span style=color:#f92672>=</span>V<span style=color:#f92672>(</span>2, 93<span style=color:#f92672>)</span> replicas<span style=color:#f92672>=[</span>3, 2<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>SEED<span style=color:#f92672>=</span><span style=color:#ae81ff>6948436056757512111</span>
</span></span></code></pre></div><p>The simulator will generate <code>1000</code> actions by default but it only needs to generate <code>2</code> actions to find this bug. The advantage of generating less actions is that the error trace will contain less events:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>MAX_ACTIONS<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> cargo t action_simulation -- --nocapture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> QUEUED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R2, P1<span style=color:#f92672>)</span>, 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> RECEIVED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R2, P1<span style=color:#f92672>)</span>, 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>ORACLE<span style=color:#f92672>]</span> value accepted by majority of replicas: majority<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> RID<span style=color:#f92672>(</span>R2, P1<span style=color:#f92672>)</span> value<span style=color:#f92672>=</span>V<span style=color:#f92672>(</span>2, 0<span style=color:#f92672>)</span> replicas<span style=color:#f92672>=[</span>2, 1<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> RECEIVED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R2, P1<span style=color:#f92672>)</span>, 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> RECEIVED Accept<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R1, P1<span style=color:#f92672>)</span>, 1, V<span style=color:#f92672>(</span>1, 1<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> QUEUED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R1, P1<span style=color:#f92672>)</span>, 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> RECEIVED PrepareResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R2, P1<span style=color:#f92672>)</span>, None, None<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> RECEIVED Accept<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R2, P1<span style=color:#f92672>)</span>, 1, V<span style=color:#f92672>(</span>2, 0<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> QUEUED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R2, P1<span style=color:#f92672>)</span>, 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> RECEIVED Accept<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R1, P1<span style=color:#f92672>)</span>, 1, V<span style=color:#f92672>(</span>1, 1<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> QUEUED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R1, P1<span style=color:#f92672>)</span>, 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> RECEIVED Accept<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R1, P1<span style=color:#f92672>)</span>, 1, V<span style=color:#f92672>(</span>1, 1<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> QUEUED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R1, P1<span style=color:#f92672>)</span>, 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> RECEIVED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R1, P1<span style=color:#f92672>)</span>, 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>ORACLE<span style=color:#f92672>]</span> value accepted by majority of replicas: majority<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> RID<span style=color:#f92672>(</span>R1, P1<span style=color:#f92672>)</span> value<span style=color:#f92672>=</span>V<span style=color:#f92672>(</span>1, 1<span style=color:#f92672>)</span> replicas<span style=color:#f92672>=[</span>3, 1<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>SEED<span style=color:#f92672>=</span><span style=color:#ae81ff>9075634049329737353</span>
</span></span></code></pre></div><blockquote><p>Always remove the current bug before introducing a new one.</p></blockquote><p>Let&rsquo;s have the replica reuse a proposal number:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Replica {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next_proposal_number</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Result<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Comment this line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// self.storage.store(&amp;state)?;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        Ok(self.state.min_proposal_number)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Run the simulation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo t action_simulation -- --nocapture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>assertion failed: <span style=color:#e6db74>`</span><span style=color:#f92672>(</span>left <span style=color:#f92672>==</span> right<span style=color:#f92672>)</span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>  left: <span style=color:#e6db74>`</span>Some<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;V(2, 14)&#34;</span><span style=color:#f92672>)</span><span style=color:#e6db74>`</span>,
</span></span><span style=display:flex><span> right: <span style=color:#e6db74>`</span>Some<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;V(2, 98)&#34;</span><span style=color:#f92672>)</span><span style=color:#e6db74>`</span>: majority of replicas decided on a different value after a value was accepted
</span></span><span style=display:flex><span>note: run with <span style=color:#e6db74>`</span>RUST_BACKTRACE<span style=color:#f92672>=</span>1<span style=color:#e6db74>`</span> environment variable to display a backtrace
</span></span><span style=display:flex><span>SEED<span style=color:#f92672>=</span><span style=color:#ae81ff>6875993431596082141</span>
</span></span></code></pre></div><p>The accepted proposal number and value must be persisted to durable storage. Let&rsquo;s forget to do that and see what happens.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Replica {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>on_accept</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, input: <span style=color:#a6e22e>AcceptInput</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> input.proposal_number <span style=color:#f92672>&gt;=</span> self.state.min_proposal_number {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> state <span style=color:#f92672>=</span> self.state.clone();
</span></span><span style=display:flex><span>            state.accepted_proposal_number <span style=color:#f92672>=</span> Some(input.proposal_number);
</span></span><span style=display:flex><span>            state.accepted_value <span style=color:#f92672>=</span> Some(input.value);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// self.storage.store(&amp;state).unwrap();
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            self.state <span style=color:#f92672>=</span> state;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self.bus.send_accept_response(
</span></span><span style=display:flex><span>                input.from_replica_id,
</span></span><span style=display:flex><span>                AcceptOutput {
</span></span><span style=display:flex><span>                    from_replica_id: <span style=color:#a6e22e>self</span>.config.id,
</span></span><span style=display:flex><span>                    request_id: <span style=color:#a6e22e>input</span>.request_id,
</span></span><span style=display:flex><span>                    min_proposal_number: <span style=color:#a6e22e>self</span>.state.min_proposal_number,
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Run the simulation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo t action_simulation -- --nocapture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>assertion <span style=color:#e6db74>`</span>left <span style=color:#f92672>==</span> right<span style=color:#e6db74>`</span> failed: majority of replicas decided on a different value after a value was accepted
</span></span><span style=display:flex><span>  left: Some<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;V(1, 17)&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> right: Some<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;V(2, 38)&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>SEED<span style=color:#f92672>=</span><span style=color:#ae81ff>6875993431596082141</span>
</span></span></code></pre></div><p>After sending a <code>Prepare(n)</code> message and receiving responses from a quorum, the value sent in <code>Accept(n, v)</code> messages must be the value accepted in the proposal with the highest proposal number. Let&rsquo;s forget to look for the accepted value and always send the value the proposer wants to.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Replica {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>on_prepare_response</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, input: <span style=color:#a6e22e>PrepareOutput</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> majority <span style=color:#f92672>=</span> self.majority();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> request_id <span style=color:#f92672>=</span> input.request_id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(req) <span style=color:#f92672>=</span> self.inflight_requests.get_mut(<span style=color:#f92672>&amp;</span>request_id) {
</span></span><span style=display:flex><span>            req.responses.insert(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> req.responses.len() <span style=color:#f92672>&lt;</span> majority {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// let value = req
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>//     .responses
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>//     .iter()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>//     .filter(|response| response.accepted_proposal_number.is_some())
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>//     .max_by_key(|response| response.accepted_proposal_number)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>//     .map(|response| response.accepted_value.clone().unwrap())
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>//     .unwrap_or_else(|| req.proposed_value.clone().unwrap());
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> req.proposed_value.clone().unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> proposal_number <span style=color:#f92672>=</span> req.proposal_number;
</span></span><span style=display:flex><span>            self.broadcast_accept(proposal_number, value);
</span></span><span style=display:flex><span>            self.inflight_requests.remove(<span style=color:#f92672>&amp;</span>request_id);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Run the simulation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo t action_simulation -- --nocapture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>assertion <span style=color:#e6db74>`</span>left <span style=color:#f92672>==</span> right<span style=color:#e6db74>`</span> failed: majority of replicas decided on a different value after a value was accepted
</span></span><span style=display:flex><span>  left: Some<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;V(1, 99)&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> right: Some<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;V(1, 40)&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> RECEIVED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R1, P10<span style=color:#f92672>)</span>, 10<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>ORACLE<span style=color:#f92672>]</span> value accepted by majority of replicas: majority<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> RID<span style=color:#f92672>(</span>R1, P10<span style=color:#f92672>)</span> value<span style=color:#f92672>=</span>V<span style=color:#f92672>(</span>1, 40<span style=color:#f92672>)</span> replicas<span style=color:#f92672>=[</span>1, 2<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>SEED<span style=color:#f92672>=</span><span style=color:#ae81ff>6369495520157998847</span>
</span></span></code></pre></div><p>Even better, let&rsquo;s forget to fsync the file that contains the replica state:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> FileStorage {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>store</span>(<span style=color:#f92672>&amp;</span>self, state: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>contracts</span>::DurableState) -&gt; <span style=color:#a6e22e>std</span>::io::Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Comment this line.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// file.sync_all()?;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        Ok(())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Run the simulation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo t action_simulation -- --nocapture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>assertion failed: <span style=color:#e6db74>`</span><span style=color:#f92672>(</span>left <span style=color:#f92672>==</span> right<span style=color:#f92672>)</span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>  left: <span style=color:#e6db74>`</span>Some<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;V(1, 0)&#34;</span><span style=color:#f92672>)</span><span style=color:#e6db74>`</span>,
</span></span><span style=display:flex><span> right: <span style=color:#e6db74>`</span>Some<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;V(1, 58)&#34;</span><span style=color:#f92672>)</span><span style=color:#e6db74>`</span>: majority of replicas decided on a different value after a value was accepted
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> QUEUED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R1, P5<span style=color:#f92672>)</span>, 5<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>BUS<span style=color:#f92672>]</span> Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> -&gt; Replica<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> RECEIVED AcceptResponse<span style=color:#f92672>(</span>RID<span style=color:#f92672>(</span>R1, P5<span style=color:#f92672>)</span>, 5<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>ORACLE<span style=color:#f92672>]</span> value accepted by majority of replicas: majority<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> RID<span style=color:#f92672>(</span>R1, P5<span style=color:#f92672>)</span> value<span style=color:#f92672>=</span>V<span style=color:#f92672>(</span>3, 59<span style=color:#f92672>)</span> replicas<span style=color:#f92672>=[</span>1, 2<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>SEED<span style=color:#f92672>=</span><span style=color:#ae81ff>7923659261799353388</span>
</span></span></code></pre></div><p>Atomically writing to a file is complicated, let&rsquo;s forget to fsync the directory since the atomic rename trick is being used:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> FileStorage {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>store</span>(<span style=color:#f92672>&amp;</span>self, state: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>contracts</span>::DurableState) -&gt; <span style=color:#a6e22e>std</span>::io::Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Comment this line.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// self.dir_file.sync_all()?;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        Ok(())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Run the simulation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo t action_simulation -- --nocapture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>assertion failed: <span style=color:#e6db74>`</span><span style=color:#f92672>(</span>left <span style=color:#f92672>==</span> right<span style=color:#f92672>)</span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>  left: <span style=color:#e6db74>`</span>Some<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;V(1, 2)&#34;</span><span style=color:#f92672>)</span><span style=color:#e6db74>`</span>,
</span></span><span style=display:flex><span> right: <span style=color:#e6db74>`</span>Some<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;V(3, 27)&#34;</span><span style=color:#f92672>)</span><span style=color:#e6db74>`</span>: majority of replicas decided on a different value after a value was accepted
</span></span><span style=display:flex><span>note: run with <span style=color:#e6db74>`</span>RUST_BACKTRACE<span style=color:#f92672>=</span>1<span style=color:#e6db74>`</span> environment variable to display a backtrace
</span></span><span style=display:flex><span>SEED<span style=color:#f92672>=</span><span style=color:#ae81ff>11856967350924232882</span>
</span></span></code></pre></div><p>Without introducing any bugs, let&rsquo;s run the simulator and see what happens:</p><p>Run the simulation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo t action_simulation -- --nocapture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Spawning <span style=color:#ae81ff>4</span> threads
</span></span><span style=display:flex><span>SEED<span style=color:#f92672>=</span><span style=color:#ae81ff>3616773477915676583</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>0<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>SEED<span style=color:#f92672>=</span><span style=color:#ae81ff>10055364015445278185</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>SEED<span style=color:#f92672>=</span><span style=color:#ae81ff>17460562123704731307</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>SEED<span style=color:#f92672>=</span><span style=color:#ae81ff>6671866141078837726</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>0<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>2000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>0<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>2000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>2000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>2000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>0<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>3000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>3000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>3000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>0<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>4000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>3000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>4000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>4000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>0<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>5000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>5000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>4000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>5000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>5000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>0<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>6000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>6000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>6000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>6000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>7000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>7000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>0<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>7000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>8000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>7000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>8000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>0<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>8000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>9000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>8000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>9000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>0<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>9000</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span> Running simulation <span style=color:#ae81ff>9000</span>
</span></span><span style=display:flex><span>test simulation::simulator::tests::action_simulation ... ok
</span></span></code></pre></div><p>The code for the Paxos implementation and the simulator can be found <a href=https://github.com/PoorlyDefinedBehaviour/single_decree_paxos_deterministic_simulation>here</a>.</p><h3 id=note-on-p>Note on P<a hidden class=anchor aria-hidden=true href=#note-on-p>#</a></h3><p><a href=https://p-org.github.io/P/>P</a> is a state machine programming language for modeling and specifying distributed systems. P is used for modeling while the simulator is used to test the real system, using the real components whenever possible. The overall structure of the system is pretty similar to the structure of a P program.</p><p>The implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>type</span> <span style=color:#a6e22e>request_id</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>node_id</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>request_number</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>type</span> <span style=color:#a6e22e>prepareReq</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>node</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>request_id</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>request_id</span>, <span style=color:#a6e22e>proposal_number</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>type</span> <span style=color:#a6e22e>prepareResp</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>node</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>request_id</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>request_id</span>, <span style=color:#a6e22e>node_id</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>proposal_number</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>accepted_proposal_number</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>accepted_value</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>type</span> <span style=color:#a6e22e>acceptReq</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>node</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>request_id</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>request_id</span>, <span style=color:#a6e22e>node_id</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>proposal_number</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>type</span> <span style=color:#a6e22e>acceptResp</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>request_id</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>request_id</span>, <span style=color:#a6e22e>node_id</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>min_proposal_number</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>type</span> <span style=color:#a6e22e>valueAcceptedReq</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>node_id</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>type</span> <span style=color:#a6e22e>setNodesReq</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>m</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>machine</span>, <span style=color:#a6e22e>nodes</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>seq</span>[<span style=color:#a6e22e>Node</span>]);
</span></span><span style=display:flex><span><span style=color:#a6e22e>event</span> <span style=color:#a6e22e>eSetNodes</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>setNodesReq</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>event</span> <span style=color:#a6e22e>eSetNodesResponse</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>event</span> <span style=color:#a6e22e>eTriggerPrepare</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>event</span> <span style=color:#a6e22e>ePrepare</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>prepareReq</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>event</span> <span style=color:#a6e22e>ePrepareResp</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>prepareResp</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>event</span> <span style=color:#a6e22e>eAccept</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>acceptReq</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>event</span> <span style=color:#a6e22e>eAcceptResp</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>acceptResp</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>event</span> <span style=color:#a6e22e>eValueAccepted</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>valueAcceptedReq</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>event</span> <span style=color:#a6e22e>eRestart</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>event</span> <span style=color:#a6e22e>eCrash</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>MessageType</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>PREPARE</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ACCEPT</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>machine</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>start</span> <span style=color:#a6e22e>state</span> <span style=color:#a6e22e>Init</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>entry</span> (<span style=color:#a6e22e>node_id</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>      ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>state</span> <span style=color:#a6e22e>Crashed</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>on</span> <span style=color:#a6e22e>eRestart</span> <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>Restarting</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ignore</span> <span style=color:#a6e22e>eCrash</span>, <span style=color:#a6e22e>eTriggerPrepare</span>, <span style=color:#a6e22e>ePrepare</span>, <span style=color:#a6e22e>ePrepareResp</span>, <span style=color:#a6e22e>eAccept</span>, <span style=color:#a6e22e>eAcceptResp</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>state</span> <span style=color:#a6e22e>Restarting</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>entry</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>requests</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>(<span style=color:#a6e22e>map</span>[(<span style=color:#a6e22e>MessageType</span>, <span style=color:#66d9ef>int</span>), (<span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>responses</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>set</span>[(<span style=color:#a6e22e>node_id</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>accepted_proposal_number</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>accepted_value</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>)])]);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>HandleRequests</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>state</span> <span style=color:#a6e22e>HandleRequests</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ignore</span> <span style=color:#a6e22e>eRestart</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>on</span> <span style=color:#a6e22e>eCrash</span> <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>Crashed</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>on</span> <span style=color:#a6e22e>eTriggerPrepare</span> <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>      ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>on</span> <span style=color:#a6e22e>ePrepare</span> <span style=color:#66d9ef>do</span> (<span style=color:#a6e22e>req</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>prepareReq</span>) {
</span></span><span style=display:flex><span>      ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>on</span> <span style=color:#a6e22e>ePrepareResp</span> <span style=color:#66d9ef>do</span> (<span style=color:#a6e22e>req</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>prepareResp</span>) {
</span></span><span style=display:flex><span>      ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>on</span> <span style=color:#a6e22e>eAccept</span> <span style=color:#66d9ef>do</span> (<span style=color:#a6e22e>req</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>acceptReq</span>) {
</span></span><span style=display:flex><span>      ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>on</span> <span style=color:#a6e22e>eAcceptResp</span> <span style=color:#66d9ef>do</span> (<span style=color:#a6e22e>req</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>acceptResp</span>) {
</span></span><span style=display:flex><span>      ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fun</span> <span style=color:#a6e22e>quorum</span>(<span style=color:#a6e22e>num_nodes</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>num_nodes</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The spec:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>event</span> <span style=color:#a6e22e>spec_EventuallyDecideOnSameValue_num_nodes</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>spec</span> <span style=color:#a6e22e>EventuallyDecideOnSameValue</span> <span style=color:#a6e22e>observes</span> <span style=color:#a6e22e>spec_EventuallyDecideOnSameValue_num_nodes</span>, <span style=color:#a6e22e>eValueAccepted</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Node id -&gt; value the node accepted. Node ids for nodes that haven&#39;t accepted a value aren&#39;t in the map.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>accepted_values</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>map</span>[<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>];
</span></span><span style=display:flex><span>  <span style=color:#75715e>// The value accepted by a majority of nodes. 0 means unset.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>accepted_value</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// The minimum number of nodes that form a majority in the cluster.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>majority</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>start</span> <span style=color:#a6e22e>state</span> <span style=color:#a6e22e>Init</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>on</span> <span style=color:#a6e22e>spec_EventuallyDecideOnSameValue_num_nodes</span> <span style=color:#66d9ef>do</span> (<span style=color:#a6e22e>num_nodes</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>majority</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>num_nodes</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>WaitingForDecision</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Nodes must eventually decide.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>hot</span> <span style=color:#a6e22e>state</span> <span style=color:#a6e22e>WaitingForDecision</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>on</span> <span style=color:#a6e22e>eValueAccepted</span> <span style=color:#66d9ef>do</span> (<span style=color:#a6e22e>req</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>valueAcceptedReq</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>accepted_values</span>[<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>node_id</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>accepted_value</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getValueAcceptedByMajority</span>();
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>print</span> <span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;debug: WaitingForDecision accepted_values={0}&#34;</span>, <span style=color:#a6e22e>accepted_values</span>);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// No value accepted yet.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>accepted_value</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>EnsuringDecisionDoesntChange</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// After a majority of the nodes decide on a value, the value cannot change.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>state</span> <span style=color:#a6e22e>EnsuringDecisionDoesntChange</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>on</span> <span style=color:#a6e22e>eValueAccepted</span> <span style=color:#66d9ef>do</span> (<span style=color:#a6e22e>req</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>valueAcceptedReq</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>accepted_values</span>[<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>node_id</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getValueAcceptedByMajority</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>assert</span> <span style=color:#a6e22e>accepted_value</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;nodes decided on a new value after a value has already been decided. old={0} new={1}&#34;</span>, <span style=color:#a6e22e>accepted_value</span>, <span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The P implementation includes a failure injector as well. The code can be found <a href=https://github.com/PoorlyDefinedBehaviour/formal-methods/tree/main/single_decree_paxos_p_lang>here</a>.</p><h3 id=cant-catch-them-all>Can&rsquo;t catch them all<a hidden class=anchor aria-hidden=true href=#cant-catch-them-all>#</a></h3><p>It&rsquo;s obvious that some bugs won&rsquo;t be found because the inputs are generated randomly and some components will end up being replaced by fake implementations to remove non-determinism or to make the simulation run at an acceptable speed. Combine dst with other testing and modeling techniques for maximum effectiveness.</p><h3 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h3><p><a href=https://lamport.azurewebsites.net/pubs/paxos-simple.pdf>Paxos made simple</a><br><a href=https://p-org.github.io/P/>P</a><br><a href=https://github.com/tigerbeetle/tigerbeetle>Tigerbeetle</a><br><a href="https://www.youtube.com/watch?v=4fFDFbi3toc">&ldquo;Testing Distributed Systems w/ Deterministic Simulation&rdquo; by Will Wilson</a><br><a href=https://www.youtube.com/live/29Vz5wkoUR8>FF meetup #4 - Deterministic simulation testing</a><br><a href=https://notes.eatonphil.com/2024-08-20-deterministic-simulation-testing.html>What&rsquo;s the big deal about Deterministic Simulation Testing?</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://poorlydefinedbehaviour.github.io/posts/the_deadlock_empire/><span class=title>Next »</span><br><span>Model checking The Deadlock Empire</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤 on x" href="https://x.com/intent/tweet/?text=%f0%9d%94%87%f0%9d%94%a2%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%af%f0%9d%94%aa%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a6%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%a0%20%f0%9d%94%b0%f0%9d%94%a6%f0%9d%94%aa%f0%9d%94%b2%f0%9d%94%a9%f0%9d%94%9e%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ac%f0%9d%94%ab%20%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a4&amp;url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fdeterministic_simulation_testing%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fdeterministic_simulation_testing%2f&amp;title=%f0%9d%94%87%f0%9d%94%a2%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%af%f0%9d%94%aa%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a6%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%a0%20%f0%9d%94%b0%f0%9d%94%a6%f0%9d%94%aa%f0%9d%94%b2%f0%9d%94%a9%f0%9d%94%9e%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ac%f0%9d%94%ab%20%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a4&amp;summary=%f0%9d%94%87%f0%9d%94%a2%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%af%f0%9d%94%aa%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a6%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%a0%20%f0%9d%94%b0%f0%9d%94%a6%f0%9d%94%aa%f0%9d%94%b2%f0%9d%94%a9%f0%9d%94%9e%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ac%f0%9d%94%ab%20%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a4&amp;source=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fdeterministic_simulation_testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fdeterministic_simulation_testing%2f&title=%f0%9d%94%87%f0%9d%94%a2%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%af%f0%9d%94%aa%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a6%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%a0%20%f0%9d%94%b0%f0%9d%94%a6%f0%9d%94%aa%f0%9d%94%b2%f0%9d%94%a9%f0%9d%94%9e%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ac%f0%9d%94%ab%20%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a4"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fdeterministic_simulation_testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤 on whatsapp" href="https://api.whatsapp.com/send?text=%f0%9d%94%87%f0%9d%94%a2%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%af%f0%9d%94%aa%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a6%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%a0%20%f0%9d%94%b0%f0%9d%94%a6%f0%9d%94%aa%f0%9d%94%b2%f0%9d%94%a9%f0%9d%94%9e%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ac%f0%9d%94%ab%20%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a4%20-%20https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fdeterministic_simulation_testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤 on telegram" href="https://telegram.me/share/url?text=%f0%9d%94%87%f0%9d%94%a2%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%af%f0%9d%94%aa%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a6%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%a0%20%f0%9d%94%b0%f0%9d%94%a6%f0%9d%94%aa%f0%9d%94%b2%f0%9d%94%a9%f0%9d%94%9e%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ac%f0%9d%94%ab%20%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a4&amp;url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fdeterministic_simulation_testing%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 𝔇𝔢𝔱𝔢𝔯𝔪𝔦𝔫𝔦𝔰𝔱𝔦𝔠 𝔰𝔦𝔪𝔲𝔩𝔞𝔱𝔦𝔬𝔫 𝔱𝔢𝔰𝔱𝔦𝔫𝔤 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%f0%9d%94%87%f0%9d%94%a2%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%af%f0%9d%94%aa%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a6%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%a0%20%f0%9d%94%b0%f0%9d%94%a6%f0%9d%94%aa%f0%9d%94%b2%f0%9d%94%a9%f0%9d%94%9e%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ac%f0%9d%94%ab%20%f0%9d%94%b1%f0%9d%94%a2%f0%9d%94%b0%f0%9d%94%b1%f0%9d%94%a6%f0%9d%94%ab%f0%9d%94%a4&u=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fdeterministic_simulation_testing%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://poorlydefinedbehaviour.github.io/></a></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>