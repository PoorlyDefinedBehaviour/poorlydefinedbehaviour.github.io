<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Model checking The Deadlock Empire | </title><meta name=keywords content><meta name=description content="
This post contains TLA+ solutions for The Deadlock Empire which is a collection of challenges where the objective is to break multithreaded programs by playing the role of a scheduler that can context switch at any time.
Non atomic instructions
There&rsquo;s two threads executing the following code:
a = a + 1;
if (a == 1) {
  critical_section();
}
Since the a increment is not atomic, conceptually, it is like setting a temporary variable to the value of a&ndash; tmp = a and then setting a to the temporary variable value incremented by 1 &ndash; a = tmp + 1."><meta name=author content="poorlydefinedbehaviour"><link rel=canonical href=https://poorlydefinedbehaviour.github.io/posts/the_deadlock_empire/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://poorlydefinedbehaviour.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://poorlydefinedbehaviour.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://poorlydefinedbehaviour.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://poorlydefinedbehaviour.github.io/apple-touch-icon.png><link rel=mask-icon href=https://poorlydefinedbehaviour.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://poorlydefinedbehaviour.github.io/posts/the_deadlock_empire/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Model checking The Deadlock Empire"><meta property="og:description" content="
This post contains TLA+ solutions for The Deadlock Empire which is a collection of challenges where the objective is to break multithreaded programs by playing the role of a scheduler that can context switch at any time.
Non atomic instructions
There&rsquo;s two threads executing the following code:
a = a + 1;
if (a == 1) {
  critical_section();
}
Since the a increment is not atomic, conceptually, it is like setting a temporary variable to the value of a&ndash; tmp = a and then setting a to the temporary variable value incremented by 1 &ndash; a = tmp + 1."><meta property="og:type" content="article"><meta property="og:url" content="https://poorlydefinedbehaviour.github.io/posts/the_deadlock_empire/"><meta property="og:image" content="https://poorlydefinedbehaviour.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-15T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-15T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://poorlydefinedbehaviour.github.io/papermod-cover.png"><meta name=twitter:title content="Model checking The Deadlock Empire"><meta name=twitter:description content="
This post contains TLA+ solutions for The Deadlock Empire which is a collection of challenges where the objective is to break multithreaded programs by playing the role of a scheduler that can context switch at any time.
Non atomic instructions
There&rsquo;s two threads executing the following code:
a = a + 1;
if (a == 1) {
  critical_section();
}
Since the a increment is not atomic, conceptually, it is like setting a temporary variable to the value of a&ndash; tmp = a and then setting a to the temporary variable value incremented by 1 &ndash; a = tmp + 1."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://poorlydefinedbehaviour.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Model checking The Deadlock Empire","item":"https://poorlydefinedbehaviour.github.io/posts/the_deadlock_empire/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Model checking The Deadlock Empire","name":"Model checking The Deadlock Empire","description":"\nThis post contains TLA+ solutions for The Deadlock Empire which is a collection of challenges where the objective is to break multithreaded programs by playing the role of a scheduler that can context switch at any time.\nNon atomic instructions\nThere\u0026rsquo;s two threads executing the following code:\na = a + 1; if (a == 1) { critical_section(); } Since the a increment is not atomic, conceptually, it is like setting a temporary variable to the value of a\u0026ndash; tmp = a and then setting a to the temporary variable value incremented by 1 \u0026ndash; a = tmp + 1.\n","keywords":[],"articleBody":"\nThis post contains TLA+ solutions for The Deadlock Empire which is a collection of challenges where the objective is to break multithreaded programs by playing the role of a scheduler that can context switch at any time.\nNon atomic instructions\nThere’s two threads executing the following code:\na = a + 1; if (a == 1) { critical_section(); } Since the a increment is not atomic, conceptually, it is like setting a temporary variable to the value of a– tmp = a and then setting a to the temporary variable value incremented by 1 – a = tmp + 1.\n---- MODULE spec ---- EXTENDS TLC, Integers, FiniteSets (*--algorithm spec variables a = 0, threads = 1..2, Enterd_critical_section = {}; define OnlyOneThreadEntersCriticalSection == Cardinality(Enterd_critical_section) \u003c= 1 end define; process Thread \\in threads variables tmp = 0; begin Load: tmp := a; Store: a := tmp + 1; CriticalSectionCheck: if a = 1 then Enterd_critical_section := Enterd_critical_section \\union {self}; end if; end process; end algorithm; *) ==== State Thread a Thread b Description a = 0 Init Init Both threads are at the initial state a = 0, thread1.tmp = 0 Load Init Thread a stores the value of a in a temporary variable a = 0, thread1.tmp = 0, thread2.tmp = 0 Load Load Thread b stores the value of a in a temporary variable a = thread1.tmp + 1, thread1.tmp = 0, thread2.tmp = 0 Store Load Thread a sets a to 0 + 1 using the temporary variable a = thread2.tmp + 1, thread1.tmp = 0, thread2.tmp = 0 Store Store Thread b sets a to 0 + 1 using the temporary variable a = 1 CriticalSectionCheck Store Thread a enters the critical section since a is equal to 1 a = 1 CriticalSectionCheck CriticalSectionCheck Thread b enters the critical section since a is equal to 1 at the same time as thread 1 Boolean Flags Are Enough For Everyone\nflag = false while (true) { while (flag != false) { ; } flag = true; critical_section(); flag = false; } ---- MODULE spec ---- EXTENDS TLC, Integers, FiniteSets (*--algorithm spec variables threads = 1..2, flag = FALSE, threads_in_criticial_section = {}; define OnlyOneThreadEntersCriticalSection == Cardinality(threads_in_criticial_section) \u003c= 1 end define; process Thread \\in threads begin SpinLock: while flag do skip; end while; SetFlag: flag := TRUE; CriticalSection1: threads_in_criticial_section := threads_in_criticial_section \\union {self}; CriticalSection2: threads_in_criticial_section := threads_in_criticial_section \\ {self}; UnsetFlag: flag := FALSE; end process; end algorithm; *) ==== State Thread a Thread b Description flag = false Init Init Both threads are at the initial state flag = false SpinLock Init Thread a enters the spinlock flag = false SpinLock SpinLock Thread b enters the spinlock flag = true SpinLock SetFlag Thread b sees that flag is false so it leaves the spinlock and sets flag to true flag = true SetFlag SetFlag Thread a was in the spinlock and read the value of flag before thread 2 set it to true. Thread a leaves the spinlock and sets flag to true flag = true CriticalSection1 CriticalSection1 Both threads enter the critical section at the same time Simple counter\nwhile (true) { counter++; if (counter == 5) { critical_section(); } } ---- MODULE spec ---- EXTENDS TLC, Integers, FiniteSets (*--algorithm spec variables threads = {3, 5}, threads_in_critical_section = {}, counter = 0; define MutualExclusion == Cardinality(threads_in_critical_section) \u003c= 1 end define; process Thread \\in threads variables tmp = 0, done = FALSE; begin Loop: while ~done do Load: tmp := counter; Store: counter := tmp + 1; EnterCriticalSection: if counter = self then threads_in_critical_section := threads_in_critical_section \\union {self}; done := TRUE; end if; LeaveCriticalSection: threads_in_critical_section := threads_in_critical_section \\ {self}; end while; end process; end algorithm; *) ==== State Thread a Thread b Description counter = 0 Loop Loop Thread a updates the counter until it reaches 3 while thread 2 is in the Loop state counter = 0 Load Loop counter = 1 Store Loop counter = 1 Loop Loop counter = 1 Load Loop counter = 2 Store Loop counter = 2 Loop Loop counter = 2 Load Loop counter = 3 Store Loop counter = 3 EnterCriticalSection Loop Counter reached 3, so thread 1 enters the critical section counter = 3 LeaveCriticalSection Loop While thread 1 is in the critical section, thread 2 updates the counter to 5 counter = 3 LeaveCriticalSection Load counter = 4 LeaveCriticalSection Store counter = 4 LeaveCriticalSection Loop counter = 4 LeaveCriticalSection Load counter = 5 LeaveCriticalSection Store counter = 5 LeaveCriticalSection EnterCriticalSection And thread 2 enters the critical section while thread 1 is still there Thread a is in the LeaveCriticalSection state but it has not executed the step yet.\nConfused counter\n// Thread a business_logic(); first++; second++; if (second == 2 \u0026\u0026 first != 2) { Debug.Assert(false); } // Thread b business_logic(); first++; second++; ---- MODULE spec ---- EXTENDS TLC, Integers (*--algorithm spec variables first = 0, second = 0, assertion_failed = FALSE; define AssertionNeverFails == assertion_failed = FALSE end define; process ThreadA = \"a\" variables tmp = 0; begin LoadFirst: tmp := first; StoreFirst: first := tmp + 1; LoadSecond: tmp := second; StoreSecond: second := tmp + 1; CriticalSection: if second = 2 /\\ first # 2 then assertion_failed := TRUE; end if; end process; process ThreadB = \"b\" variables tmp = 0; begin LoadFirst: tmp := first; StoreFirst: first := tmp + 1; LoadSecond: tmp := second; StoreSecond: second := tmp + 1; end process; end algorithm; *) ==== State Thread a Thread b Description first = 0, second = 0 LoadFirst LoadFirst Both threads load first into thread1.tmp first = 0, second = 0, thread1.tmp = 0, thread2.tmp = 0 StoreFirst StoreFirst Thread a updates first by setting it to thread1.tmp + 1 first = 1, second = 0, thread1.tmp = 0, thread2.tmp = 0 LoadSecond StoreFirst Thread a loads second into thread1.tmp. Note that Thread b is still in the StoreFirst state since it has not executed yet first = 1, second = 0, thread1.tmp = 0, thread2.tmp = 0 StoreSecond StoreFirst Thread a updates second by setting it to thread1.tmp + 1 first = 1, second = 1, thread1.tmp = 0, thread2.tmp = 0 CriticalSection StoreFirst Thread a moves to the CriticalSection state but does not execute yet first = 1, second = 1, thread1.tmp = 0, thread2.tmp = 0 CriticalSection StoreFirst Thread 2 updates first by setting it to thread2.tmp + 1. Note that thread2.tmp is still 0 since the variable was set in a previous state before Thread b got paused first = 1, second = 1, thread1.tmp = 0, thread2.tmp = 0 CriticalSection LoadSecond Thread b loads second into thread2.tmp first = 1, second = 1, thread1.tmp = 0, thread2.tmp = 1 CriticalSection StoreSecond Thread b updates second by setting it to thread2.tmp + 1. Note that thread2.tmp is 1 first = 1, second = 1, thread1.tmp = 0, thread2.tmp = 1 CriticalSection Done Thread a resumes executions and the condition in the if the statement succeeds Insuffient lock\nTwo threads use a mutex to protect i. The mutex works as expected, the problem is that exists an execution order where thread 1 hits the assertion.\n// Thread a while (true) { Monitor.Enter(mutex); i = i + 2; critical_section(); if (i == 5) { Debug.Assert(false); } Monitor.Exit(mutex); } // Thread b while (true) { Monitor.Enter(mutex); i = i - 1; critical_section(); Monitor.Exit(mutex); } ---- MODULE spec ---- EXTENDS TLC, Integers (*--algorithm spec variables lock = FALSE, assertion_failed = FALSE, i = 0; define AssertionNeverFails == assertion_failed = FALSE end define; process ThreadA = \"a\" begin Loop: while TRUE do AcquireLock: await lock = FALSE; lock := TRUE; Modify: i := i + 2; If: if i = 5 then assertion_failed := TRUE; end if; ReleaseLock: lock := FALSE; end while; end process; process ThreadB = \"b\" begin Loop: while TRUE do AcquireLock: await lock = FALSE; lock := TRUE; Modify: i := i - 1; ReleaseLock: lock := FALSE; end while; end process; end algorithm; *) ==== State Thread a Thread b Description i = 0 Loop Loop Threads start i = 0 AcquireLock AcquireLock Thread a acquires the lock repeatedly until i reaches 4. Thread b is stuck trying to acquire the lock i = 0 Modify AcquireLock i = 2 If AcquireLock i = 2 ReleaseLock AcquireLock i = 2 AcquireLock AcquireLock i = 2 Modify AcquireLock i = 2 If AcquireLock i = 4 ReleaseLock AcquireLock i = 4 ReleaseLock Modify Thread b finally acquires the lock i = 3 ReleaseLock If i = 3 ReleaseLock ReleaseLock i = 3 AcquireLock AcquireLock i = 3 Modify AcquireLock Thread a acquires the lock again i = 5 If AcquireLock Thread i is equal to 5 this time, thread 1 hits the assertion Deadlock\nNote that the order in which each thread tries to acquire the locks is different.\n// Thread a Monitor.Enter(mutex); Monitor.Enter(mutex2); critical_section(); Monitor.Exit(mutex); Monitor.Exit(mutex2); // Thread b Monitor.Enter(mutex2); Monitor.Enter(mutex); critical_section(); Monitor.Exit(mutex2); Monitor.Exit(mutex); ---- MODULE spec ---- EXTENDS TLC (*--algorithm spec variables mutex1 = FALSE, mutex2 = FALSE; process ThreadA = \"a\" begin AcquireLock1: await mutex1 = FALSE; mutex1 := TRUE; AcquireLock2: await mutex2 = FALSE; mutex2 := TRUE; ReleaseLocks: mutex1 := FALSE; mutex2 := FALSE; end process; process ThreadB = \"b\" begin AcquireLock1: await mutex2 = FALSE; mutex2 := TRUE; AcquireLock2: await mutex1 = FALSE; mutex1 := TRUE; ReleaseLocks: mutex2 := FALSE; mutex1 := FALSE; end process; end algorithm; *) ==== State Thread a Thread b Description mutex1 = FALSE, mutex2 = FALSE AcquireLock1 AcquireLock1 Both threads start acquiring the locks mutex1 = TRUE, mutex2 = FALSE AcquireLock2 AcquireLock1 Thread a acquires the first lock and tries to acquire the second mutex1 = TRUE, mutex2 = TRUE AcquireLock2 AcquireLock2 Thread b acquires the second lock before thread 1 is able to acquire it mutex1 = TRUE, mutex2 = TRUE Deadlock Deadlock No thread can progress because one thread holds the lock the other thread needs A More Complex Thread\n// Thread a while (true) { if (Monitor.TryEnter(mutex)) { Monitor.Enter(mutex3); Monitor.Enter(mutex); critical_section(); Monitor.Exit(mutex); Monitor.Enter(mutex2); flag = false; Monitor.Exit(mutex2); Monitor.Exit(mutex3); } else { Monitor.Enter(mutex2); flag = true; Monitor.Exit(mutex2); } } // Thread b while (true) { if (flag) { Monitor.Enter(mutex2); Monitor.Enter(mutex); flag = false; critical_section(); Monitor.Exit(mutex); Monitor.Enter(mutex2); } else { Monitor.Enter(mutex); flag = false; Monitor.Exit(mutex); } } ---- MODULE spec ---- EXTENDS TLC, Sequences, FiniteSets, Integers NULL == \u003c\u003c\"-1\", -1\u003e\u003e (*--algorithm spec variables mutex = NULL, mutex2 = NULL, mutex3 = NULL, flag = FALSE; macro enter(mutex, thread) begin await mutex = NULL \\/ mutex[1] = thread; if mutex = NULL then mutex := \u003c\u003e; else mutex := \u003c\u003e; end if; end macro; macro exit(mutex, thread) begin assert mutex[1] = thread; assert mutex[2] \u003e 0; if mutex[2] = 1 then mutex := NULL; else mutex := \u003c\u003e; end if; end macro; macro try_enter(mutex, thread) begin if mutex = NULL then mutex := \u003c\u003e; try_enter_result := TRUE; elsif mutex[1] = thread then mutex := \u003c\u003e; try_enter_result := TRUE; else try_enter_result := FALSE; end if; end macro; process thread_a = \"a\" variables try_enter_result = FALSE; begin Loop: while TRUE do TryEnterMutex: try_enter(mutex, \"a\"); CheckEnterMutex: if try_enter_result then EnterMutex3: enter(mutex3, \"a\"); EnterMutex: enter(mutex, \"a\"); ExitMutex: exit(mutex, \"a\"); EnterMutex2: enter(mutex2, \"a\"); else Else_EnterMutex2: enter(mutex2, \"a\"); SetFlag: flag := TRUE; ExitMutex2: exit(mutex2, \"a\"); end if; end while; end process; process thread_b = \"b\" begin Loop: while TRUE do CheckFlag: if flag then EnterMutex2:enter(mutex2, \"b\"); EnterMutex: enter(mutex, \"b\"); SetFlag:flag := FALSE; ExitMutex: exit(mutex, \"b\"); ExitMutex2: enter(mutex2, \"b\"); else Else_EnterMutex: enter(mutex, \"b\"); Else_SetFlag: flag := FALSE; Else_ExitMutex: exit(mutex, \"b\"); end if; end while; end process; end algorithm; *) ==== Variables that didn’t change on transition to a new state were omitted.\nState Thread a Thread b Description flag = false, mutex = NULL, mutex2 = NULL, mutex3 = NULL Loop Loop Both threads start running … TryEnterMutex Loop Thread a moves to the TryEnterMutex state but has not executed yet … TryEnterMutex CheckFlag Thread b moves to the CheckFlag state … TryEnterMutex Else_EnterMutex Thread b checks that flag is FALSE and moves to the else branch flag = false, mutex = «“b”, 1», mutex2 = NULL, mutex3 = NULL TryEnterMutex Else_SetFlag After acquiring mutex, thread b sets flag to FALSE … CheckEnterMutex Else_SetFlag Thread a resumes execution and checks if flag is TRUE flag = false, mutex = «“b”, 1», mutex2 = «“a”, 1», mutex3 = NULL Else_EnterMutex2 Else_SetFlag Thread a finds out that flag is FALSE and moves to the else branch … SetFlag Else_SetFlag Thread a will set flag to TRUE … SetFlag Else_ExitMutex Thread b resumes execution and releases mutex before thread a sets flag to TRUE flag = true, mutex = «“b”, 1», mutex2 = NULL, mutex3 = NULL ExitMutex2 Else_ExitMutex Thread a sets flag to TRUE flag = true, mutex = NULL, mutex2 = NULL, mutex3 = NULL Loop Else_ExitMutex Thread a releases mutex2 … TryEnterMutex Else_ExitMutex Thread a tries to acquire mutex … TryEnterMutex Loop Thread b resumes execution … CheckEnterMutex Loop Thread a checks if mutex has been acquired flag = true, mutex = «“a”, 1», mutex2 = NULL, mutex3 = «“a”, 1» EnterMutex3 Loop mutex3 was already acquired by thread a flag = true, mutex = «“a”, 2», mutex2 = NULL, mutex3 = «“a”, 1» EnterMutex Loop Thread a acquires mutex again flag = true, mutex = «“a”, 1», mutex2 = NULL, mutex3 = «“a”, 1» ExitMutex Loop Thread a releases mutex … EnterMutex2 Loop Thread a will try to acquire mutex2 … EnterMutex2 CheckFlag Thread b resumes execution and checks if flag is TRUE flag = true, mutex = «“a”, 1», mutex2 = «“b”, 1», mutex3 = «“a”, 1» EnterMutex2 EnterMutex2 flag is TRUE, so thread b triers to acquire mutex2 flag = true, mutex = «“a”, 1», mutex2 = «“b”, 1», mutex3 = «“a”, 1» EnterMutex2 EnterMutex Thread b acquires mutex2 and tries to acquire mutex while thread a tries to acquire `mutex2. … Deadlock Deadlock Manual Reset Event\n// Thread a while (true) { sync.Wait(); if (counter % 2 == 1) { Debug.Assert(false); } } // Thread b while (true) { sync.Reset(); counter++; counter++; sync.Set(); } ---- MODULE spec ---- EXTENDS TLC, Integers (*--algorithm spec variables signal = FALSE, counter = 0; process a = \"a\" variables tmp = 0; begin Loop: while TRUE do WaitSignal: await signal; LoadCounter: tmp := counter; CheckCounter: if tmp % 2 = 1 then assert FALSE; end if; end while; end process; process b = \"b\" variables tmp = 0; begin Loop: while TRUE do ResetSignal: signal := FALSE; LoadCounter1: tmp := counter; IncCounter1: counter := tmp + 1; LoadCounter2: tmp := counter; IncCounter2: counter := tmp + 1; SetSignal: signal := TRUE; end while; end process; end algorithm; *) ==== State Thread a Thread b Description signal = false, counter = 0 Loop Loop Both threads start running signal = false, counter = 0 WaitSignal Loop Thread a blocks waiting for the signal signal = false, counter = 0 WaitSignal Loop Thread b resets the signal, it does not unblock threads that are waiting signal = false, counter = 0, b.tmp = 0 WaitSignal LoadCounter1 Thread b loads counter signal = false, counter = 0, b.tmp = 0 WaitSignal IncCounter1 Thread b increments counter by setting it to tmp + 1 signal = false, counter = 1, b.tmp = 0 WaitSignal LoadCounter2 Thread b loads counter again signal = false, counter = 1, b.tmp = 1 WaitSignal IncCounter2 Thread b increments counter by setting it to tmp + 1 signal = false, counter = 2, b.tmp = 1 WaitSignal SetSignal Thread b signals the waiting thread signal = true, counter = 2, b.tmp = 1 WaitSignal Loop Thread b goes back to the beginning of the loop signal = true, counter = 2, a.tmp = 0, b.tmp = 1 LoadCounter Loop Thread a loads counter signal = true, counter = 2, a.tmp = 0, b.tmp = 1 LoadCounter ResetSignal Thread b resets the signal signal = false, counter = 2, a.tmp = 0, b.tmp = 1 LoadCounter LoadCounter1 Thread b loads counter signal = false, counter = 2, a.tmp = 0, b.tmp = 2 LoadCounter IncCounter1 Thread b increments counter by setting it to tmp + 1 signal = false, counter = 3, a.tmp = 0, b.tmp = 2 LoadCounter LoadCounter2 Thread b loads counter signal = false, counter = 3, a.tmp = 3, b.tmp = 2 CheckCounter LoadCounter2 Thread a resumes and checks if counter is odd and finds that it is Countdown Event\n// Thread a progress = progress + 20; if (progress \u003e= 20) { event.Signal(); event.Signal(); Atomic. Decrements the CountdownEvent's countdown timer by one. Throws an exception if the timer is already at zero (and you win the level). } event.Wait(); // Thread b progress = progress + 30; if (progress \u003e= 30) { event.Signal(); } progress = progress + 50; if (progress \u003e= 80) { event.Signal(); } event.Wait(); ---- MODULE spec ---- EXTENDS TLC, Integers (*--algorithm spec variables signal = 3, progress = 0; macro signal_signal() begin assert signal \u003e 0; signal := signal - 1; end macro; macro signal_wait() begin await signal = 0; end macro; process a = \"a\" variables tmp = 0; begin LoadProgres1: tmp := progress; SetProgress: progress := tmp + 20; LoadProgress2: tmp := progress; CheckProgress: if tmp \u003e= 20 then signal_signal(); end if; WaitSignal: signal_wait(); end process; process b = \"b\" variables tmp = 0; begin LoadProgress1: tmp := progress; SetProgress1: progress := tmp + 30; LoadProgress2: tmp := progress; CheckProgress1: if tmp \u003e= 30 then signal_signal(); end if; LoadProgress3: tmp := progress; SetProgress2: progress := tmp + 50; LoadProgress4: tmp := progress; CheckProgress2: if tmp \u003e= 80 then signal_signal(); end if; signal_wait(); end process; end algorithm; *) ==== State Thread a Thread b Description signal = 3, progress = 0, a.tmp = 0 LoadProgress1 LoadProgress1 Both threads start running signal = 3, progress = 0, a.tmp = 0 SetProgress LoadProgress1 Thread a is waiting to set progressto tmp + 20 signal = 3, progress = 0, a.tmp = 0, b.tmp = 0 SetProgress SetProgress1 Thread b will set progressto tmp + 30 signal = 3, progress = 30, a.tmp = 0, b.tmp = 0 SetProgress LoadProgress2 Thread b will load progress again signal = 3, progress = 20, a.tmp = 0, b.tmp = 0 LoadProgress2 LoadProgress2 Thread a resumes execution and sets progress to tmp + 20 before loading progress again signal = 3, progress = 20, a.tmp = 20, b.tmp = 0 CheckProgress LoadProgress2 Thread a will check that progress \u003e= 20 signal = 2, progress = 20, a.tmp = 20, b.tmp = 0 WaitSignal LoadProgress2 Thread a will wait for signal to reache 0 signal = 2, progress = 20, a.tmp = 20, b.tmp = 20 WaitSignal CheckProgress1 Thread b will check that progress \u003e= 30 after loading it into tmp signal = 2, progress = 20, a.tmp = 20, b.tmp = 20 WaitSignal LoadProgress3 Thread b will load progress into tmp signal = 2, progress = 20, a.tmp = 20, b.tmp = 20 WaitSignal SetProgress2 Thread b will set progress to tmp + 50 signal = 2, progress = 70, a.tmp = 20, b.tmp = 20 WaitSignal LoadProgress 4 Thread b will load progress signal = 2, progress = 70, a.tmp = 20, b.tmp = 20 WaitSignal LoadProgress 4 Thread b will check that progress \u003e= 80 signal = 2, progress = 70, a.tmp = 20, b.tmp = 20 DeadLock DeadLock Thread a is waiting for signal to reach 0 and thread b has already completed execution Countdown Event Revisited\nIn this case, since two threads are updating progress without synchronizing, lost updates cause event.Signal() to be called more than the allowed number of times (3).\n// Thread a while (true) { progress = progress + 20; event.Signal(); event.Wait(); if (progress == 100) { Environment.Exit(0); } } // Thread b while (true) { progress = progress + 30; event.Signal(); progress = progress + 50; event.Signal(); event.Wait(); if (progress == 100) { Environment.Exit(0); } } ---- MODULE spec ---- EXTENDS TLC, Integers (*--algorithm spec variables signal = 3, progress = 0; define SignalNeverGoesBelowZero == signal \u003e= 0 end define; macro signal_signal() begin signal := signal - 1; end macro; macro signal_wait() begin await signal = 0; end macro; process a = \"a\" variables exit = FALSE, tmp = 0; begin Loop: while ~exit do LoadProgres1: tmp := progress; SetProgress: progress := tmp + 20; Signal: signal_signal(); WaitSignal: signal_wait(); LoadProgress2: tmp := progress; CheckProgress: if tmp = 100 then exit := TRUE; end if; end while; end process; process b = \"b\" variables exit = FALSE, tmp = 0; begin Loop: while ~exit do LoadProgress1: tmp := progress; SetProgress1: progress := tmp + 30; Signal1: signal_signal(); LoadProgress2: tmp := progress; SetProgress2: progress := tmp + 50; Signal2: signal_signal(); WaitSignal: signal_wait(); LoadProgress3: tmp := progress; CheckProgress1: if tmp = 100 then exit := TRUE; end if; end while; end process; end algorithm; *) ==== The Barrier\nIn this case, fireball_charge will be 0 when thread a executes the if statement depending on the order of calls to barrier.SignalAndWait.\n// Thread a int fireballCharge=0; System.Threading.Barrier barrier; // [phase 0, waiting for 2 threads] while (true) { Interlocked.Increment(ref fireballCharge); barrier.SignalAndWait(); if (fireballCharge \u003c 2) { Debug.Assert(false); } fireball(); } // Thread b while (true) { Interlocked.Increment(ref fireballCharge); barrier.SignalAndWait(); } // Thread c while (true) { Interlocked.Increment(ref fireballCharge); barrier.SignalAndWait(); barrier.SignalAndWait(); fireballCharge = 0; } ---- MODULE spec ---- EXTENDS TLC, Integers, Sequences (*--algorithm spec variables fireball_charge = 2, barrier = 2, barrier_blocked = {}; procedure barrier_signal_and_wait(thread) begin BarrierSignal: if barrier - 1 = 0 then \\* Unblock threads waiting for the barrier. barrier_blocked := {}; \\* Reset the barrier. barrier := 2; else barrier := barrier - 1; barrier_blocked := barrier_blocked \\union {thread}; end if; BarrierAwait: await thread \\notin barrier_blocked; return; end procedure; process a = \"a\" begin A_Loop: while TRUE do A_IncrementFireball: fireball_charge := fireball_charge + 1; A_BarrierSignalAndWait: call barrier_signal_and_wait(\"a\"); A_CheckFireball: if fireball_charge \u003c 2 then print(\"CheckFireball: fireball_charge \u003c 2\"); assert FALSE; end if; end while; end process; process b = \"b\" begin B_Loop: while TRUE do B_IncrementFireball: fireball_charge := fireball_charge + 1; B_BarrierSignalAndWait: call barrier_signal_and_wait(\"b\"); end while; end process; process c = \"c\" begin C_Loop: while TRUE do C_IncrementFireball: fireball_charge := fireball_charge + 1; C_BarrierSignalAndWait1: call barrier_signal_and_wait(\"c\"); C_BarrierSignalAndWait2: call barrier_signal_and_wait(\"c\"); C_ResetFireball: fireball_charge := 0; end while; end process; end algorithm; *) ==== Action A increments fireball_charge B increments fireball_charge C increments fireball_charge A signals and blocks C signals and blocks, unblocking A and C B signals and blocks C signals and blocks, unblocking B and C C resets fireball_charge to 0. A checks fireball_charge, fireball_charge is 0.\nSemaphores\n// Thread a while (true) { semaphore.Wait(); critical_section(); semaphore.Release(); } // Thread b while (true) { if (semaphore.Wait(500)) { critical_section(); semaphore.Release(); } else { semaphore.Release(); } } ---- MODULE spec ---- EXTENDS TLC, Integers (*--algorithm spec variables sema = 1; threads_in_critical_section = 0; define CriticalSection == threads_in_critical_section \u003c= 1 end define; macro semaphore_wait(block) begin if block then await sema = 1; sema := 0; sema_acquired := TRUE; elsif sema = 0 then sema_acquired := TRUE; end if; end macro; macro semaphore_release() begin skip end macro; process a = \"a\" variables sema_acquired = FALSE; begin Loop: while TRUE do ResetSemaAcquired: sema_acquired := FALSE; SemaphoreWait: semaphore_wait(TRUE); CriticalSection_1: threads_in_critical_section := threads_in_critical_section + 1; CriticalSection_2: threads_in_critical_section := threads_in_critical_section - 1; SemaphoreRelease: semaphore_release(); end while; end process; process b = \"b\" variables sema_acquired = FALSE; begin Loop: while TRUE do ResetSemaAcquired: sema_acquired := FALSE; SemaphoreWait: semaphore_wait(FALSE); if sema_acquired then SemaphoreRelease_1: semaphore_release(); CriticalSection_1: threads_in_critical_section := threads_in_critical_section + 1; CriticalSection_2: threads_in_critical_section := threads_in_critical_section - 1; else SemaphoreRelease_2: semaphore_release(); end if; end while; end process; end algorithm; *) ==== Action Thread a waits to acquire the semaphore. Thread b tries to acquire the semaphore with a 500ms timeout, fails and releases the semaphore in the else branch. Thread a acquires the semaphore and enters the critical section. Thread b tries to acquire the semaphore with a 500ms timeout, fails and releases the semaphore in the else branch again. Thread b tries to acquire the semaphore with a 500ms timeout, succeds and enters the critical section. Both threads are in the critical section at the same time.\nProducer-consumer\n// Thread a while (true) { if (semaphore.Wait(500)) { queue.Dequeue(); } else { // Nothing in the queue. } } // Thread b while (true) { semaphore.Release(); queue.Enqueue(new Dragon()); } ---- MODULE spec ---- EXTENDS TLC, Sequences, Integers (*--algorithm spec variables sema = 0, queue = \u003c\u003c\u003e\u003e; macro semaphore_wait(block) begin if block then await sema = 1; sema := 0; sema_acquired := TRUE; elsif sema = 1 then sema := 0; sema_acquired := TRUE; end if; end macro; macro semaphore_release() begin sema := 1; end macro; macro dequeue() begin assert Len(queue) \u003e 0; queue := Tail(queue); end macro; macro enqueue() begin queue := Append(queue, \"v\"); end macro; process a = \"a\" variables sema_acquired = FALSE; begin Loop: while TRUE do ResetSemaAcquired: sema_acquired := FALSE; SemaphoreWait: semaphore_wait(FALSE); if sema_acquired then Dequeue: dequeue(); end if; end while; end process; process b = \"b\" begin Loop: while TRUE do ReleaseSema: semaphore_release(); Enqueue: enqueue(); end while; end process; end algorithm; *) ==== Action Thread a tries to acquire the semaphore with a 500ms timeout, fails and goes back to the start of the loop. Thread b releases the semaphore. Thread a acquires the semaphore before thread b adds an item to the queue. Thread a tries to dequeue from an empty queue. Producer-Consumer (variant)\n// Thread a while (true) { queue.Enqueue(new Golem()); } // Thread b while (true) { if (queue.Count \u003e 0) { queue.Dequeue(); } } ---- MODULE spec ---- EXTENDS TLC, Sequences, Integers (*--algorithm spec variables queue = \u003c\u003c\u003e\u003e, is_queue_inconsistent = FALSE; procedure enqueue() begin AddItem: queue := Append(queue, \"v\"); EnterInconsistentState: is_queue_inconsistent := TRUE; LeaveInconsistentState: is_queue_inconsistent := FALSE; end procedure; procedure dequeue() begin Dequeue: assert is_queue_inconsistent = FALSE; queue := Tail(queue); end procedure; process a = \"a\" begin Loop: while TRUE do call enqueue(); end while; end process; process b = \"b\" begin Loop: while TRUE do CheckQueueLen: if Len(queue) \u003e 0 then call dequeue(); end if; end while; end process; end algorithm; *) ==== Action Thread a starts the operation to add an item to queue and the queue enters an incosistent state while being modified Thread b finds out that the queue is not empty and tries to dequeue an item while the queue is still being modified by thread a Condition Variables\n// Thread a while (true) { Monitor.Enter(mutex); if (queue.Count == 0) { Monitor.Wait(mutex); release the lock, then sleep wait until woken up Monitor.Enter(mutex); } queue.Dequeue(); Monitor.Exit(mutex); } // Thread b while (true) { Monitor.Enter(mutex); if (queue.Count == 0) { Monitor.Wait(mutex); } queue.Dequeue(); Monitor.Exit(mutex); } // Thread c while (true) { Monitor.Enter(mutex); queue.Enqueue(42); Monitor.PulseAll(mutex); Monitor.Exit(mutex); } ---- MODULE spec ---- EXTENDS TLC, Sequences, Integers (*--algorithm spec variables queue = \u003c\u003c\u003e\u003e, condition_variable = [a |-\u003e FALSE, b |-\u003e FALSE], mutex = \"\"; macro mutex_enter(thread) begin await mutex = \"\"; mutex := thread; end macro; macro mutex_exit(thread) begin assert mutex = thread; mutex := \"\"; end macro; macro mutex_pulse_all(thread) begin assert mutex = thread; condition_variable := [x \\in DOMAIN condition_variable |-\u003e TRUE]; end macro; macro dequeue() begin assert Len(queue) \u003e 0; queue := Tail(queue); end macro; procedure mutex_wait(thread) begin ReleaseMutex: assert mutex = thread; mutex := \"\"; AwaitForConditionVariable: await condition_variable[thread] = TRUE; condition_variable[thread] := FALSE; AcquireMutex: mutex_enter(thread); return; end procedure; process a = \"a\" begin Loop: while TRUE do AcquireMutex: mutex_enter(\"a\"); CheckQueueLen: if Len(queue) = 0 then call mutex_wait(\"a\"); end if; Dequeue: dequeue(); ReleaseMutex: mutex_exit(\"a\"); end while; end process; process b = \"b\" begin Loop: while TRUE do AcquireMutex: mutex_enter(\"b\"); CheckQueueLen: if Len(queue) = 0 then call mutex_wait(\"b\"); end if; Dequeue: dequeue(); ReleaseMutex: mutex_exit(\"b\"); end while; end process; process c = \"c\" begin Loop: while TRUE do AcquireMutex: mutex_enter(\"c\"); Enqueue: queue := Append(queue, 42); MutexPulseAll: mutex_pulse_all(\"c\"); ReleaseMutex: mutex_exit(\"c\"); end while; end process; end algorithm; *) ==== Action Thread a acquires the mutex first, sees that the queue is empty and waits for the condition variable signal before proceeding. Thread c acquires the mutex, adds an item to the queue, signals the condition variable and releases the mutex. Thread b acquires the mutex before thread a gets to run, dequeues an item from the queue and releases the mutex. Thread a wakes up with the mutex acquired and tries to dequeue an item but finds out that queue is empty. Dragonfire\n// Thread a while (true) { Monitor.Enter(firebreathing); incinerate_enemies(); if (fireball.Wait(500)) { // Swoosh! blast_enemies(); // Uh... that was tiring. // I'd better rest while I'm vulnerable... if (fireball.Wait(500)) { if (fireball.Wait(500)) { critical_section(); } } // Safe now... } c = c - 1; c = c + 1; Monitor.Exit(firebreathing); } // Thread b // This is stupid. // The other head gets all the cool toys, // ...and I get stuck recharging. while (true) { if (c \u003c 2) { // Let's do some damage! fireball.Release(); c++; } else { // I hate being in here. critical_section(); } } ---- MODULE spec ---- EXTENDS TLC, Integers (*--algorithm spec variables mutex = \"\", critical_section = 0, c = 0, fireballs = 0; define CriticalSection == critical_section \u003c= 1 end define; macro mutex_enter(thread) begin await mutex = \"\"; mutex := thread; end macro; macro mutex_exit(thread) begin assert mutex = thread; mutex := \"\"; end macro; macro fireball_wait() begin if fireballs \u003e 0 then fireballs := fireballs - 1; ok := TRUE; else ok := FALSE; end if; end macro; process a = \"a\" variables tmp = 0, ok = FALSE; begin Loop: while TRUE do AcquireMutex: mutex_enter(\"a\"); \\* incinerate_enemies(); CheckFireball_1: fireball_wait(); if ok then \\* blast_enemies(); CheckFireball_2: fireball_wait(); if ok then CheckFireball_3: fireball_wait(); if ok then EnterCriticalSection: critical_section := critical_section + 1; LeaveCriticalSection: critical_section := critical_section - 1; end if; end if; end if; LoadC_1: tmp := c; DecrementC: c := tmp - 1; LoadC_2: tmp := c; IncrementC: c := tmp + 1; ReleaseMutex: mutex_exit(\"a\"); end while; end process; process b = \"b\" variables tmp = 0; begin Loop: while TRUE do if c \u003c 2 then FireballRelease: fireballs := fireballs + 1; LoadC: tmp := c; IncrementC: c := tmp + 1; else EnterCriticalSection: critical_section := critical_section + 1; LeaveCriticalSection: critical_section := critical_section - 1; end if; end while; end process; end algorithm; *) ==== Triple danger\n// Thread a while (true) { Monitor.Enter(conduit); // I summon mana for you, dragon! // Incinerate the enemies! energyBursts.Enqueue(new EnergyBurst()); Monitor.Exit(conduit); } // Thread b while (true) { if (energyBursts.Count \u003e 0) { Monitor.Enter(conduit); energyBursts.Dequeue(); lightning_bolts(terrifying: true); Monitor.Exit(conduit); } } // Thread c while (true) { if (energyBursts.Count \u003e 0) { Monitor.Enter(conduit); energyBursts.Dequeue(); fireball(mighty: true); Monitor.Exit(conduit); } } Provided without comment.\n---- MODULE spec ---- EXTENDS TLC, Sequences, Integers (*--algorithm spec variables mutex = \"\", queue = \u003c\u003c\u003e\u003e; macro mutex_enter(thread) begin await mutex = \"\"; mutex := thread; end macro; macro mutex_exit(thread) begin assert mutex = thread; mutex := \"\"; end macro; macro enqueue() begin queue := Append(queue, \"v\"); end macro; macro dequeue() begin assert Len(queue) \u003e 0; queue := Tail(queue); end macro; process a = \"a\" begin Loop: while TRUE do AcquireMutex: mutex_enter(\"a\"); Enqueue: enqueue(); ReleaseMutex: mutex_exit(\"a\"); end while; end process; process b = \"b\" begin Loop: while TRUE do if Len(queue) \u003e 0 then AcquireMutex: mutex_enter(\"b\"); Dequeue: dequeue(); ReleaseMutex: mutex_exit(\"b\"); end if; end while; end process; process c = \"c\" begin Loop: while TRUE do if Len(queue) \u003e 0 then AcquireMutex: mutex_enter(\"c\"); Dequeue: dequeue(); ReleaseMutex: mutex_exit(\"c\"); end if; end while; end process; end algorithm; *) ==== Provided without comment.\nBoss fight\n// Thread a while (true) { darkness++; evil++; if (darkness != 2 \u0026\u0026 evil != 2) { if (fortress.Wait(500)) { fortress.Wait(); Monitor.Enter(sanctum); Monitor.Wait(sanctum); critical_section(); Monitor.Exit(sanctum); } } } // Thread b while (true) { darkness++; evil++; if (darkness != 2 \u0026\u0026 evil == 2) { Monitor.Enter(sanctum); Monitor.Pulse(sanctum); Monitor.Exit(sanctum); critical_section(); } fortress.Release(); darkness = 0; evil = 0; } ---- MODULE spec ---- EXTENDS TLC, Integers, Sequences (*--algorithm spec variables mutex = \"\", mutex_pulse_received = FALSE, darkness = 0, evil = 0, fortress = 0, threads_in_critical_section = 0; define MutualExclusion == threads_in_critical_section \u003c= 1 end define; macro mutex_enter(thread) begin await mutex = \"\"; mutex := thread; end macro; macro mutex_exit(thread) begin assert mutex = thread; mutex := \"\"; end macro; macro mutex_pulse(thread) begin assert mutex = thread; mutex_pulse_received := TRUE; end macro; macro fortress_wait(block) begin if block then await fortress \u003e 0; end if; if fortress = 0 then ok := FALSE; else fortress := fortress - 1; ok := TRUE; end if; end macro; procedure mutex_wait(thread) begin MutexWait_ReleaseMutex: assert mutex = thread; mutex := \"\"; MutexWait_WaitForPulse: await mutex_pulse_received = TRUE; mutex_pulse_received := FALSE; MutexWait_AcquireMutex: mutex_enter(thread); return; end procedure; procedure inc_darkness() variables tmp = 0; begin Inc_Load: tmp := darkness; Inc_Add: darkness := tmp + 1; return; end procedure; procedure inc_evil() variables tmp = 0; begin Inc_Load: tmp := evil; Inc_Add: evil := tmp + 1; return; end procedure; procedure critical_section() begin CriticalSection_Enter: threads_in_critical_section := threads_in_critical_section + 1; CriticalSection_Leave: threads_in_critical_section := threads_in_critical_section - 1; return; end procedure; process a = \"a\" variables ok = FALSE; begin Loop: while TRUE do IncDarkness: call inc_darkness(); IncEvil: call inc_evil(); Check: if darkness # 2 /\\ evil # 2 then FortressWait_1: fortress_wait(FALSE); if ok then FortressWait_2: fortress_wait(TRUE); DecFortress: fortress := fortress - 1; AcquireMutex: mutex_enter(\"a\"); MutexWait: call mutex_wait(\"a\"); CriticalSection: call critical_section(); ReleaseMutex: mutex_exit(\"a\"); end if; end if; end while; end process; process b = \"b\" begin Loop: while TRUE do IncDarkness: call inc_darkness(); IncEvil: call inc_evil(); Check: if darkness # 2 /\\ evil = 2 then AcquireMutex: mutex_enter(\"b\"); MutexPulse: mutex_pulse(\"b\"); MutexExit: mutex_exit(\"b\"); CriticalSection: call critical_section(); end if; FortressRelease: fortress := fortress + 1; ResetDarkness: darkness := 0; ResetEvil: evil := 0; end while; end process; end algorithm; *) ==== Provided without comment.\n","wordCount":"5628","inLanguage":"en","image":"https://poorlydefinedbehaviour.github.io/papermod-cover.png","datePublished":"2024-08-15T00:00:00Z","dateModified":"2024-08-15T00:00:00Z","author":{"@type":"Person","name":"poorlydefinedbehaviour"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://poorlydefinedbehaviour.github.io/posts/the_deadlock_empire/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"https://poorlydefinedbehaviour.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://poorlydefinedbehaviour.github.io/ title=Home><span>Home</span></a></li><li><a href=https://poorlydefinedbehaviour.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://poorlydefinedbehaviour.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://poorlydefinedbehaviour.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://poorlydefinedbehaviour.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://poorlydefinedbehaviour.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Model checking The Deadlock Empire</h1><div class=post-meta><span title='2024-08-15 00:00:00 +0000 UTC'>August 15, 2024</span>&nbsp;·&nbsp;27 min&nbsp;·&nbsp;poorlydefinedbehaviour&nbsp;|&nbsp;<a href=https://github.com/PoorlyDefinedBehaviour/poorlydefinedbehaviour.github.io/tree/main/content/posts/the_deadlock_empire/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p><img loading=lazy src=/posts/the_deadlock_empire/images/banner.jpeg></p><p>This post contains <a href=https://learntla.com/>TLA+</a> solutions for <a href=https://deadlockempire.github.io/>The Deadlock Empire</a> which is a collection of challenges where the objective is to break multithreaded programs by playing the role of a scheduler that can context switch at any time.</p><p><a href=https://deadlockempire.github.io/#T2-Expansion>Non atomic instructions</a></p><p>There&rsquo;s two threads executing the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>a = a + <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (a == <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>  critical_section();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since the <code>a</code> increment is not atomic, conceptually, it is like setting a temporary variable to the value of <code>a</code>&ndash; <code>tmp = a</code> and then setting <code>a</code> to the temporary variable value incremented by 1 &ndash; <code>a = tmp + 1</code>.</p><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>---- MODULE spec ----
EXTENDS TLC, Integers, FiniteSets

(*--algorithm spec

variables
    a = 0,
    threads = 1..2,
    Enterd_critical_section = {};

define
    OnlyOneThreadEntersCriticalSection == Cardinality(Enterd_critical_section) &lt;= 1
end define;

process Thread \in threads
variables
    tmp = 0;
begin
Load:
    tmp := a;
Store:
    a := tmp + 1;
CriticalSectionCheck:
    if a = 1 then
        Enterd_critical_section := Enterd_critical_section \union {self};
    end if;
end process;

end algorithm; *)
====
</code></pre><table><thead><tr><th>State</th><th>Thread a</th><th>Thread b</th><th>Description</th></tr></thead><tbody><tr><td>a = 0</td><td>Init</td><td>Init</td><td>Both threads are at the initial state</td></tr><tr><td>a = 0, thread1.tmp = 0</td><td>Load</td><td>Init</td><td>Thread a stores the value of <code>a</code> in a temporary variable</td></tr><tr><td>a = 0, thread1.tmp = 0, thread2.tmp = 0</td><td>Load</td><td>Load</td><td>Thread b stores the value of <code>a</code> in a temporary variable</td></tr><tr><td>a = thread1.tmp + 1, thread1.tmp = 0, thread2.tmp = 0</td><td>Store</td><td>Load</td><td>Thread a sets <code>a</code> to <code>0 + 1</code> using the temporary variable</td></tr><tr><td>a = thread2.tmp + 1, thread1.tmp = 0, thread2.tmp = 0</td><td>Store</td><td>Store</td><td>Thread b sets <code>a</code> to <code>0 + 1</code> using the temporary variable</td></tr><tr><td>a = 1</td><td>CriticalSectionCheck</td><td>Store</td><td>Thread a enters the critical section since <code>a</code> is equal to <code>1</code></td></tr><tr><td>a = 1</td><td>CriticalSectionCheck</td><td>CriticalSectionCheck</td><td>Thread b enters the critical section since <code>a</code> is equal to <code>1</code> at the same time as thread 1</td></tr></tbody></table><p><a href=https://deadlockempire.github.io/#2-flags>Boolean Flags Are Enough For Everyone</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>flag = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (flag != <span style=color:#66d9ef>false</span>) {
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  flag = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  critical_section();
</span></span><span style=display:flex><span>  flag = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>---- MODULE spec ----
EXTENDS TLC, Integers, FiniteSets

(*--algorithm spec
variables
    threads = 1..2,
    flag = FALSE,
    threads_in_criticial_section = {};

define
    OnlyOneThreadEntersCriticalSection == Cardinality(threads_in_criticial_section) &lt;= 1
end define;

process Thread \in threads
begin
SpinLock:
    while flag do
        skip;
    end while;
SetFlag:
    flag := TRUE;
CriticalSection1:
    threads_in_criticial_section := threads_in_criticial_section \union {self};
CriticalSection2:
    threads_in_criticial_section :=  threads_in_criticial_section \ {self};
UnsetFlag:
    flag := FALSE;
end process;

end algorithm; *)
====
</code></pre><table><thead><tr><th>State</th><th>Thread a</th><th>Thread b</th><th>Description</th></tr></thead><tbody><tr><td>flag = false</td><td>Init</td><td>Init</td><td>Both threads are at the initial state</td></tr><tr><td>flag = false</td><td>SpinLock</td><td>Init</td><td>Thread a enters the spinlock</td></tr><tr><td>flag = false</td><td>SpinLock</td><td>SpinLock</td><td>Thread b enters the spinlock</td></tr><tr><td>flag = true</td><td>SpinLock</td><td>SetFlag</td><td>Thread b sees that <code>flag</code> is <code>false</code> so it leaves the spinlock and sets <code>flag</code> to <code>true</code></td></tr><tr><td>flag = true</td><td>SetFlag</td><td>SetFlag</td><td>Thread a was in the spinlock and read the value of <code>flag</code> before thread 2 set it to <code>true</code>. Thread a leaves the spinlock and sets <code>flag</code> to <code>true</code></td></tr><tr><td>flag = true</td><td>CriticalSection1</td><td>CriticalSection1</td><td>Both threads enter the critical section at the same time</td></tr></tbody></table><p><a href=https://deadlockempire.github.io/#3-simpleCounter>Simple counter</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  counter++;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (counter == <span style=color:#ae81ff>5</span>) {
</span></span><span style=display:flex><span>    critical_section();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>---- MODULE spec ----
EXTENDS TLC, Integers, FiniteSets

(*--algorithm spec
variables
    threads = {3, 5},
    threads_in_critical_section = {},
    counter = 0;

define
    MutualExclusion == Cardinality(threads_in_critical_section) &lt;= 1
end define;

process Thread \in threads
variables
    tmp = 0,
    done = FALSE;
begin
Loop:
    while ~done do
Load:
    tmp := counter;
Store:
    counter := tmp + 1;
EnterCriticalSection:
    if counter = self then
        threads_in_critical_section := threads_in_critical_section \union {self};
        done := TRUE;
    end if;
LeaveCriticalSection:
    threads_in_critical_section := threads_in_critical_section \ {self};
    end while;
end process;
end algorithm; *)
====
</code></pre><table><thead><tr><th>State</th><th>Thread a</th><th>Thread b</th><th>Description</th></tr></thead><tbody><tr><td>counter = 0</td><td>Loop</td><td>Loop</td><td>Thread a updates the counter until it reaches 3 while thread 2 is in the Loop state</td></tr><tr><td>counter = 0</td><td>Load</td><td>Loop</td><td></td></tr><tr><td>counter = 1</td><td>Store</td><td>Loop</td><td></td></tr><tr><td>counter = 1</td><td>Loop</td><td>Loop</td><td></td></tr><tr><td>counter = 1</td><td>Load</td><td>Loop</td><td></td></tr><tr><td>counter = 2</td><td>Store</td><td>Loop</td><td></td></tr><tr><td>counter = 2</td><td>Loop</td><td>Loop</td><td></td></tr><tr><td>counter = 2</td><td>Load</td><td>Loop</td><td></td></tr><tr><td>counter = 3</td><td>Store</td><td>Loop</td><td></td></tr><tr><td>counter = 3</td><td>EnterCriticalSection</td><td>Loop</td><td>Counter reached 3, so thread 1 enters the critical section</td></tr><tr><td>counter = 3</td><td>LeaveCriticalSection</td><td>Loop</td><td>While thread 1 is in the critical section, thread 2 updates the counter to 5</td></tr><tr><td>counter = 3</td><td>LeaveCriticalSection</td><td>Load</td><td></td></tr><tr><td>counter = 4</td><td>LeaveCriticalSection</td><td>Store</td><td></td></tr><tr><td>counter = 4</td><td>LeaveCriticalSection</td><td>Loop</td><td></td></tr><tr><td>counter = 4</td><td>LeaveCriticalSection</td><td>Load</td><td></td></tr><tr><td>counter = 5</td><td>LeaveCriticalSection</td><td>Store</td><td></td></tr><tr><td>counter = 5</td><td>LeaveCriticalSection</td><td>EnterCriticalSection</td><td>And thread 2 enters the critical section while thread 1 is still there</td></tr></tbody></table><blockquote><p>Thread a is in the LeaveCriticalSection state but it has not executed the step yet.</p></blockquote><p><a href=https://deadlockempire.github.io/#4-confusedCounter>Confused counter</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span>business_logic();
</span></span><span style=display:flex><span>first++;
</span></span><span style=display:flex><span>second++;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (second == <span style=color:#ae81ff>2</span> &amp;&amp; first != <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>  Debug.Assert(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span>business_logic();
</span></span><span style=display:flex><span>first++;
</span></span><span style=display:flex><span>second++;
</span></span></code></pre></div><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>---- MODULE spec ----
EXTENDS TLC, Integers

(*--algorithm spec
variables
    first = 0,
    second = 0,
    assertion_failed = FALSE;

define
    AssertionNeverFails == assertion_failed = FALSE
end define;

process ThreadA = &#34;a&#34;
variables
    tmp = 0;
begin
LoadFirst:
    tmp := first;
StoreFirst:
    first := tmp + 1;
LoadSecond:
    tmp := second;
StoreSecond:
    second := tmp + 1;
CriticalSection:
    if second = 2 /\ first # 2 then
        assertion_failed := TRUE;
    end if;
end process;

process ThreadB = &#34;b&#34;
variables
    tmp = 0;
begin
LoadFirst:
    tmp := first;
StoreFirst:
    first := tmp + 1;
LoadSecond:
    tmp := second;
StoreSecond:
    second := tmp + 1;
end process;
end algorithm; *)
====
</code></pre><table><thead><tr><th>State</th><th>Thread a</th><th>Thread b</th><th>Description</th></tr></thead><tbody><tr><td>first = 0, second = 0</td><td>LoadFirst</td><td>LoadFirst</td><td>Both threads load <code>first</code> into <code>thread1.tmp</code></td></tr><tr><td>first = 0, second = 0, thread1.tmp = 0, thread2.tmp = 0</td><td>StoreFirst</td><td>StoreFirst</td><td>Thread a updates <code>first</code> by setting it to <code>thread1.tmp + 1</code></td></tr><tr><td>first = 1, second = 0, thread1.tmp = 0, thread2.tmp = 0</td><td>LoadSecond</td><td>StoreFirst</td><td>Thread a loads <code>second</code> into <code>thread1.tmp</code>. Note that Thread b is still in the <code>StoreFirst</code> state since it has not executed yet</td></tr><tr><td>first = 1, second = 0, thread1.tmp = 0, thread2.tmp = 0</td><td>StoreSecond</td><td>StoreFirst</td><td>Thread a updates <code>second</code> by setting it to <code>thread1.tmp + 1</code></td></tr><tr><td>first = 1, second = 1, thread1.tmp = 0, thread2.tmp = 0</td><td>CriticalSection</td><td>StoreFirst</td><td>Thread a moves to the <code>CriticalSection</code> state but does not execute yet</td></tr><tr><td>first = 1, second = 1, thread1.tmp = 0, thread2.tmp = 0</td><td>CriticalSection</td><td>StoreFirst</td><td>Thread <code>2</code> updates <code>first</code> by setting it to <code>thread2.tmp + 1</code>. Note that <code>thread2.tmp</code> is still <code>0</code> since the variable was set in a previous state before Thread b got paused</td></tr><tr><td>first = 1, second = 1, thread1.tmp = 0, thread2.tmp = 0</td><td>CriticalSection</td><td>LoadSecond</td><td>Thread b loads <code>second</code> into <code>thread2.tmp</code></td></tr><tr><td>first = 1, second = 1, thread1.tmp = 0, thread2.tmp = 1</td><td>CriticalSection</td><td>StoreSecond</td><td>Thread b updates <code>second</code> by setting it to <code>thread2.tmp + 1</code>. Note that <code>thread2.tmp</code> is <code>1</code></td></tr><tr><td>first = 1, second = 1, thread1.tmp = 0, thread2.tmp = 1</td><td>CriticalSection</td><td>Done</td><td>Thread a resumes executions and the condition in the if the statement succeeds</td></tr></tbody></table><p><a href=https://deadlockempire.github.io/#L1-lock>Insuffient lock</a></p><p>Two threads use a mutex to protect <code>i</code>. The mutex works as expected, the problem is that exists an execution order where thread 1 hits the assertion.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  Monitor.Enter(mutex);
</span></span><span style=display:flex><span>  i = i + <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  critical_section();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (i == <span style=color:#ae81ff>5</span>) {
</span></span><span style=display:flex><span>    Debug.Assert(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  Monitor.Exit(mutex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  Monitor.Enter(mutex);
</span></span><span style=display:flex><span>  i = i - <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  critical_section();
</span></span><span style=display:flex><span>  Monitor.Exit(mutex);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>---- MODULE spec ----
EXTENDS TLC, Integers

(*--algorithm spec
variables
    lock = FALSE,
    assertion_failed = FALSE,
    i = 0;

define
    AssertionNeverFails == assertion_failed = FALSE
end define;

process ThreadA = &#34;a&#34;
begin
Loop:
while TRUE do
AcquireLock:
    await lock = FALSE;
    lock  := TRUE;
Modify:
    i := i + 2;
If:
  if i = 5 then
    assertion_failed := TRUE;
  end if;
ReleaseLock:
    lock := FALSE;
end while;
end process;

process ThreadB = &#34;b&#34;
begin
Loop:
while TRUE do
AcquireLock:
    await lock = FALSE;
    lock := TRUE;
Modify:
    i := i - 1;
ReleaseLock:
    lock := FALSE;
end while;
end process;
end algorithm; *)
====
</code></pre><table><thead><tr><th>State</th><th>Thread a</th><th>Thread b</th><th>Description</th><th></th></tr></thead><tbody><tr><td>i = 0</td><td>Loop</td><td>Loop</td><td>Threads start</td><td></td></tr><tr><td>i = 0</td><td>AcquireLock</td><td>AcquireLock</td><td>Thread a acquires the lock repeatedly until <code>i</code> reaches <code>4</code>. Thread b is stuck trying to acquire the lock</td><td></td></tr><tr><td>i = 0</td><td>Modify</td><td>AcquireLock</td><td></td><td></td></tr><tr><td>i = 2</td><td>If</td><td>AcquireLock</td><td></td><td></td></tr><tr><td>i = 2</td><td>ReleaseLock</td><td>AcquireLock</td><td></td><td></td></tr><tr><td>i = 2</td><td>AcquireLock</td><td>AcquireLock</td><td></td><td></td></tr><tr><td>i = 2</td><td>Modify</td><td>AcquireLock</td><td></td><td></td></tr><tr><td>i = 2</td><td>If</td><td>AcquireLock</td><td></td><td></td></tr><tr><td>i = 4</td><td>ReleaseLock</td><td>AcquireLock</td><td></td><td></td></tr><tr><td>i = 4</td><td>ReleaseLock</td><td>Modify</td><td>Thread b finally acquires the lock</td><td></td></tr><tr><td>i = 3</td><td>ReleaseLock</td><td>If</td><td></td><td></td></tr><tr><td>i = 3</td><td>ReleaseLock</td><td>ReleaseLock</td><td></td><td></td></tr><tr><td>i = 3</td><td>AcquireLock</td><td>AcquireLock</td><td></td><td></td></tr><tr><td>i = 3</td><td>Modify</td><td>AcquireLock</td><td>Thread a acquires the lock again</td><td></td></tr><tr><td>i = 5</td><td>If</td><td>AcquireLock</td><td>Thread</td><td><code>i</code> is equal to <code>5</code> this time, thread 1 hits the assertion</td></tr></tbody></table><p><a href=https://deadlockempire.github.io/#L2-deadlock>Deadlock</a></p><p>Note that the order in which each thread tries to acquire the locks is different.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span>Monitor.Enter(mutex);
</span></span><span style=display:flex><span>Monitor.Enter(mutex2);
</span></span><span style=display:flex><span>critical_section();
</span></span><span style=display:flex><span>Monitor.Exit(mutex);
</span></span><span style=display:flex><span>Monitor.Exit(mutex2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span>Monitor.Enter(mutex2);
</span></span><span style=display:flex><span>Monitor.Enter(mutex);
</span></span><span style=display:flex><span>critical_section();
</span></span><span style=display:flex><span>Monitor.Exit(mutex2);
</span></span><span style=display:flex><span>Monitor.Exit(mutex);
</span></span></code></pre></div><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>---- MODULE spec ----
EXTENDS TLC

(*--algorithm spec
variables
    mutex1 = FALSE,
    mutex2 = FALSE;

process ThreadA = &#34;a&#34;
begin
AcquireLock1:
    await mutex1 = FALSE;
    mutex1 := TRUE;
AcquireLock2:
    await mutex2 = FALSE;
    mutex2 := TRUE;
ReleaseLocks:
    mutex1 := FALSE;
    mutex2 := FALSE;
end process;

process ThreadB = &#34;b&#34;
begin
AcquireLock1:
    await mutex2 = FALSE;
    mutex2 := TRUE;
AcquireLock2:
    await mutex1 = FALSE;
    mutex1 := TRUE;
ReleaseLocks:
    mutex2 := FALSE;
    mutex1 := FALSE;
end process;
end algorithm; *)
====
</code></pre><table><thead><tr><th>State</th><th>Thread a</th><th>Thread b</th><th>Description</th></tr></thead><tbody><tr><td>mutex1 = FALSE, mutex2 = FALSE</td><td>AcquireLock1</td><td>AcquireLock1</td><td>Both threads start acquiring the locks</td></tr><tr><td>mutex1 = TRUE, mutex2 = FALSE</td><td>AcquireLock2</td><td>AcquireLock1</td><td>Thread a acquires the first lock and tries to acquire the second</td></tr><tr><td>mutex1 = TRUE, mutex2 = TRUE</td><td>AcquireLock2</td><td>AcquireLock2</td><td>Thread b acquires the second lock before thread 1 is able to acquire it</td></tr><tr><td>mutex1 = TRUE, mutex2 = TRUE</td><td>Deadlock</td><td>Deadlock</td><td>No thread can progress because one thread holds the lock the other thread needs</td></tr></tbody></table><p><a href=https://deadlockempire.github.io/#L3-complexer>A More Complex Thread</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (Monitor.TryEnter(mutex)) {
</span></span><span style=display:flex><span>    Monitor.Enter(mutex3);
</span></span><span style=display:flex><span>    Monitor.Enter(mutex);
</span></span><span style=display:flex><span>    critical_section();
</span></span><span style=display:flex><span>    Monitor.Exit(mutex);
</span></span><span style=display:flex><span>    Monitor.Enter(mutex2);
</span></span><span style=display:flex><span>    flag = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    Monitor.Exit(mutex2);
</span></span><span style=display:flex><span>    Monitor.Exit(mutex3);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    Monitor.Enter(mutex2);
</span></span><span style=display:flex><span>    flag = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    Monitor.Exit(mutex2);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (flag) {
</span></span><span style=display:flex><span>    Monitor.Enter(mutex2);
</span></span><span style=display:flex><span>    Monitor.Enter(mutex);
</span></span><span style=display:flex><span>    flag = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    critical_section();
</span></span><span style=display:flex><span>    Monitor.Exit(mutex);
</span></span><span style=display:flex><span>    Monitor.Enter(mutex2);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    Monitor.Enter(mutex);
</span></span><span style=display:flex><span>    flag = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    Monitor.Exit(mutex);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>---- MODULE spec ----
EXTENDS TLC, Sequences, FiniteSets, Integers

NULL == &lt;&lt;&#34;-1&#34;, -1&gt;&gt;

(*--algorithm spec
variables
    mutex = NULL,
    mutex2 = NULL,
    mutex3 = NULL,
    flag = FALSE;
macro enter(mutex, thread) begin
    await mutex = NULL \/ mutex[1] = thread;
    if mutex = NULL then
        mutex := &lt;&lt;thread, 1&gt;&gt;;
    else
        mutex := &lt;&lt;thread, mutex[2] + 1&gt;&gt;;
    end if;
end macro;

macro exit(mutex, thread) begin
    assert mutex[1] = thread;
    assert mutex[2] &gt; 0;

    if mutex[2] = 1 then
        mutex := NULL;
    else
        mutex := &lt;&lt;mutex[1], mutex[2] - 1&gt;&gt;;
    end if;
end macro;

macro try_enter(mutex, thread) begin
    if mutex = NULL then
        mutex := &lt;&lt;thread, 1&gt;&gt;;
        try_enter_result := TRUE;
    elsif mutex[1] = thread then
        mutex := &lt;&lt;thread, mutex[2] + 1&gt;&gt;;
        try_enter_result := TRUE;
    else
        try_enter_result := FALSE;
    end if;
end macro;

process thread_a = &#34;a&#34;
variables
    try_enter_result = FALSE;
begin
Loop:
while TRUE do
TryEnterMutex: try_enter(mutex, &#34;a&#34;);
CheckEnterMutex:
    if try_enter_result then
        EnterMutex3: enter(mutex3, &#34;a&#34;);
        EnterMutex: enter(mutex, &#34;a&#34;);
        ExitMutex: exit(mutex, &#34;a&#34;);
        EnterMutex2: enter(mutex2, &#34;a&#34;);
    else
        Else_EnterMutex2: enter(mutex2, &#34;a&#34;);
        SetFlag: flag := TRUE;
        ExitMutex2: exit(mutex2, &#34;a&#34;);
    end if;
end while;
end process;

process thread_b = &#34;b&#34;
begin
Loop:
while TRUE do
    CheckFlag:
    if flag then
        EnterMutex2:enter(mutex2, &#34;b&#34;);
        EnterMutex: enter(mutex, &#34;b&#34;);
        SetFlag:flag := FALSE;
        ExitMutex: exit(mutex, &#34;b&#34;);
        ExitMutex2: enter(mutex2, &#34;b&#34;);
    else
        Else_EnterMutex: enter(mutex, &#34;b&#34;);
        Else_SetFlag: flag := FALSE;
        Else_ExitMutex: exit(mutex, &#34;b&#34;);
    end if;
end while;
end process;
end algorithm; *)
====
</code></pre><blockquote><p>Variables that didn&rsquo;t change on transition to a new state were omitted.</p></blockquote><table><thead><tr><th>State</th><th>Thread a</th><th>Thread b</th><th>Description</th></tr></thead><tbody><tr><td>flag = false, mutex = NULL, mutex2 = NULL, mutex3 = NULL</td><td>Loop</td><td>Loop</td><td>Both threads start running</td></tr><tr><td>&mldr;</td><td>TryEnterMutex</td><td>Loop</td><td>Thread <code>a</code> moves to the <code>TryEnterMutex</code> state but has not executed yet</td></tr><tr><td>&mldr;</td><td>TryEnterMutex</td><td>CheckFlag</td><td>Thread <code>b</code> moves to the <code>CheckFlag</code> state</td></tr><tr><td>&mldr;</td><td>TryEnterMutex</td><td>Else_EnterMutex</td><td>Thread <code>b</code> checks that <code>flag</code> is <code>FALSE</code> and moves to the <code>else</code> branch</td></tr><tr><td>flag = false, mutex = &#171;&ldquo;b&rdquo;, 1&#187;, mutex2 = NULL, mutex3 = NULL</td><td>TryEnterMutex</td><td>Else_SetFlag</td><td>After acquiring <code>mutex</code>, thread <code>b</code> sets <code>flag</code> to <code>FALSE</code></td></tr><tr><td>&mldr;</td><td>CheckEnterMutex</td><td>Else_SetFlag</td><td>Thread <code>a</code> resumes execution and checks if <code>flag</code> is <code>TRUE</code></td></tr><tr><td>flag = false, mutex = &#171;&ldquo;b&rdquo;, 1&#187;, mutex2 = &#171;&ldquo;a&rdquo;, 1&#187;, mutex3 = NULL</td><td>Else_EnterMutex2</td><td>Else_SetFlag</td><td>Thread <code>a</code> finds out that <code>flag</code> is <code>FALSE</code> and moves to the <code>else</code> branch</td></tr><tr><td>&mldr;</td><td>SetFlag</td><td>Else_SetFlag</td><td>Thread <code>a</code> <code>will</code> set <code>flag</code> to <code>TRUE</code></td></tr><tr><td>&mldr;</td><td>SetFlag</td><td>Else_ExitMutex</td><td>Thread <code>b</code> resumes execution and releases <code>mutex</code> before thread <code>a</code> sets <code>flag</code> to <code>TRUE</code></td></tr><tr><td>flag = true, mutex = &#171;&ldquo;b&rdquo;, 1&#187;, mutex2 = NULL, mutex3 = NULL</td><td>ExitMutex2</td><td>Else_ExitMutex</td><td>Thread <code>a</code> sets <code>flag</code> to <code>TRUE</code></td></tr><tr><td>flag = true, mutex = NULL, mutex2 = NULL, mutex3 = NULL</td><td>Loop</td><td>Else_ExitMutex</td><td>Thread <code>a</code> releases <code>mutex2</code></td></tr><tr><td>&mldr;</td><td>TryEnterMutex</td><td>Else_ExitMutex</td><td>Thread <code>a</code> tries to acquire <code>mutex</code></td></tr><tr><td>&mldr;</td><td>TryEnterMutex</td><td>Loop</td><td>Thread <code>b</code> resumes execution</td></tr><tr><td>&mldr;</td><td>CheckEnterMutex</td><td>Loop</td><td>Thread <code>a</code> checks if <code>mutex</code> has been acquired</td></tr><tr><td>flag = true, mutex = &#171;&ldquo;a&rdquo;, 1&#187;, mutex2 = NULL, mutex3 = &#171;&ldquo;a&rdquo;, 1&#187;</td><td>EnterMutex3</td><td>Loop</td><td><code>mutex3</code> was already acquired by thread <code>a</code></td></tr><tr><td>flag = true, mutex = &#171;&ldquo;a&rdquo;, 2&#187;, mutex2 = NULL, mutex3 = &#171;&ldquo;a&rdquo;, 1&#187;</td><td>EnterMutex</td><td>Loop</td><td>Thread <code>a</code> acquires <code>mutex</code> again</td></tr><tr><td>flag = true, mutex = &#171;&ldquo;a&rdquo;, 1&#187;, mutex2 = NULL, mutex3 = &#171;&ldquo;a&rdquo;, 1&#187;</td><td>ExitMutex</td><td>Loop</td><td>Thread <code>a</code> releases <code>mutex</code></td></tr><tr><td>&mldr;</td><td>EnterMutex2</td><td>Loop</td><td>Thread <code>a</code> will try to acquire <code>mutex2</code></td></tr><tr><td>&mldr;</td><td>EnterMutex2</td><td>CheckFlag</td><td>Thread <code>b</code> resumes execution and checks if <code>flag</code> is <code>TRUE</code></td></tr><tr><td>flag = true, mutex = &#171;&ldquo;a&rdquo;, 1&#187;, mutex2 = &#171;&ldquo;b&rdquo;, 1&#187;, mutex3 = &#171;&ldquo;a&rdquo;, 1&#187;</td><td>EnterMutex2</td><td>EnterMutex2</td><td><code>flag</code> is <code>TRUE</code>, so thread <code>b</code> triers to acquire <code>mutex2</code></td></tr><tr><td>flag = true, mutex = &#171;&ldquo;a&rdquo;, 1&#187;, mutex2 = &#171;&ldquo;b&rdquo;, 1&#187;, mutex3 = &#171;&ldquo;a&rdquo;, 1&#187;</td><td>EnterMutex2</td><td>EnterMutex</td><td>Thread <code>b</code> acquires <code>mutex</code>2 and tries to acquire <code>mutex</code> while thread <code>a</code> tries to acquire `mutex2.</td></tr><tr><td>&mldr;</td><td>Deadlock</td><td>Deadlock</td><td></td></tr></tbody></table><p><a href=https://deadlockempire.github.io/#H1-ManualResetEvent>Manual Reset Event</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  sync.Wait();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (counter % <span style=color:#ae81ff>2</span> == <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    Debug.Assert(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  sync.Reset();
</span></span><span style=display:flex><span>  counter++;
</span></span><span style=display:flex><span>  counter++;
</span></span><span style=display:flex><span>  sync.Set();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-pluscal data-lang=pluscal>---- MODULE spec ----
EXTENDS TLC, Integers

(*--algorithm spec
variables
    signal = FALSE,
    counter = 0;

process a = &#34;a&#34;
variables
    tmp = 0;
begin
Loop:
while TRUE do
    WaitSignal: await signal;
    LoadCounter: tmp := counter;
    CheckCounter:
    if tmp % 2 = 1 then
        assert FALSE;
    end if;
end while;
end process;

process b = &#34;b&#34;
variables
    tmp = 0;
begin
Loop:
while TRUE do
    ResetSignal: signal := FALSE;

    LoadCounter1: tmp := counter;
    IncCounter1: counter := tmp + 1;

    LoadCounter2: tmp := counter;
    IncCounter2: counter := tmp + 1;

    SetSignal: signal := TRUE;
end while;
end process;
end algorithm; *)
====
</code></pre><table><thead><tr><th>State</th><th>Thread a</th><th>Thread b</th><th>Description</th></tr></thead><tbody><tr><td>signal = false, counter = 0</td><td>Loop</td><td>Loop</td><td>Both threads start running</td></tr><tr><td>signal = false, counter = 0</td><td>WaitSignal</td><td>Loop</td><td>Thread <code>a</code> blocks waiting for the signal</td></tr><tr><td>signal = false, counter = 0</td><td>WaitSignal</td><td>Loop</td><td>Thread <code>b</code> resets the signal, it does not unblock threads that are waiting</td></tr><tr><td>signal = false, counter = 0, b.tmp = 0</td><td>WaitSignal</td><td>LoadCounter1</td><td>Thread <code>b</code> loads <code>counter</code></td></tr><tr><td>signal = false, counter = 0, b.tmp = 0</td><td>WaitSignal</td><td>IncCounter1</td><td>Thread <code>b</code> increments <code>counter</code> by setting it to <code>tmp + 1</code></td></tr><tr><td>signal = false, counter = 1, b.tmp = 0</td><td>WaitSignal</td><td>LoadCounter2</td><td>Thread <code>b</code> loads <code>counter</code> again</td></tr><tr><td>signal = false, counter = 1, b.tmp = 1</td><td>WaitSignal</td><td>IncCounter2</td><td>Thread <code>b</code> increments <code>counter</code> by setting it to <code>tmp + 1</code></td></tr><tr><td>signal = false, counter = 2, b.tmp = 1</td><td>WaitSignal</td><td>SetSignal</td><td>Thread <code>b</code> signals the waiting thread</td></tr><tr><td>signal = true, counter = 2, b.tmp = 1</td><td>WaitSignal</td><td>Loop</td><td>Thread <code>b</code> goes back to the beginning of the loop</td></tr><tr><td>signal = true, counter = 2, a.tmp = 0, b.tmp = 1</td><td>LoadCounter</td><td>Loop</td><td>Thread <code>a</code> loads <code>counter</code></td></tr><tr><td>signal = true, counter = 2, a.tmp = 0, b.tmp = 1</td><td>LoadCounter</td><td>ResetSignal</td><td>Thread <code>b</code> resets the signal</td></tr><tr><td>signal = false, counter = 2, a.tmp = 0, b.tmp = 1</td><td>LoadCounter</td><td>LoadCounter1</td><td>Thread <code>b</code> loads <code>counter</code></td></tr><tr><td>signal = false, counter = 2, a.tmp = 0, b.tmp = 2</td><td>LoadCounter</td><td>IncCounter1</td><td>Thread <code>b</code> increments <code>counter</code> by setting it to <code>tmp + 1</code></td></tr><tr><td>signal = false, counter = 3, a.tmp = 0, b.tmp = 2</td><td>LoadCounter</td><td>LoadCounter2</td><td>Thread <code>b</code> loads <code>counter</code></td></tr><tr><td>signal = false, counter = 3, a.tmp = 3, b.tmp = 2</td><td>CheckCounter</td><td>LoadCounter2</td><td>Thread <code>a</code> resumes and checks if <code>counter</code> is odd and finds that it is</td></tr></tbody></table><p><a href=https://deadlockempire.github.io/#H2-CountdownEvent>Countdown Event</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span>progress = progress + <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (progress &gt;= <span style=color:#ae81ff>20</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>event</span>.Signal();
</span></span><span style=display:flex><span><span style=color:#66d9ef>event</span>.Signal();
</span></span><span style=display:flex><span>Atomic. Decrements the CountdownEvent<span style=color:#960050;background-color:#1e0010>&#39;</span>s countdown timer <span style=color:#66d9ef>by</span> one. Throws an exception <span style=color:#66d9ef>if</span> the timer <span style=color:#66d9ef>is</span> already at zero (and you win the level).
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>event</span>.Wait();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span>progress = progress + <span style=color:#ae81ff>30</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (progress &gt;= <span style=color:#ae81ff>30</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>event</span>.Signal();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>progress = progress + <span style=color:#ae81ff>50</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (progress &gt;= <span style=color:#ae81ff>80</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>event</span>.Signal();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>event</span>.Wait();
</span></span></code></pre></div><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>
---- MODULE spec ----
EXTENDS TLC, Integers

(*--algorithm spec
variables
    signal = 3,
    progress = 0;

macro signal_signal() begin
    assert signal &gt; 0;
    signal := signal - 1;
end macro;

macro signal_wait() begin
    await signal = 0;
end macro;

process a = &#34;a&#34;
variables
    tmp = 0;
begin
LoadProgres1: tmp := progress;
SetProgress: progress := tmp + 20;

LoadProgress2: tmp := progress;

CheckProgress: if tmp &gt;= 20 then
    signal_signal();
end if;

WaitSignal: signal_wait();
end process;

process b = &#34;b&#34;
variables
    tmp = 0;
begin
LoadProgress1: tmp := progress;
SetProgress1: progress := tmp + 30;

LoadProgress2: tmp := progress;

CheckProgress1: if tmp &gt;= 30 then
    signal_signal();
end if;

LoadProgress3: tmp := progress;
SetProgress2: progress := tmp + 50;

LoadProgress4: tmp := progress;

CheckProgress2: if tmp &gt;= 80 then
    signal_signal();
end if;

signal_wait();
end process;
end algorithm; *)
====
</code></pre><table><thead><tr><th>State</th><th>Thread a</th><th>Thread b</th><th>Description</th></tr></thead><tbody><tr><td>signal = 3, progress = 0, a.tmp = 0</td><td>LoadProgress1</td><td>LoadProgress1</td><td>Both threads start running</td></tr><tr><td>signal = 3, progress = 0, a.tmp = 0</td><td>SetProgress</td><td>LoadProgress1</td><td>Thread <code>a</code> is waiting to set <code>progress</code>to <code>tmp + 20</code></td></tr><tr><td>signal = 3, progress = 0, a.tmp = 0, b.tmp = 0</td><td>SetProgress</td><td>SetProgress1</td><td>Thread <code>b</code> will set <code>progress</code>to <code>tmp + 30</code></td></tr><tr><td>signal = 3, progress = 30, a.tmp = 0, b.tmp = 0</td><td>SetProgress</td><td>LoadProgress2</td><td>Thread <code>b</code> will load <code>progress</code> again</td></tr><tr><td>signal = 3, progress = 20, a.tmp = 0, b.tmp = 0</td><td>LoadProgress2</td><td>LoadProgress2</td><td>Thread <code>a</code> resumes execution and sets <code>progress</code> to <code>tmp + 20</code> before loading <code>progress</code> again</td></tr><tr><td>signal = 3, progress = 20, a.tmp = 20, b.tmp = 0</td><td>CheckProgress</td><td>LoadProgress2</td><td>Thread <code>a</code> will check that <code>progress >= 20</code></td></tr><tr><td>signal = 2, progress = 20, a.tmp = 20, b.tmp = 0</td><td>WaitSignal</td><td>LoadProgress2</td><td>Thread <code>a</code> will wait for signal to reache <code>0</code></td></tr><tr><td>signal = 2, progress = 20, a.tmp = 20, b.tmp = 20</td><td>WaitSignal</td><td>CheckProgress1</td><td>Thread <code>b</code> will check that <code>progress >= 30</code> after loading it into <code>tmp</code></td></tr><tr><td>signal = 2, progress = 20, a.tmp = 20, b.tmp = 20</td><td>WaitSignal</td><td>LoadProgress3</td><td>Thread <code>b</code> will load <code>progress</code> into <code>tmp</code></td></tr><tr><td>signal = 2, progress = 20, a.tmp = 20, b.tmp = 20</td><td>WaitSignal</td><td>SetProgress2</td><td>Thread <code>b</code> will set <code>progress</code> to <code>tmp + 50</code></td></tr><tr><td>signal = 2, progress = 70, a.tmp = 20, b.tmp = 20</td><td>WaitSignal</td><td>LoadProgress 4</td><td>Thread <code>b</code> will load <code>progress</code></td></tr><tr><td>signal = 2, progress = 70, a.tmp = 20, b.tmp = 20</td><td>WaitSignal</td><td>LoadProgress 4</td><td>Thread <code>b</code> will check that <code>progress >= 80</code></td></tr><tr><td>signal = 2, progress = 70, a.tmp = 20, b.tmp = 20</td><td>DeadLock</td><td>DeadLock</td><td>Thread <code>a</code> is waiting for <code>signal</code> to reach <code>0</code> and thread <code>b</code> has already completed execution</td></tr></tbody></table><p><a href=https://deadlockempire.github.io/#H3-CountdownEvent>Countdown Event Revisited</a></p><p>In this case, since two threads are updating <code>progress</code> without synchronizing, lost updates cause <code>event.Signal()</code> to be called more than the allowed number of times (3).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  progress = progress + <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>event</span>.Signal();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>event</span>.Wait();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (progress == <span style=color:#ae81ff>100</span>) {
</span></span><span style=display:flex><span>    Environment.Exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  progress = progress + <span style=color:#ae81ff>30</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>event</span>.Signal();
</span></span><span style=display:flex><span>  progress = progress + <span style=color:#ae81ff>50</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>event</span>.Signal();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>event</span>.Wait();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (progress == <span style=color:#ae81ff>100</span>) {
</span></span><span style=display:flex><span>    Environment.Exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>---- MODULE spec ----
EXTENDS TLC, Integers

(*--algorithm spec
variables
    signal = 3,
    progress = 0;

define
    SignalNeverGoesBelowZero == signal &gt;= 0
end define;

macro signal_signal() begin
    signal := signal - 1;
end macro;

macro signal_wait() begin
    await signal = 0;
end macro;

process a = &#34;a&#34;
variables
    exit = FALSE,
    tmp = 0;
begin
Loop:
while ~exit do
LoadProgres1: tmp := progress;
SetProgress: progress := tmp + 20;

Signal: signal_signal();

WaitSignal: signal_wait();

LoadProgress2: tmp := progress;
CheckProgress: if tmp = 100 then
    exit := TRUE;
end if;
end while;
end process;

process b = &#34;b&#34;
variables
    exit = FALSE,
    tmp = 0;
begin
Loop:
while ~exit do
LoadProgress1: tmp := progress;
SetProgress1: progress := tmp + 30;

Signal1: signal_signal();

LoadProgress2: tmp := progress;
SetProgress2: progress := tmp + 50;

Signal2: signal_signal();

WaitSignal: signal_wait();

LoadProgress3: tmp := progress;
CheckProgress1: if tmp = 100 then
    exit := TRUE;
end if;
end while;
end process;
end algorithm; *)
====
</code></pre><p><a href=https://deadlockempire.github.io/#H3-CountdownEvent>The Barrier</a></p><p>In this case, <code>fireball_charge</code> will be <code>0</code> when thread <code>a</code> executes the if statement depending on the order of calls to <code>barrier.SignalAndWait</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> fireballCharge=<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>System.Threading.Barrier barrier; <span style=color:#75715e>// [phase 0, waiting for 2 threads]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  Interlocked.Increment(<span style=color:#66d9ef>ref</span> fireballCharge);
</span></span><span style=display:flex><span>  barrier.SignalAndWait();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (fireballCharge &lt; <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>    Debug.Assert(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  fireball();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  Interlocked.Increment(<span style=color:#66d9ef>ref</span> fireballCharge);
</span></span><span style=display:flex><span>  barrier.SignalAndWait();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread c</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  Interlocked.Increment(<span style=color:#66d9ef>ref</span> fireballCharge);
</span></span><span style=display:flex><span>  barrier.SignalAndWait();
</span></span><span style=display:flex><span>  barrier.SignalAndWait();
</span></span><span style=display:flex><span>  fireballCharge = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-pluscal data-lang=pluscal>---- MODULE spec ----
EXTENDS TLC, Integers, Sequences

(*--algorithm spec
variables
    fireball_charge = 2,
    barrier = 2,
    barrier_blocked = {};

procedure barrier_signal_and_wait(thread) begin
    BarrierSignal:
        if barrier - 1 = 0 then
            \* Unblock threads waiting for the barrier.
            barrier_blocked := {};
            \* Reset the barrier.
            barrier := 2;
        else
            barrier := barrier - 1;
            barrier_blocked := barrier_blocked \union {thread};
        end if;

    BarrierAwait:
        await thread \notin barrier_blocked;

    return;
end procedure;


process a = &#34;a&#34;
begin
A_Loop:
while TRUE do
    A_IncrementFireball: fireball_charge := fireball_charge + 1;
    A_BarrierSignalAndWait: call barrier_signal_and_wait(&#34;a&#34;);
    A_CheckFireball: if fireball_charge &lt; 2 then
        print(&#34;CheckFireball: fireball_charge &lt; 2&#34;);
        assert FALSE;
    end if;
end while;
end process;

process b = &#34;b&#34;
begin
B_Loop:
while TRUE do
    B_IncrementFireball: fireball_charge := fireball_charge + 1;
    B_BarrierSignalAndWait: call barrier_signal_and_wait(&#34;b&#34;);
end while;
end process;

process c = &#34;c&#34;
begin
C_Loop:
while TRUE do
    C_IncrementFireball: fireball_charge := fireball_charge + 1;
    C_BarrierSignalAndWait1: call barrier_signal_and_wait(&#34;c&#34;);
    C_BarrierSignalAndWait2: call barrier_signal_and_wait(&#34;c&#34;);
    C_ResetFireball: fireball_charge := 0;
end while;
end process;
end algorithm; *)
====
</code></pre><table><thead><tr><th>Action</th></tr></thead><tbody></tbody></table><p>A increments fireball_charge
B increments fireball_charge
C increments fireball_charge
A signals and blocks
C signals and blocks, unblocking A and C
B signals and blocks
C signals and blocks, unblocking B and C
C resets fireball_charge to 0.
A checks fireball_charge, fireball_charge is 0.</p><p><a href=https://deadlockempire.github.io/#S1-simple>Semaphores</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  semaphore.Wait();
</span></span><span style=display:flex><span>  critical_section();
</span></span><span style=display:flex><span>  semaphore.Release();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (semaphore.Wait(<span style=color:#ae81ff>500</span>)) {
</span></span><span style=display:flex><span>    critical_section();
</span></span><span style=display:flex><span>    semaphore.Release();
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    semaphore.Release();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>---- MODULE spec ----
EXTENDS TLC, Integers

(*--algorithm spec
variables
    sema = 1;
    threads_in_critical_section = 0;

define
    CriticalSection == threads_in_critical_section &lt;= 1
end define;

macro semaphore_wait(block) begin
    if block then
        await sema = 1;
        sema := 0;
        sema_acquired := TRUE;
    elsif sema = 0 then
        sema_acquired := TRUE;
    end if;
end macro;

macro semaphore_release() begin
    skip
end macro;

process a = &#34;a&#34;
variables
    sema_acquired = FALSE;
begin
Loop:
while TRUE do
    ResetSemaAcquired: sema_acquired := FALSE;
    SemaphoreWait: semaphore_wait(TRUE);
    CriticalSection_1: threads_in_critical_section := threads_in_critical_section + 1;
    CriticalSection_2: threads_in_critical_section := threads_in_critical_section - 1;
    SemaphoreRelease: semaphore_release();
end while;
end process;

process b = &#34;b&#34;
variables
    sema_acquired = FALSE;
begin
Loop:
while TRUE do
    ResetSemaAcquired: sema_acquired := FALSE;
    SemaphoreWait: semaphore_wait(FALSE);
    if sema_acquired then
        SemaphoreRelease_1: semaphore_release();
        CriticalSection_1: threads_in_critical_section := threads_in_critical_section + 1;
        CriticalSection_2: threads_in_critical_section := threads_in_critical_section - 1;
    else
        SemaphoreRelease_2: semaphore_release();
    end if;
end while;
end process;
end algorithm; *)
====
</code></pre><table><thead><tr><th>Action</th></tr></thead><tbody></tbody></table><p>Thread <code>a</code> waits to acquire the semaphore.
Thread <code>b</code> tries to acquire the semaphore with a <code>500ms</code> timeout, fails and releases the semaphore in the <code>else</code> branch.
Thread <code>a</code> acquires the semaphore and enters the critical section.
Thread <code>b</code> tries to acquire the semaphore with a <code>500ms</code> timeout, fails and releases the semaphore in the <code>else</code> branch again.
Thread <code>b</code> tries to acquire the semaphore with a <code>500ms</code> timeout, succeds and enters the critical section.
Both threads are in the critical section at the same time.</p><p><a href=https://deadlockempire.github.io/#S2-producerConsumer>Producer-consumer</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (semaphore.Wait(<span style=color:#ae81ff>500</span>)) {
</span></span><span style=display:flex><span>    queue.Dequeue();
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Nothing in the queue.</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  semaphore.Release();
</span></span><span style=display:flex><span>  queue.Enqueue(<span style=color:#66d9ef>new</span> Dragon());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>---- MODULE spec ----
EXTENDS TLC, Sequences, Integers

(*--algorithm spec
variables
    sema = 0,
    queue = &lt;&lt;&gt;&gt;;

macro semaphore_wait(block) begin
    if block then
        await sema = 1;
        sema := 0;
        sema_acquired := TRUE;
    elsif sema = 1 then
        sema := 0;
        sema_acquired := TRUE;
    end if;
end macro;

macro semaphore_release() begin
    sema := 1;
end macro;

macro dequeue() begin
    assert Len(queue) &gt; 0;
    queue := Tail(queue);
end macro;

macro enqueue() begin
    queue := Append(queue, &#34;v&#34;);
end macro;

process a = &#34;a&#34;
variables
    sema_acquired = FALSE;
begin
Loop:
while TRUE do
    ResetSemaAcquired: sema_acquired := FALSE;
    SemaphoreWait:
        semaphore_wait(FALSE);
        if sema_acquired then
            Dequeue: dequeue();
        end if;

end while;
end process;

process b = &#34;b&#34;
begin
Loop:
while TRUE do
    ReleaseSema: semaphore_release();
    Enqueue: enqueue();
end while;
end process;
end algorithm; *)
====
</code></pre><table><thead><tr><th>Action</th></tr></thead><tbody><tr><td>Thread <code>a</code> tries to acquire the semaphore with a <code>500ms</code> timeout, fails and goes back to the start of the loop.</td></tr><tr><td>Thread <code>b</code> releases the semaphore.</td></tr><tr><td>Thread <code>a</code> acquires the semaphore before thread <code>b</code> adds an item to the queue.</td></tr><tr><td>Thread <code>a</code> tries to dequeue from an empty queue.</td></tr></tbody></table><p><a href=https://deadlockempire.github.io/#S3-producerConsumer>Producer-Consumer (variant)</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  queue.Enqueue(<span style=color:#66d9ef>new</span> Golem());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (queue.Count &gt; <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    queue.Dequeue();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>
---- MODULE spec ----
EXTENDS TLC, Sequences, Integers

(*--algorithm spec
variables
    queue = &lt;&lt;&gt;&gt;,
    is_queue_inconsistent = FALSE;

procedure enqueue() begin 
    AddItem: queue := Append(queue, &#34;v&#34;);
    EnterInconsistentState: is_queue_inconsistent := TRUE;
    LeaveInconsistentState: is_queue_inconsistent := FALSE;
end procedure;

procedure dequeue() begin 
Dequeue:
    assert is_queue_inconsistent = FALSE;
    queue := Tail(queue);
end procedure;

process a = &#34;a&#34;
begin
Loop:
while TRUE do
    call enqueue();
end while;
end process;

process b = &#34;b&#34;
begin
Loop:
while TRUE do
    CheckQueueLen: 
    if Len(queue) &gt; 0 then
        call dequeue();
    end if;
end while;
end process;
end algorithm; *)
====
</code></pre><table><thead><tr><th>Action</th></tr></thead><tbody><tr><td>Thread <code>a</code> starts the operation to add an item to queue and the queue enters an incosistent state while being modified</td></tr><tr><td>Thread <code>b</code> finds out that the queue is not empty and tries to dequeue an item while the queue is still being modified by thread <code>a</code></td></tr></tbody></table><p><a href=https://deadlockempire.github.io/#CV1-simple>Condition Variables</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  Monitor.Enter(mutex);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (queue.Count == <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    Monitor.Wait(mutex);
</span></span><span style=display:flex><span>      release the <span style=color:#66d9ef>lock</span>, then sleep
</span></span><span style=display:flex><span>      wait until woken up
</span></span><span style=display:flex><span>      Monitor.Enter(mutex);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  queue.Dequeue();
</span></span><span style=display:flex><span>  Monitor.Exit(mutex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  Monitor.Enter(mutex);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (queue.Count == <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    Monitor.Wait(mutex);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  queue.Dequeue();
</span></span><span style=display:flex><span>  Monitor.Exit(mutex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread c</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  Monitor.Enter(mutex);
</span></span><span style=display:flex><span>  queue.Enqueue(<span style=color:#ae81ff>42</span>);
</span></span><span style=display:flex><span>  Monitor.PulseAll(mutex);
</span></span><span style=display:flex><span>  Monitor.Exit(mutex);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>---- MODULE spec ----
EXTENDS TLC, Sequences, Integers

(*--algorithm spec
variables
    queue = &lt;&lt;&gt;&gt;,
    condition_variable = [a |-&gt; FALSE, b |-&gt; FALSE],
    mutex = &#34;&#34;;

macro mutex_enter(thread) begin
    await mutex = &#34;&#34;;
    mutex := thread;
end macro;

macro mutex_exit(thread) begin
    assert mutex = thread;
    mutex := &#34;&#34;;
end macro;

macro mutex_pulse_all(thread) begin
    assert mutex = thread;
    condition_variable := [x \in DOMAIN condition_variable |-&gt; TRUE];
end macro;

macro dequeue() begin
    assert Len(queue) &gt; 0;
    queue := Tail(queue);
end macro;

procedure mutex_wait(thread) begin
    ReleaseMutex:
        assert mutex = thread;
        mutex := &#34;&#34;;
    AwaitForConditionVariable: 
        await condition_variable[thread] = TRUE;
        condition_variable[thread] := FALSE;
    AcquireMutex: 
        mutex_enter(thread);
        return;
end procedure;

process a = &#34;a&#34;
begin
Loop:
while TRUE do
    AcquireMutex: mutex_enter(&#34;a&#34;);
    CheckQueueLen: 
        if Len(queue) = 0 then
            call mutex_wait(&#34;a&#34;);
        end if;
    Dequeue: dequeue();
    ReleaseMutex: mutex_exit(&#34;a&#34;);
end while;
end process;

process b = &#34;b&#34;
begin
Loop:
while TRUE do
    AcquireMutex: mutex_enter(&#34;b&#34;);
    CheckQueueLen: 
        if Len(queue) = 0 then
            call mutex_wait(&#34;b&#34;);
        end if;
    Dequeue: dequeue();
    ReleaseMutex: mutex_exit(&#34;b&#34;);
end while;
end process;

process c = &#34;c&#34;
begin
Loop:
while TRUE do
    AcquireMutex: mutex_enter(&#34;c&#34;);
    Enqueue: queue := Append(queue, 42);
    MutexPulseAll: mutex_pulse_all(&#34;c&#34;);
    ReleaseMutex: mutex_exit(&#34;c&#34;);
end while;
end process;
end algorithm; *)
====
</code></pre><table><thead><tr><th>Action</th></tr></thead><tbody><tr><td>Thread <code>a</code> acquires the mutex first, sees that the queue is empty and waits for the condition variable signal before proceeding.</td></tr><tr><td>Thread <code>c</code> acquires the mutex, adds an item to the queue, signals the condition variable and releases the mutex.</td></tr><tr><td>Thread <code>b</code> acquires the mutex before thread <code>a</code> gets to run, dequeues an item from the queue and releases the mutex.</td></tr><tr><td>Thread <code>a</code> wakes up with the mutex acquired and tries to dequeue an item but finds out that queue is empty.</td></tr></tbody></table><p><a href=https://deadlockempire.github.io/#D1-Dragonfire>Dragonfire</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  Monitor.Enter(firebreathing);
</span></span><span style=display:flex><span>  incinerate_enemies();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (fireball.Wait(<span style=color:#ae81ff>500</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Swoosh!</span>
</span></span><span style=display:flex><span>    blast_enemies();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Uh... that was tiring.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// I&#39;d better rest while I&#39;m vulnerable...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fireball.Wait(<span style=color:#ae81ff>500</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (fireball.Wait(<span style=color:#ae81ff>500</span>)) {
</span></span><span style=display:flex><span>        critical_section();
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Safe now...</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  c = c - <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  c = c + <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  Monitor.Exit(firebreathing);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// This is stupid.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// The other head gets all the cool toys,</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...and I get stuck recharging.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (c &lt; <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Let&#39;s do some damage!</span>
</span></span><span style=display:flex><span>    fireball.Release();
</span></span><span style=display:flex><span>    c++;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// I hate being in here.</span>
</span></span><span style=display:flex><span>    critical_section();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>---- MODULE spec ----
EXTENDS TLC, Integers

(*--algorithm spec
variables
    mutex = &#34;&#34;,
    critical_section = 0,
    c = 0,
    fireballs = 0;

define
    CriticalSection == critical_section &lt;= 1
end define;

macro mutex_enter(thread) begin
    await mutex = &#34;&#34;;
    mutex := thread;
end macro;

macro mutex_exit(thread) begin
    assert mutex = thread;
    mutex := &#34;&#34;;
end macro;

macro fireball_wait() begin
    if fireballs &gt; 0 then
        fireballs := fireballs - 1;
        ok := TRUE;
    else
        ok := FALSE;
    end if;
end macro;

process a = &#34;a&#34;
variables
    tmp = 0,
    ok = FALSE;
begin
Loop:
while TRUE do
    AcquireMutex: mutex_enter(&#34;a&#34;);
    \* incinerate_enemies();
    CheckFireball_1:
    fireball_wait();
    if ok then
        \* blast_enemies();
        CheckFireball_2:
        fireball_wait();
        if ok then
            CheckFireball_3:
            fireball_wait();
            if ok then
                EnterCriticalSection: critical_section := critical_section + 1;
                LeaveCriticalSection: critical_section := critical_section - 1;
            end if;
        end if;
    end if;

    LoadC_1:  tmp := c;
    DecrementC: c := tmp - 1;

    LoadC_2: tmp := c;
    IncrementC: c := tmp + 1;

    ReleaseMutex: mutex_exit(&#34;a&#34;);
end while;
end process;

process b = &#34;b&#34;
variables
    tmp = 0;
begin
Loop:
while TRUE do
    if c &lt; 2 then
        FireballRelease: fireballs := fireballs + 1;
        LoadC: tmp := c;
        IncrementC: c := tmp + 1;
    else
        EnterCriticalSection: critical_section := critical_section + 1;
        LeaveCriticalSection: critical_section := critical_section - 1;
    end if;
end while;
end process;
end algorithm; *)
====
</code></pre><p><a href=https://deadlockempire.github.io/#D2-Sorcerer>Triple danger</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  Monitor.Enter(conduit);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// I summon mana for you, dragon!</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Incinerate the enemies!</span>
</span></span><span style=display:flex><span>  energyBursts.Enqueue(<span style=color:#66d9ef>new</span> EnergyBurst());
</span></span><span style=display:flex><span>  Monitor.Exit(conduit);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (energyBursts.Count &gt; <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    Monitor.Enter(conduit);
</span></span><span style=display:flex><span>    energyBursts.Dequeue();
</span></span><span style=display:flex><span>    lightning_bolts(terrifying: <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    Monitor.Exit(conduit);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread c</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (energyBursts.Count &gt; <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    Monitor.Enter(conduit);
</span></span><span style=display:flex><span>    energyBursts.Dequeue();
</span></span><span style=display:flex><span>    fireball(mighty: <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    Monitor.Exit(conduit);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Provided without comment.</p><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>---- MODULE spec ----
EXTENDS TLC, Sequences, Integers

(*--algorithm spec
variables
    mutex = &#34;&#34;,
    queue = &lt;&lt;&gt;&gt;;

macro mutex_enter(thread) begin
    await mutex = &#34;&#34;;
    mutex := thread;
end macro;

macro mutex_exit(thread) begin
    assert mutex = thread;
    mutex := &#34;&#34;;
end macro;

macro enqueue() begin
    queue := Append(queue, &#34;v&#34;);
end macro;

macro dequeue() begin
    assert Len(queue) &gt; 0;
    queue := Tail(queue);
end macro;

process a = &#34;a&#34;
begin
Loop:
while TRUE do
    AcquireMutex: mutex_enter(&#34;a&#34;);
    Enqueue: enqueue();
    ReleaseMutex: mutex_exit(&#34;a&#34;);
end while;
end process;

process b = &#34;b&#34;
begin
Loop:
while TRUE do
    if Len(queue) &gt; 0 then
        AcquireMutex: mutex_enter(&#34;b&#34;);
        Dequeue: dequeue();
        ReleaseMutex: mutex_exit(&#34;b&#34;);
    end if;
end while;
end process;

process c = &#34;c&#34;
begin
Loop:
while TRUE do
    if Len(queue) &gt; 0 then
        AcquireMutex: mutex_enter(&#34;c&#34;);
        Dequeue: dequeue();
        ReleaseMutex: mutex_exit(&#34;c&#34;);
    end if;
end while;
end process;
end algorithm; *)
====
</code></pre><p>Provided without comment.</p><p><a href=https://deadlockempire.github.io/#D4-Boss>Boss fight</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Thread a</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  darkness++;
</span></span><span style=display:flex><span>  evil++;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (darkness != <span style=color:#ae81ff>2</span> &amp;&amp; evil != <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fortress.Wait(<span style=color:#ae81ff>500</span>)) {
</span></span><span style=display:flex><span>      fortress.Wait();
</span></span><span style=display:flex><span>      Monitor.Enter(sanctum);
</span></span><span style=display:flex><span>      Monitor.Wait(sanctum);
</span></span><span style=display:flex><span>      critical_section();
</span></span><span style=display:flex><span>      Monitor.Exit(sanctum);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Thread b</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  darkness++;
</span></span><span style=display:flex><span>  evil++;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (darkness != <span style=color:#ae81ff>2</span> &amp;&amp; evil == <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>    Monitor.Enter(sanctum);
</span></span><span style=display:flex><span>    Monitor.Pulse(sanctum);
</span></span><span style=display:flex><span>    Monitor.Exit(sanctum);
</span></span><span style=display:flex><span>    critical_section();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  fortress.Release();
</span></span><span style=display:flex><span>  darkness = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  evil = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-tlaplus data-lang=tlaplus>---- MODULE spec ----
EXTENDS TLC, Integers, Sequences

(*--algorithm spec
variables 
    mutex = &#34;&#34;,
    mutex_pulse_received = FALSE,
    darkness = 0,
    evil = 0,
    fortress = 0,
    threads_in_critical_section = 0;

define
    MutualExclusion == threads_in_critical_section &lt;= 1
end define;

macro mutex_enter(thread) begin
    await mutex = &#34;&#34;;
    mutex := thread;
end macro;

macro mutex_exit(thread) begin
    assert mutex = thread;
    mutex := &#34;&#34;;
end macro;

macro mutex_pulse(thread) begin
    assert mutex = thread;
    mutex_pulse_received := TRUE;
end macro;

macro fortress_wait(block) begin
    if block then
        await fortress &gt; 0;
    end if;

    if fortress = 0 then
        ok := FALSE;
    else
        fortress := fortress - 1;
        ok := TRUE;
    end if;
end macro;

procedure mutex_wait(thread) begin
    MutexWait_ReleaseMutex:
        assert mutex = thread;
        mutex := &#34;&#34;;
    MutexWait_WaitForPulse:
        await mutex_pulse_received = TRUE;
        mutex_pulse_received := FALSE;
    MutexWait_AcquireMutex:
        mutex_enter(thread);
    return;
end procedure;

procedure inc_darkness() 
    variables
        tmp = 0;
begin 
    Inc_Load: tmp := darkness;
    Inc_Add: darkness := tmp + 1;
    return;
end procedure;

procedure inc_evil() 
    variables
        tmp = 0;
begin 
    Inc_Load: tmp := evil;
    Inc_Add: evil := tmp + 1;
    return;
end procedure;

procedure critical_section() begin 
    CriticalSection_Enter: threads_in_critical_section := threads_in_critical_section + 1;
    CriticalSection_Leave: threads_in_critical_section := threads_in_critical_section - 1;
    return;
end procedure;

process a = &#34;a&#34;
variables 
    ok = FALSE;
begin
Loop:
while TRUE do
    IncDarkness: call inc_darkness();
    IncEvil: call inc_evil();
    Check:
    if darkness # 2 /\ evil # 2 then
        FortressWait_1: fortress_wait(FALSE);
        if ok then 
            FortressWait_2: fortress_wait(TRUE);
            DecFortress: fortress :=  fortress - 1;
            AcquireMutex: mutex_enter(&#34;a&#34;);
            MutexWait: call mutex_wait(&#34;a&#34;);
            CriticalSection: call critical_section();
            ReleaseMutex: mutex_exit(&#34;a&#34;);
        end if;
    end if;
end while;
end process;

process b = &#34;b&#34;
begin
Loop:
while TRUE do
    IncDarkness: call inc_darkness();
    IncEvil: call inc_evil();
    Check:
    if darkness # 2 /\ evil = 2 then
        AcquireMutex: mutex_enter(&#34;b&#34;);
        MutexPulse: mutex_pulse(&#34;b&#34;);
        MutexExit: mutex_exit(&#34;b&#34;);
        CriticalSection: call critical_section();
    end if;
    FortressRelease: fortress := fortress + 1;
    ResetDarkness: darkness := 0;
    ResetEvil: evil := 0;
end while;
end process;
end algorithm; *)
====
</code></pre><p>Provided without comment.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://poorlydefinedbehaviour.github.io/posts/reading_list_2023/><span class=title>Next »</span><br><span>Reading list 2023</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Model checking The Deadlock Empire on x" href="https://x.com/intent/tweet/?text=Model%20checking%20The%20Deadlock%20Empire&amp;url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fthe_deadlock_empire%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Model checking The Deadlock Empire on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fthe_deadlock_empire%2f&amp;title=Model%20checking%20The%20Deadlock%20Empire&amp;summary=Model%20checking%20The%20Deadlock%20Empire&amp;source=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fthe_deadlock_empire%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Model checking The Deadlock Empire on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fthe_deadlock_empire%2f&title=Model%20checking%20The%20Deadlock%20Empire"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Model checking The Deadlock Empire on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fthe_deadlock_empire%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Model checking The Deadlock Empire on whatsapp" href="https://api.whatsapp.com/send?text=Model%20checking%20The%20Deadlock%20Empire%20-%20https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fthe_deadlock_empire%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Model checking The Deadlock Empire on telegram" href="https://telegram.me/share/url?text=Model%20checking%20The%20Deadlock%20Empire&amp;url=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fthe_deadlock_empire%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Model checking The Deadlock Empire on ycombinator" href="https://news.ycombinator.com/submitlink?t=Model%20checking%20The%20Deadlock%20Empire&u=https%3a%2f%2fpoorlydefinedbehaviour.github.io%2fposts%2fthe_deadlock_empire%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://poorlydefinedbehaviour.github.io/></a></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>