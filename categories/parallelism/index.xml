<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Parallelism on </title>
    <link>https://poorlydefinedbehaviour.github.io/categories/parallelism/</link>
    <description>Recent content in Parallelism on </description>
    <image>
      <title></title>
      <url>https://poorlydefinedbehaviour.github.io/papermod-cover.png</url>
      <link>https://poorlydefinedbehaviour.github.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.138.0</generator>
    <language>en</language>
    <lastBuildDate>Sun, 19 Mar 2023 20:54:00 -0300</lastBuildDate>
    <atom:link href="https://poorlydefinedbehaviour.github.io/categories/parallelism/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Avoid overloading your systems: Request coalescing</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/request_coalescing/</link>
      <pubDate>Sun, 19 Mar 2023 20:54:00 -0300</pubDate>
      <guid>https://poorlydefinedbehaviour.github.io/posts/request_coalescing/</guid>
      <description>&lt;h2 id=&#34;the-problem&#34;&gt;The problem&lt;/h2&gt;
&lt;p&gt;You are developing an application backed by a database, something happens and then several of your users try to access the same content.
Several requests are sent to your backend at almost the same time and your backend hits the database once for each request to fetch the same data.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://poorlydefinedbehaviour.github.io/posts/request_coalescing/images/users_hitting_backend_at_the_same_time_1.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;fetching-the-data-only-once&#34;&gt;Fetching the data only once&lt;/h2&gt;
&lt;p&gt;If &lt;code&gt;N&lt;/code&gt; requests asking for the same data arrive at the backend at around the same time, the backend could hit the database to fetch the data when the first request arrives and force the other requests to await until the data is fetched. When a response to the request sent to the database arrives at the backend with the data, the data can be shared with the requests that are waiting for it.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Do Go programs with common data races compile in Rust?</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/rust_compile_time_safety_1/</link>
      <pubDate>Mon, 23 May 2022 20:39:07 -0300</pubDate>
      <guid>https://poorlydefinedbehaviour.github.io/posts/rust_compile_time_safety_1/</guid>
      <description>&lt;p&gt;Uber has adopted &lt;a href=&#34;https://github.com/golang/go&#34;&gt;Go&lt;/a&gt; as its primary programming language for developing microservices and has a post on its blog called &lt;a href=&#34;https://www.uber.com/en-BR/blog/data-race-patterns-in-go/&#34;&gt;Data Race Patterns in Go&lt;/a&gt; where they talk about data races found in their Go codebase.&lt;/p&gt;
&lt;p&gt;I was reading it and thought to myself that many of the problems presented in the post would not even compile in Rust. Can Rust help us avoid writing code with common data races?&lt;/p&gt;
&lt;p&gt;Examples written in Rust are not meant do be idiomatic Rust and do not wait for outputs generated by tasks for simplicity because the examples written in Go do not wait as well.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
