<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>concurrency on </title>
    <link>https://poorlydefinedbehaviour.github.io/categories/concurrency/</link>
    <description>Recent content in concurrency on </description>
    <image>
      <title></title>
      <url>https://poorlydefinedbehaviour.github.io/papermod-cover.png</url>
      <link>https://poorlydefinedbehaviour.github.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 25 Mar 2023 20:35:00 -0300</lastBuildDate><atom:link href="https://poorlydefinedbehaviour.github.io/categories/concurrency/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The simple way to avoid dead locks</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/the_simple_way_to_avoid_deadlocks/</link>
      <pubDate>Sat, 25 Mar 2023 20:35:00 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/the_simple_way_to_avoid_deadlocks/</guid>
      <description>A deadlock happens when there&amp;rsquo;s at least one resource that can be only acquired by one process at a time and there&amp;rsquo;s a process P1 that is waiting to acquire a resource currently held by a process P2 and P2 is waiting to acquire a resource currently held by P1.
Process is not being used only to refer to an OS process.
There are two processes: Process A wants to acquire a lock on resource 1 and then a lock on resource 2.</description>
    </item>
    
    <item>
      <title>Database anomalies and isolation levels</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/isolation_levels/</link>
      <pubDate>Fri, 24 Mar 2023 15:43:00 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/isolation_levels/</guid>
      <description>Anomalies An anomaly or read phenomena can happen when a transaction reads data that may have been modified by another concurrent transaction.
Dirty read A dirty read happens when a transaction T1 reads data that has been modified by a concurrent transaction T2 that has not has been committed or rolled back yet. T1 ends up working with stale data if T2 does not commit.
T2 starts executing and sets x to a new value, T1 starts executing and reads x, the value of x is the value just set by T2, T2 rolls back, the value of x is not persisted to the database but T1 will move forward with the stale value of x that was written before T2 rolled back.</description>
    </item>
    
    <item>
      <title>Avoid overloading your systems: Request coalescing</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/request_coalescing/</link>
      <pubDate>Sun, 19 Mar 2023 20:54:00 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/request_coalescing/</guid>
      <description>The problem You are developing an application backed by a database, something happens and then several of your users try to access the same content. Several requests are sent to your backend at almost the same time and your backend hits the database once for each request to fetch the same data.
Fetching the data only once If N requests asking for the same data arrive at the backend at around the same time, the backend could hit the database to fetch the data when the first request arrives and force the other requests to await until the data is fetched.</description>
    </item>
    
    <item>
      <title>Do Go programs with common data races compile in Rust?</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/rust_compile_time_safety_1/</link>
      <pubDate>Mon, 23 May 2022 20:39:07 -0300</pubDate>
      
      <guid>https://poorlydefinedbehaviour.github.io/posts/rust_compile_time_safety_1/</guid>
      <description>Uber has adopted Go as its primary programming language for developing microservices and has a post on its blog called Data Race Patterns in Go where they talk about data races found in their Go codebase.
I was reading it and thought to myself that many of the problems presented in the post would not even compile in Rust. Can Rust help us avoid writing code with common data races?</description>
    </item>
    
  </channel>
</rss>
