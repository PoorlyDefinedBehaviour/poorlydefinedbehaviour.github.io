<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Concurrency on </title>
    <link>https://poorlydefinedbehaviour.github.io/categories/concurrency/</link>
    <description>Recent content in Concurrency on </description>
    <image>
      <title></title>
      <url>https://poorlydefinedbehaviour.github.io/papermod-cover.png</url>
      <link>https://poorlydefinedbehaviour.github.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.139.2</generator>
    <language>en</language>
    <lastBuildDate>Sat, 25 Mar 2023 20:35:00 -0300</lastBuildDate>
    <atom:link href="https://poorlydefinedbehaviour.github.io/categories/concurrency/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The simple way to avoid deadlocks</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/the_simple_way_to_avoid_deadlocks/</link>
      <pubDate>Sat, 25 Mar 2023 20:35:00 -0300</pubDate>
      <guid>https://poorlydefinedbehaviour.github.io/posts/the_simple_way_to_avoid_deadlocks/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://poorlydefinedbehaviour.github.io/posts/the_simple_way_to_avoid_deadlocks/images/regular_show_deadlock_1.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;A deadlock happens when there&amp;rsquo;s at least one resource that can be only acquired by one process at a time and there&amp;rsquo;s a process &lt;code&gt;P1&lt;/code&gt; that is waiting to acquire a resource currently held by a process &lt;code&gt;P2&lt;/code&gt; and &lt;code&gt;P2&lt;/code&gt; is waiting to acquire a resource currently held by &lt;code&gt;P1&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The word &lt;code&gt;process&lt;/code&gt; does not mean we are talking about just OS processes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://poorlydefinedbehaviour.github.io/posts/the_simple_way_to_avoid_deadlocks/images/deadlock_example_1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;There are two processes: Process &lt;code&gt;A&lt;/code&gt; wants to acquire a lock on &lt;code&gt;resource 1&lt;/code&gt; and then a lock on &lt;code&gt;resource 2&lt;/code&gt;. Process &lt;code&gt;B&lt;/code&gt; wants to acquire a lock on &lt;code&gt;resource 2&lt;/code&gt; and then a lock on &lt;code&gt;resource 1&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Database anomalies and isolation levels</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/isolation_levels/</link>
      <pubDate>Fri, 24 Mar 2023 15:43:00 -0300</pubDate>
      <guid>https://poorlydefinedbehaviour.github.io/posts/isolation_levels/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://poorlydefinedbehaviour.github.io/posts/isolation_levels/images/tom_1.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;anomalies&#34;&gt;Anomalies&lt;/h2&gt;
&lt;p&gt;An anomaly or read phenomena can happen when a transaction reads data that may have been modified by another concurrent transaction.&lt;/p&gt;
&lt;h3 id=&#34;dirty-read&#34;&gt;Dirty read&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;dirty read&lt;/code&gt; happens when a transaction &lt;code&gt;T1&lt;/code&gt; reads data that has been modified by a concurrent transaction &lt;code&gt;T2&lt;/code&gt; that has not has been committed or rolled back yet. &lt;code&gt;T1&lt;/code&gt; ends up working with stale data if &lt;code&gt;T2&lt;/code&gt; does not commit.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://poorlydefinedbehaviour.github.io/posts/isolation_levels/images/dirty_read_1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;T2&lt;/code&gt; starts executing and sets &lt;code&gt;x&lt;/code&gt; to a new value, &lt;code&gt;T1&lt;/code&gt; starts executing and reads &lt;code&gt;x&lt;/code&gt;, the value of &lt;code&gt;x&lt;/code&gt; is the value just set by &lt;code&gt;T2&lt;/code&gt;, &lt;code&gt;T2&lt;/code&gt; rolls back, the value of &lt;code&gt;x&lt;/code&gt; is not persisted to the database but &lt;code&gt;T1&lt;/code&gt; will move forward with the stale value of &lt;code&gt;x&lt;/code&gt; that was written before &lt;code&gt;T2&lt;/code&gt; rolled back.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Avoid overloading your systems: Request coalescing</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/request_coalescing/</link>
      <pubDate>Sun, 19 Mar 2023 20:54:00 -0300</pubDate>
      <guid>https://poorlydefinedbehaviour.github.io/posts/request_coalescing/</guid>
      <description>&lt;h2 id=&#34;the-problem&#34;&gt;The problem&lt;/h2&gt;
&lt;p&gt;You are developing an application backed by a database, something happens and then several of your users try to access the same content.
Several requests are sent to your backend at almost the same time and your backend hits the database once for each request to fetch the same data.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://poorlydefinedbehaviour.github.io/posts/request_coalescing/images/users_hitting_backend_at_the_same_time_1.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;fetching-the-data-only-once&#34;&gt;Fetching the data only once&lt;/h2&gt;
&lt;p&gt;If &lt;code&gt;N&lt;/code&gt; requests asking for the same data arrive at the backend at around the same time, the backend could hit the database to fetch the data when the first request arrives and force the other requests to await until the data is fetched. When a response to the request sent to the database arrives at the backend with the data, the data can be shared with the requests that are waiting for it.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Do Go programs with common data races compile in Rust?</title>
      <link>https://poorlydefinedbehaviour.github.io/posts/rust_compile_time_safety_1/</link>
      <pubDate>Mon, 23 May 2022 20:39:07 -0300</pubDate>
      <guid>https://poorlydefinedbehaviour.github.io/posts/rust_compile_time_safety_1/</guid>
      <description>&lt;p&gt;Uber has adopted &lt;a href=&#34;https://github.com/golang/go&#34;&gt;Go&lt;/a&gt; as its primary programming language for developing microservices and has a post on its blog called &lt;a href=&#34;https://www.uber.com/en-BR/blog/data-race-patterns-in-go/&#34;&gt;Data Race Patterns in Go&lt;/a&gt; where they talk about data races found in their Go codebase.&lt;/p&gt;
&lt;p&gt;I was reading it and thought to myself that many of the problems presented in the post would not even compile in Rust. Can Rust help us avoid writing code with common data races?&lt;/p&gt;
&lt;p&gt;Examples written in Rust are not meant do be idiomatic Rust and do not wait for outputs generated by tasks for simplicity because the examples written in Go do not wait as well.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
